
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Property
 * 
 */
export type Property = $Result.DefaultSelection<Prisma.$PropertyPayload>
/**
 * Model Amenity
 * 
 */
export type Amenity = $Result.DefaultSelection<Prisma.$AmenityPayload>
/**
 * Model PropertyAmenity
 * 
 */
export type PropertyAmenity = $Result.DefaultSelection<Prisma.$PropertyAmenityPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model PropertyAvailability
 * 
 */
export type PropertyAvailability = $Result.DefaultSelection<Prisma.$PropertyAvailabilityPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model MaintenanceRequest
 * 
 */
export type MaintenanceRequest = $Result.DefaultSelection<Prisma.$MaintenanceRequestPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Edition
 * 
 */
export type Edition = $Result.DefaultSelection<Prisma.$EditionPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model KnowledgeArticle
 * 
 */
export type KnowledgeArticle = $Result.DefaultSelection<Prisma.$KnowledgeArticlePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model PropertyGroup
 * 
 */
export type PropertyGroup = $Result.DefaultSelection<Prisma.$PropertyGroupPayload>
/**
 * Model CleaningSchedule
 * 
 */
export type CleaningSchedule = $Result.DefaultSelection<Prisma.$CleaningSchedulePayload>
/**
 * Model PropertyAnalytics
 * 
 */
export type PropertyAnalytics = $Result.DefaultSelection<Prisma.$PropertyAnalyticsPayload>
/**
 * Model PropertyNote
 * 
 */
export type PropertyNote = $Result.DefaultSelection<Prisma.$PropertyNotePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model Content
 * 
 */
export type Content = $Result.DefaultSelection<Prisma.$ContentPayload>
/**
 * Model ContentMedia
 * 
 */
export type ContentMedia = $Result.DefaultSelection<Prisma.$ContentMediaPayload>
/**
 * Model Media
 * 
 */
export type Media = $Result.DefaultSelection<Prisma.$MediaPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model RoomContent
 * 
 */
export type RoomContent = $Result.DefaultSelection<Prisma.$RoomContentPayload>
/**
 * Model RoomAvailabilityRule
 * 
 */
export type RoomAvailabilityRule = $Result.DefaultSelection<Prisma.$RoomAvailabilityRulePayload>
/**
 * Model Inquiry
 * 
 */
export type Inquiry = $Result.DefaultSelection<Prisma.$InquiryPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  USER: 'USER',
  ADMIN: 'ADMIN',
  PROPERTY_OWNER: 'PROPERTY_OWNER',
  MANAGER: 'MANAGER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const PropertyType: {
  APARTMENT: 'APARTMENT',
  HOUSE: 'HOUSE',
  ROOM: 'ROOM',
  COMMERCIAL: 'COMMERCIAL',
  STORAGE: 'STORAGE',
  PLOT: 'PLOT',
  GARAGE: 'GARAGE',
  LUXURY: 'LUXURY',
  INVESTMENT: 'INVESTMENT'
};

export type PropertyType = (typeof PropertyType)[keyof typeof PropertyType]


export const PropertyStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  SUSPENDED: 'SUSPENDED'
};

export type PropertyStatus = (typeof PropertyStatus)[keyof typeof PropertyStatus]


export const CancellationPolicy: {
  FLEXIBLE: 'FLEXIBLE',
  MODERATE: 'MODERATE',
  STRICT: 'STRICT',
  SUPER_STRICT: 'SUPER_STRICT'
};

export type CancellationPolicy = (typeof CancellationPolicy)[keyof typeof CancellationPolicy]


export const BookingStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CHECKED_IN: 'CHECKED_IN',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const BookingSource: {
  DIRECT: 'DIRECT',
  BOOKING_COM: 'BOOKING_COM',
  AIRBNB: 'AIRBNB',
  VRBO: 'VRBO',
  EXPEDIA: 'EXPEDIA',
  MANUAL: 'MANUAL',
  OTHER: 'OTHER'
};

export type BookingSource = (typeof BookingSource)[keyof typeof BookingSource]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  PARTIALLY_REFUNDED: 'PARTIALLY_REFUNDED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const MaintenancePriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type MaintenancePriority = (typeof MaintenancePriority)[keyof typeof MaintenancePriority]


export const MaintenanceStatus: {
  OPEN: 'OPEN',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED'
};

export type MaintenanceStatus = (typeof MaintenanceStatus)[keyof typeof MaintenanceStatus]


export const MessageType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE',
  FILE: 'FILE',
  SYSTEM: 'SYSTEM'
};

export type MessageType = (typeof MessageType)[keyof typeof MessageType]


export const NotificationType: {
  BOOKING_CONFIRMED: 'BOOKING_CONFIRMED',
  BOOKING_CANCELLED: 'BOOKING_CANCELLED',
  PAYMENT_RECEIVED: 'PAYMENT_RECEIVED',
  MAINTENANCE_REQUEST: 'MAINTENANCE_REQUEST',
  REVIEW_RECEIVED: 'REVIEW_RECEIVED',
  MESSAGE_RECEIVED: 'MESSAGE_RECEIVED',
  SYSTEM_UPDATE: 'SYSTEM_UPDATE'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const ContentStatus: {
  DRAFT: 'DRAFT',
  PUBLISHED: 'PUBLISHED',
  ARCHIVED: 'ARCHIVED'
};

export type ContentStatus = (typeof ContentStatus)[keyof typeof ContentStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  APPLE_PAY: 'APPLE_PAY',
  GOOGLE_PAY: 'GOOGLE_PAY',
  PAYPAL: 'PAYPAL',
  BANK_TRANSFER: 'BANK_TRANSFER',
  STRIPE_LINK: 'STRIPE_LINK'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const RoomType: {
  BEDROOM: 'BEDROOM',
  LIVING_ROOM: 'LIVING_ROOM',
  STUDIO: 'STUDIO',
  KITCHEN: 'KITCHEN',
  BATHROOM: 'BATHROOM',
  BALCONY: 'BALCONY',
  TERRACE: 'TERRACE',
  GARDEN: 'GARDEN',
  OTHER: 'OTHER',
  APARTMENT: 'APARTMENT'
};

export type RoomType = (typeof RoomType)[keyof typeof RoomType]


export const CleaningFrequency: {
  AFTER_EACH_BOOKING: 'AFTER_EACH_BOOKING',
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  BIWEEKLY: 'BIWEEKLY',
  MONTHLY: 'MONTHLY',
  CUSTOM: 'CUSTOM'
};

export type CleaningFrequency = (typeof CleaningFrequency)[keyof typeof CleaningFrequency]


export const AnalyticsPeriod: {
  DAILY: 'DAILY',
  WEEKLY: 'WEEKLY',
  MONTHLY: 'MONTHLY',
  QUARTERLY: 'QUARTERLY',
  YEARLY: 'YEARLY'
};

export type AnalyticsPeriod = (typeof AnalyticsPeriod)[keyof typeof AnalyticsPeriod]


export const NoteType: {
  OWNER_NOTE: 'OWNER_NOTE',
  MAINTENANCE_NOTE: 'MAINTENANCE_NOTE',
  GUEST_PREFERENCE: 'GUEST_PREFERENCE',
  BUSINESS_NOTE: 'BUSINESS_NOTE',
  ADMIN_NOTE: 'ADMIN_NOTE'
};

export type NoteType = (typeof NoteType)[keyof typeof NoteType]


export const ContentType: {
  TEXT: 'TEXT',
  HTML: 'HTML',
  MARKDOWN: 'MARKDOWN',
  JSON: 'JSON',
  IMAGE: 'IMAGE',
  GALLERY: 'GALLERY',
  HERO: 'HERO'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const MediaCategory: {
  ROOMS: 'ROOMS',
  COMMON_AREAS: 'COMMON_AREAS',
  AMENITIES: 'AMENITIES',
  GALLERY: 'GALLERY',
  HERO: 'HERO',
  LOGO: 'LOGO',
  GENERAL: 'GENERAL'
};

export type MediaCategory = (typeof MediaCategory)[keyof typeof MediaCategory]


export const SettingType: {
  STRING: 'STRING',
  NUMBER: 'NUMBER',
  BOOLEAN: 'BOOLEAN',
  JSON: 'JSON'
};

export type SettingType = (typeof SettingType)[keyof typeof SettingType]


export const InquiryStatus: {
  NEW: 'NEW',
  IN_PROGRESS: 'IN_PROGRESS',
  RESPONDED: 'RESPONDED',
  CLOSED: 'CLOSED',
  SPAM: 'SPAM'
};

export type InquiryStatus = (typeof InquiryStatus)[keyof typeof InquiryStatus]


export const InquiryPriority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type InquiryPriority = (typeof InquiryPriority)[keyof typeof InquiryPriority]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type PropertyType = $Enums.PropertyType

export const PropertyType: typeof $Enums.PropertyType

export type PropertyStatus = $Enums.PropertyStatus

export const PropertyStatus: typeof $Enums.PropertyStatus

export type CancellationPolicy = $Enums.CancellationPolicy

export const CancellationPolicy: typeof $Enums.CancellationPolicy

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type BookingSource = $Enums.BookingSource

export const BookingSource: typeof $Enums.BookingSource

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type MaintenancePriority = $Enums.MaintenancePriority

export const MaintenancePriority: typeof $Enums.MaintenancePriority

export type MaintenanceStatus = $Enums.MaintenanceStatus

export const MaintenanceStatus: typeof $Enums.MaintenanceStatus

export type MessageType = $Enums.MessageType

export const MessageType: typeof $Enums.MessageType

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type ContentStatus = $Enums.ContentStatus

export const ContentStatus: typeof $Enums.ContentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type RoomType = $Enums.RoomType

export const RoomType: typeof $Enums.RoomType

export type CleaningFrequency = $Enums.CleaningFrequency

export const CleaningFrequency: typeof $Enums.CleaningFrequency

export type AnalyticsPeriod = $Enums.AnalyticsPeriod

export const AnalyticsPeriod: typeof $Enums.AnalyticsPeriod

export type NoteType = $Enums.NoteType

export const NoteType: typeof $Enums.NoteType

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type MediaCategory = $Enums.MediaCategory

export const MediaCategory: typeof $Enums.MediaCategory

export type SettingType = $Enums.SettingType

export const SettingType: typeof $Enums.SettingType

export type InquiryStatus = $Enums.InquiryStatus

export const InquiryStatus: typeof $Enums.InquiryStatus

export type InquiryPriority = $Enums.InquiryPriority

export const InquiryPriority: typeof $Enums.InquiryPriority

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.property`: Exposes CRUD operations for the **Property** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Properties
    * const properties = await prisma.property.findMany()
    * ```
    */
  get property(): Prisma.PropertyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenity`: Exposes CRUD operations for the **Amenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenity.findMany()
    * ```
    */
  get amenity(): Prisma.AmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyAmenity`: Exposes CRUD operations for the **PropertyAmenity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAmenities
    * const propertyAmenities = await prisma.propertyAmenity.findMany()
    * ```
    */
  get propertyAmenity(): Prisma.PropertyAmenityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyAvailability`: Exposes CRUD operations for the **PropertyAvailability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAvailabilities
    * const propertyAvailabilities = await prisma.propertyAvailability.findMany()
    * ```
    */
  get propertyAvailability(): Prisma.PropertyAvailabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.maintenanceRequest`: Exposes CRUD operations for the **MaintenanceRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MaintenanceRequests
    * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
    * ```
    */
  get maintenanceRequest(): Prisma.MaintenanceRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.edition`: Exposes CRUD operations for the **Edition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Editions
    * const editions = await prisma.edition.findMany()
    * ```
    */
  get edition(): Prisma.EditionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.knowledgeArticle`: Exposes CRUD operations for the **KnowledgeArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more KnowledgeArticles
    * const knowledgeArticles = await prisma.knowledgeArticle.findMany()
    * ```
    */
  get knowledgeArticle(): Prisma.KnowledgeArticleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyGroup`: Exposes CRUD operations for the **PropertyGroup** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyGroups
    * const propertyGroups = await prisma.propertyGroup.findMany()
    * ```
    */
  get propertyGroup(): Prisma.PropertyGroupDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cleaningSchedule`: Exposes CRUD operations for the **CleaningSchedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CleaningSchedules
    * const cleaningSchedules = await prisma.cleaningSchedule.findMany()
    * ```
    */
  get cleaningSchedule(): Prisma.CleaningScheduleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyAnalytics`: Exposes CRUD operations for the **PropertyAnalytics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyAnalytics
    * const propertyAnalytics = await prisma.propertyAnalytics.findMany()
    * ```
    */
  get propertyAnalytics(): Prisma.PropertyAnalyticsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.propertyNote`: Exposes CRUD operations for the **PropertyNote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PropertyNotes
    * const propertyNotes = await prisma.propertyNote.findMany()
    * ```
    */
  get propertyNote(): Prisma.PropertyNoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.content`: Exposes CRUD operations for the **Content** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contents
    * const contents = await prisma.content.findMany()
    * ```
    */
  get content(): Prisma.ContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contentMedia`: Exposes CRUD operations for the **ContentMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContentMedias
    * const contentMedias = await prisma.contentMedia.findMany()
    * ```
    */
  get contentMedia(): Prisma.ContentMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.media`: Exposes CRUD operations for the **Media** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Media
    * const media = await prisma.media.findMany()
    * ```
    */
  get media(): Prisma.MediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomContent`: Exposes CRUD operations for the **RoomContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomContents
    * const roomContents = await prisma.roomContent.findMany()
    * ```
    */
  get roomContent(): Prisma.RoomContentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roomAvailabilityRule`: Exposes CRUD operations for the **RoomAvailabilityRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoomAvailabilityRules
    * const roomAvailabilityRules = await prisma.roomAvailabilityRule.findMany()
    * ```
    */
  get roomAvailabilityRule(): Prisma.RoomAvailabilityRuleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inquiry`: Exposes CRUD operations for the **Inquiry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Inquiries
    * const inquiries = await prisma.inquiry.findMany()
    * ```
    */
  get inquiry(): Prisma.InquiryDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Property: 'Property',
    Amenity: 'Amenity',
    PropertyAmenity: 'PropertyAmenity',
    Booking: 'Booking',
    PropertyAvailability: 'PropertyAvailability',
    Review: 'Review',
    MaintenanceRequest: 'MaintenanceRequest',
    Message: 'Message',
    Notification: 'Notification',
    Edition: 'Edition',
    Service: 'Service',
    KnowledgeArticle: 'KnowledgeArticle',
    Payment: 'Payment',
    Room: 'Room',
    PropertyGroup: 'PropertyGroup',
    CleaningSchedule: 'CleaningSchedule',
    PropertyAnalytics: 'PropertyAnalytics',
    PropertyNote: 'PropertyNote',
    AuditLog: 'AuditLog',
    Content: 'Content',
    ContentMedia: 'ContentMedia',
    Media: 'Media',
    Setting: 'Setting',
    RoomContent: 'RoomContent',
    RoomAvailabilityRule: 'RoomAvailabilityRule',
    Inquiry: 'Inquiry'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "property" | "amenity" | "propertyAmenity" | "booking" | "propertyAvailability" | "review" | "maintenanceRequest" | "message" | "notification" | "edition" | "service" | "knowledgeArticle" | "payment" | "room" | "propertyGroup" | "cleaningSchedule" | "propertyAnalytics" | "propertyNote" | "auditLog" | "content" | "contentMedia" | "media" | "setting" | "roomContent" | "roomAvailabilityRule" | "inquiry"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Property: {
        payload: Prisma.$PropertyPayload<ExtArgs>
        fields: Prisma.PropertyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findFirst: {
            args: Prisma.PropertyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          findMany: {
            args: Prisma.PropertyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          create: {
            args: Prisma.PropertyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          createMany: {
            args: Prisma.PropertyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          delete: {
            args: Prisma.PropertyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          update: {
            args: Prisma.PropertyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          deleteMany: {
            args: Prisma.PropertyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>[]
          }
          upsert: {
            args: Prisma.PropertyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyPayload>
          }
          aggregate: {
            args: Prisma.PropertyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProperty>
          }
          groupBy: {
            args: Prisma.PropertyGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyCountAggregateOutputType> | number
          }
        }
      }
      Amenity: {
        payload: Prisma.$AmenityPayload<ExtArgs>
        fields: Prisma.AmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findFirst: {
            args: Prisma.AmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          findMany: {
            args: Prisma.AmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          create: {
            args: Prisma.AmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          createMany: {
            args: Prisma.AmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          delete: {
            args: Prisma.AmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          update: {
            args: Prisma.AmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          deleteMany: {
            args: Prisma.AmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>[]
          }
          upsert: {
            args: Prisma.AmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenityPayload>
          }
          aggregate: {
            args: Prisma.AmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenity>
          }
          groupBy: {
            args: Prisma.AmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenityCountArgs<ExtArgs>
            result: $Utils.Optional<AmenityCountAggregateOutputType> | number
          }
        }
      }
      PropertyAmenity: {
        payload: Prisma.$PropertyAmenityPayload<ExtArgs>
        fields: Prisma.PropertyAmenityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAmenityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAmenityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
          }
          findFirst: {
            args: Prisma.PropertyAmenityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAmenityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
          }
          findMany: {
            args: Prisma.PropertyAmenityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>[]
          }
          create: {
            args: Prisma.PropertyAmenityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
          }
          createMany: {
            args: Prisma.PropertyAmenityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAmenityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>[]
          }
          delete: {
            args: Prisma.PropertyAmenityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
          }
          update: {
            args: Prisma.PropertyAmenityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAmenityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAmenityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyAmenityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>[]
          }
          upsert: {
            args: Prisma.PropertyAmenityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAmenityPayload>
          }
          aggregate: {
            args: Prisma.PropertyAmenityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAmenity>
          }
          groupBy: {
            args: Prisma.PropertyAmenityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAmenityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAmenityCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAmenityCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      PropertyAvailability: {
        payload: Prisma.$PropertyAvailabilityPayload<ExtArgs>
        fields: Prisma.PropertyAvailabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAvailabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAvailabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>
          }
          findFirst: {
            args: Prisma.PropertyAvailabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAvailabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>
          }
          findMany: {
            args: Prisma.PropertyAvailabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>[]
          }
          create: {
            args: Prisma.PropertyAvailabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>
          }
          createMany: {
            args: Prisma.PropertyAvailabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAvailabilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>[]
          }
          delete: {
            args: Prisma.PropertyAvailabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>
          }
          update: {
            args: Prisma.PropertyAvailabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAvailabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAvailabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyAvailabilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>[]
          }
          upsert: {
            args: Prisma.PropertyAvailabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAvailabilityPayload>
          }
          aggregate: {
            args: Prisma.PropertyAvailabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAvailability>
          }
          groupBy: {
            args: Prisma.PropertyAvailabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAvailabilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAvailabilityCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAvailabilityCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      MaintenanceRequest: {
        payload: Prisma.$MaintenanceRequestPayload<ExtArgs>
        fields: Prisma.MaintenanceRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaintenanceRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findFirst: {
            args: Prisma.MaintenanceRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          findMany: {
            args: Prisma.MaintenanceRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          create: {
            args: Prisma.MaintenanceRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          createMany: {
            args: Prisma.MaintenanceRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          delete: {
            args: Prisma.MaintenanceRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          update: {
            args: Prisma.MaintenanceRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          deleteMany: {
            args: Prisma.MaintenanceRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaintenanceRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>[]
          }
          upsert: {
            args: Prisma.MaintenanceRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaintenanceRequestPayload>
          }
          aggregate: {
            args: Prisma.MaintenanceRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaintenanceRequest>
          }
          groupBy: {
            args: Prisma.MaintenanceRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaintenanceRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MaintenanceRequestCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Edition: {
        payload: Prisma.$EditionPayload<ExtArgs>
        fields: Prisma.EditionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EditionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EditionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>
          }
          findFirst: {
            args: Prisma.EditionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EditionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>
          }
          findMany: {
            args: Prisma.EditionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>[]
          }
          create: {
            args: Prisma.EditionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>
          }
          createMany: {
            args: Prisma.EditionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EditionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>[]
          }
          delete: {
            args: Prisma.EditionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>
          }
          update: {
            args: Prisma.EditionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>
          }
          deleteMany: {
            args: Prisma.EditionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EditionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EditionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>[]
          }
          upsert: {
            args: Prisma.EditionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EditionPayload>
          }
          aggregate: {
            args: Prisma.EditionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEdition>
          }
          groupBy: {
            args: Prisma.EditionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EditionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EditionCountArgs<ExtArgs>
            result: $Utils.Optional<EditionCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      KnowledgeArticle: {
        payload: Prisma.$KnowledgeArticlePayload<ExtArgs>
        fields: Prisma.KnowledgeArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.KnowledgeArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          findFirst: {
            args: Prisma.KnowledgeArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          findMany: {
            args: Prisma.KnowledgeArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          create: {
            args: Prisma.KnowledgeArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          createMany: {
            args: Prisma.KnowledgeArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          delete: {
            args: Prisma.KnowledgeArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          update: {
            args: Prisma.KnowledgeArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          deleteMany: {
            args: Prisma.KnowledgeArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.KnowledgeArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.KnowledgeArticleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>[]
          }
          upsert: {
            args: Prisma.KnowledgeArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$KnowledgeArticlePayload>
          }
          aggregate: {
            args: Prisma.KnowledgeArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateKnowledgeArticle>
          }
          groupBy: {
            args: Prisma.KnowledgeArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.KnowledgeArticleCountArgs<ExtArgs>
            result: $Utils.Optional<KnowledgeArticleCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      PropertyGroup: {
        payload: Prisma.$PropertyGroupPayload<ExtArgs>
        fields: Prisma.PropertyGroupFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyGroupFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyGroupFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          findFirst: {
            args: Prisma.PropertyGroupFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyGroupFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          findMany: {
            args: Prisma.PropertyGroupFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>[]
          }
          create: {
            args: Prisma.PropertyGroupCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          createMany: {
            args: Prisma.PropertyGroupCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyGroupCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>[]
          }
          delete: {
            args: Prisma.PropertyGroupDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          update: {
            args: Prisma.PropertyGroupUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          deleteMany: {
            args: Prisma.PropertyGroupDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyGroupUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyGroupUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>[]
          }
          upsert: {
            args: Prisma.PropertyGroupUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyGroupPayload>
          }
          aggregate: {
            args: Prisma.PropertyGroupAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyGroup>
          }
          groupBy: {
            args: Prisma.PropertyGroupGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyGroupCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyGroupCountAggregateOutputType> | number
          }
        }
      }
      CleaningSchedule: {
        payload: Prisma.$CleaningSchedulePayload<ExtArgs>
        fields: Prisma.CleaningScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CleaningScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CleaningScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>
          }
          findFirst: {
            args: Prisma.CleaningScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CleaningScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>
          }
          findMany: {
            args: Prisma.CleaningScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>[]
          }
          create: {
            args: Prisma.CleaningScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>
          }
          createMany: {
            args: Prisma.CleaningScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CleaningScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>[]
          }
          delete: {
            args: Prisma.CleaningScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>
          }
          update: {
            args: Prisma.CleaningScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>
          }
          deleteMany: {
            args: Prisma.CleaningScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CleaningScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CleaningScheduleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>[]
          }
          upsert: {
            args: Prisma.CleaningScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CleaningSchedulePayload>
          }
          aggregate: {
            args: Prisma.CleaningScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCleaningSchedule>
          }
          groupBy: {
            args: Prisma.CleaningScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<CleaningScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.CleaningScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<CleaningScheduleCountAggregateOutputType> | number
          }
        }
      }
      PropertyAnalytics: {
        payload: Prisma.$PropertyAnalyticsPayload<ExtArgs>
        fields: Prisma.PropertyAnalyticsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyAnalyticsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyAnalyticsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>
          }
          findFirst: {
            args: Prisma.PropertyAnalyticsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyAnalyticsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>
          }
          findMany: {
            args: Prisma.PropertyAnalyticsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>[]
          }
          create: {
            args: Prisma.PropertyAnalyticsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>
          }
          createMany: {
            args: Prisma.PropertyAnalyticsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyAnalyticsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>[]
          }
          delete: {
            args: Prisma.PropertyAnalyticsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>
          }
          update: {
            args: Prisma.PropertyAnalyticsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>
          }
          deleteMany: {
            args: Prisma.PropertyAnalyticsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyAnalyticsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyAnalyticsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>[]
          }
          upsert: {
            args: Prisma.PropertyAnalyticsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyAnalyticsPayload>
          }
          aggregate: {
            args: Prisma.PropertyAnalyticsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyAnalytics>
          }
          groupBy: {
            args: Prisma.PropertyAnalyticsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyAnalyticsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyAnalyticsCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyAnalyticsCountAggregateOutputType> | number
          }
        }
      }
      PropertyNote: {
        payload: Prisma.$PropertyNotePayload<ExtArgs>
        fields: Prisma.PropertyNoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PropertyNoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PropertyNoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>
          }
          findFirst: {
            args: Prisma.PropertyNoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PropertyNoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>
          }
          findMany: {
            args: Prisma.PropertyNoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>[]
          }
          create: {
            args: Prisma.PropertyNoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>
          }
          createMany: {
            args: Prisma.PropertyNoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PropertyNoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>[]
          }
          delete: {
            args: Prisma.PropertyNoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>
          }
          update: {
            args: Prisma.PropertyNoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>
          }
          deleteMany: {
            args: Prisma.PropertyNoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PropertyNoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PropertyNoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>[]
          }
          upsert: {
            args: Prisma.PropertyNoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PropertyNotePayload>
          }
          aggregate: {
            args: Prisma.PropertyNoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePropertyNote>
          }
          groupBy: {
            args: Prisma.PropertyNoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PropertyNoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PropertyNoteCountArgs<ExtArgs>
            result: $Utils.Optional<PropertyNoteCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      Content: {
        payload: Prisma.$ContentPayload<ExtArgs>
        fields: Prisma.ContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findFirst: {
            args: Prisma.ContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          findMany: {
            args: Prisma.ContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          create: {
            args: Prisma.ContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          createMany: {
            args: Prisma.ContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          delete: {
            args: Prisma.ContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          update: {
            args: Prisma.ContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          deleteMany: {
            args: Prisma.ContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>[]
          }
          upsert: {
            args: Prisma.ContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentPayload>
          }
          aggregate: {
            args: Prisma.ContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContent>
          }
          groupBy: {
            args: Prisma.ContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentCountArgs<ExtArgs>
            result: $Utils.Optional<ContentCountAggregateOutputType> | number
          }
        }
      }
      ContentMedia: {
        payload: Prisma.$ContentMediaPayload<ExtArgs>
        fields: Prisma.ContentMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContentMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContentMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>
          }
          findFirst: {
            args: Prisma.ContentMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContentMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>
          }
          findMany: {
            args: Prisma.ContentMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>[]
          }
          create: {
            args: Prisma.ContentMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>
          }
          createMany: {
            args: Prisma.ContentMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContentMediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>[]
          }
          delete: {
            args: Prisma.ContentMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>
          }
          update: {
            args: Prisma.ContentMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>
          }
          deleteMany: {
            args: Prisma.ContentMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContentMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContentMediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>[]
          }
          upsert: {
            args: Prisma.ContentMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContentMediaPayload>
          }
          aggregate: {
            args: Prisma.ContentMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContentMedia>
          }
          groupBy: {
            args: Prisma.ContentMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContentMediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContentMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ContentMediaCountAggregateOutputType> | number
          }
        }
      }
      Media: {
        payload: Prisma.$MediaPayload<ExtArgs>
        fields: Prisma.MediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findFirst: {
            args: Prisma.MediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          findMany: {
            args: Prisma.MediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          create: {
            args: Prisma.MediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          createMany: {
            args: Prisma.MediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          delete: {
            args: Prisma.MediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          update: {
            args: Prisma.MediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          deleteMany: {
            args: Prisma.MediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>[]
          }
          upsert: {
            args: Prisma.MediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaPayload>
          }
          aggregate: {
            args: Prisma.MediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedia>
          }
          groupBy: {
            args: Prisma.MediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaCountArgs<ExtArgs>
            result: $Utils.Optional<MediaCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SettingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      RoomContent: {
        payload: Prisma.$RoomContentPayload<ExtArgs>
        fields: Prisma.RoomContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>
          }
          findFirst: {
            args: Prisma.RoomContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>
          }
          findMany: {
            args: Prisma.RoomContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>[]
          }
          create: {
            args: Prisma.RoomContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>
          }
          createMany: {
            args: Prisma.RoomContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>[]
          }
          delete: {
            args: Prisma.RoomContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>
          }
          update: {
            args: Prisma.RoomContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>
          }
          deleteMany: {
            args: Prisma.RoomContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomContentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>[]
          }
          upsert: {
            args: Prisma.RoomContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomContentPayload>
          }
          aggregate: {
            args: Prisma.RoomContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomContent>
          }
          groupBy: {
            args: Prisma.RoomContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomContentCountArgs<ExtArgs>
            result: $Utils.Optional<RoomContentCountAggregateOutputType> | number
          }
        }
      }
      RoomAvailabilityRule: {
        payload: Prisma.$RoomAvailabilityRulePayload<ExtArgs>
        fields: Prisma.RoomAvailabilityRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomAvailabilityRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomAvailabilityRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>
          }
          findFirst: {
            args: Prisma.RoomAvailabilityRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomAvailabilityRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>
          }
          findMany: {
            args: Prisma.RoomAvailabilityRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>[]
          }
          create: {
            args: Prisma.RoomAvailabilityRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>
          }
          createMany: {
            args: Prisma.RoomAvailabilityRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomAvailabilityRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>[]
          }
          delete: {
            args: Prisma.RoomAvailabilityRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>
          }
          update: {
            args: Prisma.RoomAvailabilityRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>
          }
          deleteMany: {
            args: Prisma.RoomAvailabilityRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomAvailabilityRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RoomAvailabilityRuleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>[]
          }
          upsert: {
            args: Prisma.RoomAvailabilityRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomAvailabilityRulePayload>
          }
          aggregate: {
            args: Prisma.RoomAvailabilityRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoomAvailabilityRule>
          }
          groupBy: {
            args: Prisma.RoomAvailabilityRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomAvailabilityRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomAvailabilityRuleCountArgs<ExtArgs>
            result: $Utils.Optional<RoomAvailabilityRuleCountAggregateOutputType> | number
          }
        }
      }
      Inquiry: {
        payload: Prisma.$InquiryPayload<ExtArgs>
        fields: Prisma.InquiryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InquiryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InquiryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findFirst: {
            args: Prisma.InquiryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InquiryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          findMany: {
            args: Prisma.InquiryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          create: {
            args: Prisma.InquiryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          createMany: {
            args: Prisma.InquiryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InquiryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          delete: {
            args: Prisma.InquiryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          update: {
            args: Prisma.InquiryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          deleteMany: {
            args: Prisma.InquiryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InquiryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InquiryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>[]
          }
          upsert: {
            args: Prisma.InquiryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InquiryPayload>
          }
          aggregate: {
            args: Prisma.InquiryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInquiry>
          }
          groupBy: {
            args: Prisma.InquiryGroupByArgs<ExtArgs>
            result: $Utils.Optional<InquiryGroupByOutputType>[]
          }
          count: {
            args: Prisma.InquiryCountArgs<ExtArgs>
            result: $Utils.Optional<InquiryCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    property?: PropertyOmit
    amenity?: AmenityOmit
    propertyAmenity?: PropertyAmenityOmit
    booking?: BookingOmit
    propertyAvailability?: PropertyAvailabilityOmit
    review?: ReviewOmit
    maintenanceRequest?: MaintenanceRequestOmit
    message?: MessageOmit
    notification?: NotificationOmit
    edition?: EditionOmit
    service?: ServiceOmit
    knowledgeArticle?: KnowledgeArticleOmit
    payment?: PaymentOmit
    room?: RoomOmit
    propertyGroup?: PropertyGroupOmit
    cleaningSchedule?: CleaningScheduleOmit
    propertyAnalytics?: PropertyAnalyticsOmit
    propertyNote?: PropertyNoteOmit
    auditLog?: AuditLogOmit
    content?: ContentOmit
    contentMedia?: ContentMediaOmit
    media?: MediaOmit
    setting?: SettingOmit
    roomContent?: RoomContentOmit
    roomAvailabilityRule?: RoomAvailabilityRuleOmit
    inquiry?: InquiryOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    properties: number
    bookings: number
    reviews: number
    notifications: number
    messages: number
    auditLogs: number
    propertyGroups: number
    rooms: number
    cleaningSchedules: number
    inquiries: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | UserCountOutputTypeCountPropertiesArgs
    bookings?: boolean | UserCountOutputTypeCountBookingsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    messages?: boolean | UserCountOutputTypeCountMessagesArgs
    auditLogs?: boolean | UserCountOutputTypeCountAuditLogsArgs
    propertyGroups?: boolean | UserCountOutputTypeCountPropertyGroupsArgs
    rooms?: boolean | UserCountOutputTypeCountRoomsArgs
    cleaningSchedules?: boolean | UserCountOutputTypeCountCleaningSchedulesArgs
    inquiries?: boolean | UserCountOutputTypeCountInquiriesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPropertyGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCleaningSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningScheduleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }


  /**
   * Count Type PropertyCountOutputType
   */

  export type PropertyCountOutputType = {
    bookings: number
    reviews: number
    amenities: number
    availability: number
    maintenance: number
    rooms: number
    notes: number
    analytics: number
    cleaningSchedules: number
    payments: number
    inquiries: number
  }

  export type PropertyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | PropertyCountOutputTypeCountBookingsArgs
    reviews?: boolean | PropertyCountOutputTypeCountReviewsArgs
    amenities?: boolean | PropertyCountOutputTypeCountAmenitiesArgs
    availability?: boolean | PropertyCountOutputTypeCountAvailabilityArgs
    maintenance?: boolean | PropertyCountOutputTypeCountMaintenanceArgs
    rooms?: boolean | PropertyCountOutputTypeCountRoomsArgs
    notes?: boolean | PropertyCountOutputTypeCountNotesArgs
    analytics?: boolean | PropertyCountOutputTypeCountAnalyticsArgs
    cleaningSchedules?: boolean | PropertyCountOutputTypeCountCleaningSchedulesArgs
    payments?: boolean | PropertyCountOutputTypeCountPaymentsArgs
    inquiries?: boolean | PropertyCountOutputTypeCountInquiriesArgs
  }

  // Custom InputTypes
  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyCountOutputType
     */
    select?: PropertyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAmenityWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAvailabilityWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountNotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyNoteWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountAnalyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAnalyticsWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountCleaningSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningScheduleWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * PropertyCountOutputType without action
   */
  export type PropertyCountOutputTypeCountInquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
  }


  /**
   * Count Type AmenityCountOutputType
   */

  export type AmenityCountOutputType = {
    properties: number
  }

  export type AmenityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | AmenityCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenityCountOutputType
     */
    select?: AmenityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenityCountOutputType without action
   */
  export type AmenityCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAmenityWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payments: number
    reviews: number
    messages: number
    maintenance: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | BookingCountOutputTypeCountPaymentsArgs
    reviews?: boolean | BookingCountOutputTypeCountReviewsArgs
    messages?: boolean | BookingCountOutputTypeCountMessagesArgs
    maintenance?: boolean | BookingCountOutputTypeCountMaintenanceArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountMaintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
  }


  /**
   * Count Type RoomCountOutputType
   */

  export type RoomCountOutputType = {
    availabilityRules: number
  }

  export type RoomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    availabilityRules?: boolean | RoomCountOutputTypeCountAvailabilityRulesArgs
  }

  // Custom InputTypes
  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomCountOutputType
     */
    select?: RoomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoomCountOutputType without action
   */
  export type RoomCountOutputTypeCountAvailabilityRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAvailabilityRuleWhereInput
  }


  /**
   * Count Type PropertyGroupCountOutputType
   */

  export type PropertyGroupCountOutputType = {
    properties: number
  }

  export type PropertyGroupCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | PropertyGroupCountOutputTypeCountPropertiesArgs
  }

  // Custom InputTypes
  /**
   * PropertyGroupCountOutputType without action
   */
  export type PropertyGroupCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroupCountOutputType
     */
    select?: PropertyGroupCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PropertyGroupCountOutputType without action
   */
  export type PropertyGroupCountOutputTypeCountPropertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
  }


  /**
   * Count Type ContentCountOutputType
   */

  export type ContentCountOutputType = {
    media: number
  }

  export type ContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | ContentCountOutputTypeCountMediaArgs
  }

  // Custom InputTypes
  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentCountOutputType
     */
    select?: ContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContentCountOutputType without action
   */
  export type ContentCountOutputTypeCountMediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentMediaWhereInput
  }


  /**
   * Count Type MediaCountOutputType
   */

  export type MediaCountOutputType = {
    content: number
  }

  export type MediaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | MediaCountOutputTypeCountContentArgs
  }

  // Custom InputTypes
  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaCountOutputType
     */
    select?: MediaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MediaCountOutputType without action
   */
  export type MediaCountOutputTypeCountContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentMediaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole | null
    avatar: string | null
    isActive: boolean | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    stripeAccountId: string | null
    stripeAccountStatus: string | null
    preferredCurrency: string | null
    preferredLanguage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    name: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole | null
    avatar: string | null
    isActive: boolean | null
    mfaEnabled: boolean | null
    mfaSecret: string | null
    emailVerified: boolean | null
    phoneVerified: boolean | null
    stripeAccountId: string | null
    stripeAccountStatus: string | null
    preferredCurrency: string | null
    preferredLanguage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    name: number
    phone: number
    password: number
    role: number
    avatar: number
    isActive: number
    mfaEnabled: number
    mfaSecret: number
    mfaBackupCodes: number
    emailVerified: number
    phoneVerified: number
    stripeAccountId: number
    stripeAccountStatus: number
    preferredCurrency: number
    preferredLanguage: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    password?: true
    role?: true
    avatar?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    emailVerified?: true
    phoneVerified?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    preferredCurrency?: true
    preferredLanguage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    password?: true
    role?: true
    avatar?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    emailVerified?: true
    phoneVerified?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    preferredCurrency?: true
    preferredLanguage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    name?: true
    phone?: true
    password?: true
    role?: true
    avatar?: true
    isActive?: true
    mfaEnabled?: true
    mfaSecret?: true
    mfaBackupCodes?: true
    emailVerified?: true
    phoneVerified?: true
    stripeAccountId?: true
    stripeAccountStatus?: true
    preferredCurrency?: true
    preferredLanguage?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    name: string | null
    phone: string | null
    password: string | null
    role: $Enums.UserRole
    avatar: string | null
    isActive: boolean
    mfaEnabled: boolean
    mfaSecret: string | null
    mfaBackupCodes: JsonValue | null
    emailVerified: boolean
    phoneVerified: boolean
    stripeAccountId: string | null
    stripeAccountStatus: string | null
    preferredCurrency: string | null
    preferredLanguage: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    avatar?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    preferredCurrency?: boolean
    preferredLanguage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    properties?: boolean | User$propertiesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    propertyGroups?: boolean | User$propertyGroupsArgs<ExtArgs>
    rooms?: boolean | User$roomsArgs<ExtArgs>
    cleaningSchedules?: boolean | User$cleaningSchedulesArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    avatar?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    preferredCurrency?: boolean
    preferredLanguage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    avatar?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    preferredCurrency?: boolean
    preferredLanguage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    name?: boolean
    phone?: boolean
    password?: boolean
    role?: boolean
    avatar?: boolean
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: boolean
    mfaBackupCodes?: boolean
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: boolean
    stripeAccountStatus?: boolean
    preferredCurrency?: boolean
    preferredLanguage?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "name" | "phone" | "password" | "role" | "avatar" | "isActive" | "mfaEnabled" | "mfaSecret" | "mfaBackupCodes" | "emailVerified" | "phoneVerified" | "stripeAccountId" | "stripeAccountStatus" | "preferredCurrency" | "preferredLanguage" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | User$propertiesArgs<ExtArgs>
    bookings?: boolean | User$bookingsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    messages?: boolean | User$messagesArgs<ExtArgs>
    auditLogs?: boolean | User$auditLogsArgs<ExtArgs>
    propertyGroups?: boolean | User$propertyGroupsArgs<ExtArgs>
    rooms?: boolean | User$roomsArgs<ExtArgs>
    cleaningSchedules?: boolean | User$cleaningSchedulesArgs<ExtArgs>
    inquiries?: boolean | User$inquiriesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      properties: Prisma.$PropertyPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      auditLogs: Prisma.$AuditLogPayload<ExtArgs>[]
      propertyGroups: Prisma.$PropertyGroupPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      cleaningSchedules: Prisma.$CleaningSchedulePayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      name: string | null
      phone: string | null
      password: string | null
      role: $Enums.UserRole
      avatar: string | null
      isActive: boolean
      mfaEnabled: boolean
      mfaSecret: string | null
      mfaBackupCodes: Prisma.JsonValue | null
      emailVerified: boolean
      phoneVerified: boolean
      stripeAccountId: string | null
      stripeAccountStatus: string | null
      preferredCurrency: string | null
      preferredLanguage: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends User$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, User$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends User$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends User$messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    auditLogs<T extends User$auditLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$auditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyGroups<T extends User$propertyGroupsArgs<ExtArgs> = {}>(args?: Subset<T, User$propertyGroupsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rooms<T extends User$roomsArgs<ExtArgs> = {}>(args?: Subset<T, User$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningSchedules<T extends User$cleaningSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, User$cleaningSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends User$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, User$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly avatar: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly mfaEnabled: FieldRef<"User", 'Boolean'>
    readonly mfaSecret: FieldRef<"User", 'String'>
    readonly mfaBackupCodes: FieldRef<"User", 'Json'>
    readonly emailVerified: FieldRef<"User", 'Boolean'>
    readonly phoneVerified: FieldRef<"User", 'Boolean'>
    readonly stripeAccountId: FieldRef<"User", 'String'>
    readonly stripeAccountStatus: FieldRef<"User", 'String'>
    readonly preferredCurrency: FieldRef<"User", 'String'>
    readonly preferredLanguage: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.properties
   */
  export type User$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * User.bookings
   */
  export type User$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.messages
   */
  export type User$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.auditLogs
   */
  export type User$auditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.propertyGroups
   */
  export type User$propertyGroupsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    where?: PropertyGroupWhereInput
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    cursor?: PropertyGroupWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }

  /**
   * User.rooms
   */
  export type User$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * User.cleaningSchedules
   */
  export type User$cleaningSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    where?: CleaningScheduleWhereInput
    orderBy?: CleaningScheduleOrderByWithRelationInput | CleaningScheduleOrderByWithRelationInput[]
    cursor?: CleaningScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningScheduleScalarFieldEnum | CleaningScheduleScalarFieldEnum[]
  }

  /**
   * User.inquiries
   */
  export type User$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Property
   */

  export type AggregateProperty = {
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  export type PropertyAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    maxGuests: number | null
    bedrooms: number | null
    bathrooms: number | null
    area: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFeePercentage: number | null
    taxes: number | null
    taxRate: number | null
    minStay: number | null
    maxStay: number | null
    advanceBooking: number | null
    averageCleanlinessRating: number | null
  }

  export type PropertySumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    maxGuests: number | null
    bedrooms: number | null
    bathrooms: number | null
    area: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFeePercentage: number | null
    taxes: number | null
    taxRate: number | null
    minStay: number | null
    maxStay: number | null
    advanceBooking: number | null
    averageCleanlinessRating: number | null
  }

  export type PropertyMinAggregateOutputType = {
    id: string | null
    titleGr: string | null
    titleEn: string | null
    descriptionGr: string | null
    descriptionEn: string | null
    type: $Enums.PropertyType | null
    status: $Enums.PropertyStatus | null
    address: string | null
    city: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    postalCode: string | null
    maxGuests: number | null
    bedrooms: number | null
    bathrooms: number | null
    area: number | null
    basePrice: number | null
    currency: string | null
    cleaningFee: number | null
    serviceFeePercentage: number | null
    taxes: number | null
    taxRate: number | null
    minStay: number | null
    maxStay: number | null
    advanceBooking: number | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: $Enums.CancellationPolicy | null
    houseRules: string | null
    petFriendly: boolean | null
    smokingAllowed: boolean | null
    partyAllowed: boolean | null
    hasDynamicRooms: boolean | null
    averageCleanlinessRating: number | null
    lastCleaningDate: Date | null
    propertyGroupId: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyMaxAggregateOutputType = {
    id: string | null
    titleGr: string | null
    titleEn: string | null
    descriptionGr: string | null
    descriptionEn: string | null
    type: $Enums.PropertyType | null
    status: $Enums.PropertyStatus | null
    address: string | null
    city: string | null
    country: string | null
    latitude: number | null
    longitude: number | null
    postalCode: string | null
    maxGuests: number | null
    bedrooms: number | null
    bathrooms: number | null
    area: number | null
    basePrice: number | null
    currency: string | null
    cleaningFee: number | null
    serviceFeePercentage: number | null
    taxes: number | null
    taxRate: number | null
    minStay: number | null
    maxStay: number | null
    advanceBooking: number | null
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: $Enums.CancellationPolicy | null
    houseRules: string | null
    petFriendly: boolean | null
    smokingAllowed: boolean | null
    partyAllowed: boolean | null
    hasDynamicRooms: boolean | null
    averageCleanlinessRating: number | null
    lastCleaningDate: Date | null
    propertyGroupId: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyCountAggregateOutputType = {
    id: number
    titleGr: number
    titleEn: number
    descriptionGr: number
    descriptionEn: number
    type: number
    status: number
    address: number
    city: number
    country: number
    latitude: number
    longitude: number
    postalCode: number
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area: number
    basePrice: number
    currency: number
    cleaningFee: number
    serviceFeePercentage: number
    taxes: number
    taxRate: number
    minStay: number
    maxStay: number
    advanceBooking: number
    checkInTime: number
    checkOutTime: number
    cancellationPolicy: number
    houseRules: number
    petFriendly: number
    smokingAllowed: number
    partyAllowed: number
    hasDynamicRooms: number
    averageCleanlinessRating: number
    lastCleaningDate: number
    propertyGroupId: number
    images: number
    videos: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    maxGuests?: true
    bedrooms?: true
    bathrooms?: true
    area?: true
    basePrice?: true
    cleaningFee?: true
    serviceFeePercentage?: true
    taxes?: true
    taxRate?: true
    minStay?: true
    maxStay?: true
    advanceBooking?: true
    averageCleanlinessRating?: true
  }

  export type PropertySumAggregateInputType = {
    latitude?: true
    longitude?: true
    maxGuests?: true
    bedrooms?: true
    bathrooms?: true
    area?: true
    basePrice?: true
    cleaningFee?: true
    serviceFeePercentage?: true
    taxes?: true
    taxRate?: true
    minStay?: true
    maxStay?: true
    advanceBooking?: true
    averageCleanlinessRating?: true
  }

  export type PropertyMinAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    type?: true
    status?: true
    address?: true
    city?: true
    country?: true
    latitude?: true
    longitude?: true
    postalCode?: true
    maxGuests?: true
    bedrooms?: true
    bathrooms?: true
    area?: true
    basePrice?: true
    currency?: true
    cleaningFee?: true
    serviceFeePercentage?: true
    taxes?: true
    taxRate?: true
    minStay?: true
    maxStay?: true
    advanceBooking?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    houseRules?: true
    petFriendly?: true
    smokingAllowed?: true
    partyAllowed?: true
    hasDynamicRooms?: true
    averageCleanlinessRating?: true
    lastCleaningDate?: true
    propertyGroupId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyMaxAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    type?: true
    status?: true
    address?: true
    city?: true
    country?: true
    latitude?: true
    longitude?: true
    postalCode?: true
    maxGuests?: true
    bedrooms?: true
    bathrooms?: true
    area?: true
    basePrice?: true
    currency?: true
    cleaningFee?: true
    serviceFeePercentage?: true
    taxes?: true
    taxRate?: true
    minStay?: true
    maxStay?: true
    advanceBooking?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    houseRules?: true
    petFriendly?: true
    smokingAllowed?: true
    partyAllowed?: true
    hasDynamicRooms?: true
    averageCleanlinessRating?: true
    lastCleaningDate?: true
    propertyGroupId?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyCountAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    type?: true
    status?: true
    address?: true
    city?: true
    country?: true
    latitude?: true
    longitude?: true
    postalCode?: true
    maxGuests?: true
    bedrooms?: true
    bathrooms?: true
    area?: true
    basePrice?: true
    currency?: true
    cleaningFee?: true
    serviceFeePercentage?: true
    taxes?: true
    taxRate?: true
    minStay?: true
    maxStay?: true
    advanceBooking?: true
    checkInTime?: true
    checkOutTime?: true
    cancellationPolicy?: true
    houseRules?: true
    petFriendly?: true
    smokingAllowed?: true
    partyAllowed?: true
    hasDynamicRooms?: true
    averageCleanlinessRating?: true
    lastCleaningDate?: true
    propertyGroupId?: true
    images?: true
    videos?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Property to aggregate.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Properties
    **/
    _count?: true | PropertyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyMaxAggregateInputType
  }

  export type GetPropertyAggregateType<T extends PropertyAggregateArgs> = {
        [P in keyof T & keyof AggregateProperty]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProperty[P]>
      : GetScalarType<T[P], AggregateProperty[P]>
  }




  export type PropertyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithAggregationInput | PropertyOrderByWithAggregationInput[]
    by: PropertyScalarFieldEnum[] | PropertyScalarFieldEnum
    having?: PropertyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyCountAggregateInputType | true
    _avg?: PropertyAvgAggregateInputType
    _sum?: PropertySumAggregateInputType
    _min?: PropertyMinAggregateInputType
    _max?: PropertyMaxAggregateInputType
  }

  export type PropertyGroupByOutputType = {
    id: string
    titleGr: string
    titleEn: string
    descriptionGr: string | null
    descriptionEn: string | null
    type: $Enums.PropertyType
    status: $Enums.PropertyStatus
    address: string
    city: string
    country: string
    latitude: number | null
    longitude: number | null
    postalCode: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area: number | null
    basePrice: number
    currency: string
    cleaningFee: number | null
    serviceFeePercentage: number | null
    taxes: number | null
    taxRate: number | null
    minStay: number
    maxStay: number | null
    advanceBooking: number
    checkInTime: string | null
    checkOutTime: string | null
    cancellationPolicy: $Enums.CancellationPolicy
    houseRules: string | null
    petFriendly: boolean
    smokingAllowed: boolean
    partyAllowed: boolean
    hasDynamicRooms: boolean
    averageCleanlinessRating: number | null
    lastCleaningDate: Date | null
    propertyGroupId: string | null
    images: JsonValue | null
    videos: JsonValue | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: PropertyCountAggregateOutputType | null
    _avg: PropertyAvgAggregateOutputType | null
    _sum: PropertySumAggregateOutputType | null
    _min: PropertyMinAggregateOutputType | null
    _max: PropertyMaxAggregateOutputType | null
  }

  type GetPropertyGroupByPayload<T extends PropertyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupByOutputType[P]>
        }
      >
    >


  export type PropertySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    type?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    postalCode?: boolean
    maxGuests?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    area?: boolean
    basePrice?: boolean
    currency?: boolean
    cleaningFee?: boolean
    serviceFeePercentage?: boolean
    taxes?: boolean
    taxRate?: boolean
    minStay?: boolean
    maxStay?: boolean
    advanceBooking?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: boolean
    lastCleaningDate?: boolean
    propertyGroupId?: boolean
    images?: boolean
    videos?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Property$bookingsArgs<ExtArgs>
    reviews?: boolean | Property$reviewsArgs<ExtArgs>
    amenities?: boolean | Property$amenitiesArgs<ExtArgs>
    availability?: boolean | Property$availabilityArgs<ExtArgs>
    maintenance?: boolean | Property$maintenanceArgs<ExtArgs>
    rooms?: boolean | Property$roomsArgs<ExtArgs>
    notes?: boolean | Property$notesArgs<ExtArgs>
    analytics?: boolean | Property$analyticsArgs<ExtArgs>
    cleaningSchedules?: boolean | Property$cleaningSchedulesArgs<ExtArgs>
    propertyGroup?: boolean | Property$propertyGroupArgs<ExtArgs>
    payments?: boolean | Property$paymentsArgs<ExtArgs>
    inquiries?: boolean | Property$inquiriesArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    type?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    postalCode?: boolean
    maxGuests?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    area?: boolean
    basePrice?: boolean
    currency?: boolean
    cleaningFee?: boolean
    serviceFeePercentage?: boolean
    taxes?: boolean
    taxRate?: boolean
    minStay?: boolean
    maxStay?: boolean
    advanceBooking?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: boolean
    lastCleaningDate?: boolean
    propertyGroupId?: boolean
    images?: boolean
    videos?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    propertyGroup?: boolean | Property$propertyGroupArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    type?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    postalCode?: boolean
    maxGuests?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    area?: boolean
    basePrice?: boolean
    currency?: boolean
    cleaningFee?: boolean
    serviceFeePercentage?: boolean
    taxes?: boolean
    taxRate?: boolean
    minStay?: boolean
    maxStay?: boolean
    advanceBooking?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: boolean
    lastCleaningDate?: boolean
    propertyGroupId?: boolean
    images?: boolean
    videos?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    propertyGroup?: boolean | Property$propertyGroupArgs<ExtArgs>
  }, ExtArgs["result"]["property"]>

  export type PropertySelectScalar = {
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    type?: boolean
    status?: boolean
    address?: boolean
    city?: boolean
    country?: boolean
    latitude?: boolean
    longitude?: boolean
    postalCode?: boolean
    maxGuests?: boolean
    bedrooms?: boolean
    bathrooms?: boolean
    area?: boolean
    basePrice?: boolean
    currency?: boolean
    cleaningFee?: boolean
    serviceFeePercentage?: boolean
    taxes?: boolean
    taxRate?: boolean
    minStay?: boolean
    maxStay?: boolean
    advanceBooking?: boolean
    checkInTime?: boolean
    checkOutTime?: boolean
    cancellationPolicy?: boolean
    houseRules?: boolean
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: boolean
    lastCleaningDate?: boolean
    propertyGroupId?: boolean
    images?: boolean
    videos?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titleGr" | "titleEn" | "descriptionGr" | "descriptionEn" | "type" | "status" | "address" | "city" | "country" | "latitude" | "longitude" | "postalCode" | "maxGuests" | "bedrooms" | "bathrooms" | "area" | "basePrice" | "currency" | "cleaningFee" | "serviceFeePercentage" | "taxes" | "taxRate" | "minStay" | "maxStay" | "advanceBooking" | "checkInTime" | "checkOutTime" | "cancellationPolicy" | "houseRules" | "petFriendly" | "smokingAllowed" | "partyAllowed" | "hasDynamicRooms" | "averageCleanlinessRating" | "lastCleaningDate" | "propertyGroupId" | "images" | "videos" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["property"]>
  export type PropertyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    bookings?: boolean | Property$bookingsArgs<ExtArgs>
    reviews?: boolean | Property$reviewsArgs<ExtArgs>
    amenities?: boolean | Property$amenitiesArgs<ExtArgs>
    availability?: boolean | Property$availabilityArgs<ExtArgs>
    maintenance?: boolean | Property$maintenanceArgs<ExtArgs>
    rooms?: boolean | Property$roomsArgs<ExtArgs>
    notes?: boolean | Property$notesArgs<ExtArgs>
    analytics?: boolean | Property$analyticsArgs<ExtArgs>
    cleaningSchedules?: boolean | Property$cleaningSchedulesArgs<ExtArgs>
    propertyGroup?: boolean | Property$propertyGroupArgs<ExtArgs>
    payments?: boolean | Property$paymentsArgs<ExtArgs>
    inquiries?: boolean | Property$inquiriesArgs<ExtArgs>
    _count?: boolean | PropertyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    propertyGroup?: boolean | Property$propertyGroupArgs<ExtArgs>
  }
  export type PropertyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    propertyGroup?: boolean | Property$propertyGroupArgs<ExtArgs>
  }

  export type $PropertyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Property"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      amenities: Prisma.$PropertyAmenityPayload<ExtArgs>[]
      availability: Prisma.$PropertyAvailabilityPayload<ExtArgs>[]
      maintenance: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      notes: Prisma.$PropertyNotePayload<ExtArgs>[]
      analytics: Prisma.$PropertyAnalyticsPayload<ExtArgs>[]
      cleaningSchedules: Prisma.$CleaningSchedulePayload<ExtArgs>[]
      propertyGroup: Prisma.$PropertyGroupPayload<ExtArgs> | null
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      inquiries: Prisma.$InquiryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titleGr: string
      titleEn: string
      descriptionGr: string | null
      descriptionEn: string | null
      type: $Enums.PropertyType
      status: $Enums.PropertyStatus
      address: string
      city: string
      country: string
      latitude: number | null
      longitude: number | null
      postalCode: string | null
      maxGuests: number
      bedrooms: number
      bathrooms: number
      area: number | null
      basePrice: number
      currency: string
      cleaningFee: number | null
      serviceFeePercentage: number | null
      taxes: number | null
      taxRate: number | null
      minStay: number
      maxStay: number | null
      advanceBooking: number
      checkInTime: string | null
      checkOutTime: string | null
      cancellationPolicy: $Enums.CancellationPolicy
      houseRules: string | null
      petFriendly: boolean
      smokingAllowed: boolean
      partyAllowed: boolean
      hasDynamicRooms: boolean
      averageCleanlinessRating: number | null
      lastCleaningDate: Date | null
      propertyGroupId: string | null
      images: Prisma.JsonValue | null
      videos: Prisma.JsonValue | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["property"]>
    composites: {}
  }

  type PropertyGetPayload<S extends boolean | null | undefined | PropertyDefaultArgs> = $Result.GetResult<Prisma.$PropertyPayload, S>

  type PropertyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyCountAggregateInputType | true
    }

  export interface PropertyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Property'], meta: { name: 'Property' } }
    /**
     * Find zero or one Property that matches the filter.
     * @param {PropertyFindUniqueArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyFindUniqueArgs>(args: SelectSubset<T, PropertyFindUniqueArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Property that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyFindUniqueOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyFindFirstArgs>(args?: SelectSubset<T, PropertyFindFirstArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Property that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindFirstOrThrowArgs} args - Arguments to find a Property
     * @example
     * // Get one Property
     * const property = await prisma.property.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Properties that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Properties
     * const properties = await prisma.property.findMany()
     * 
     * // Get first 10 Properties
     * const properties = await prisma.property.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyWithIdOnly = await prisma.property.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyFindManyArgs>(args?: SelectSubset<T, PropertyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Property.
     * @param {PropertyCreateArgs} args - Arguments to create a Property.
     * @example
     * // Create one Property
     * const Property = await prisma.property.create({
     *   data: {
     *     // ... data to create a Property
     *   }
     * })
     * 
     */
    create<T extends PropertyCreateArgs>(args: SelectSubset<T, PropertyCreateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Properties.
     * @param {PropertyCreateManyArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyCreateManyArgs>(args?: SelectSubset<T, PropertyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Properties and returns the data saved in the database.
     * @param {PropertyCreateManyAndReturnArgs} args - Arguments to create many Properties.
     * @example
     * // Create many Properties
     * const property = await prisma.property.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Property.
     * @param {PropertyDeleteArgs} args - Arguments to delete one Property.
     * @example
     * // Delete one Property
     * const Property = await prisma.property.delete({
     *   where: {
     *     // ... filter to delete one Property
     *   }
     * })
     * 
     */
    delete<T extends PropertyDeleteArgs>(args: SelectSubset<T, PropertyDeleteArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Property.
     * @param {PropertyUpdateArgs} args - Arguments to update one Property.
     * @example
     * // Update one Property
     * const property = await prisma.property.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyUpdateArgs>(args: SelectSubset<T, PropertyUpdateArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Properties.
     * @param {PropertyDeleteManyArgs} args - Arguments to filter Properties to delete.
     * @example
     * // Delete a few Properties
     * const { count } = await prisma.property.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyDeleteManyArgs>(args?: SelectSubset<T, PropertyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyUpdateManyArgs>(args: SelectSubset<T, PropertyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Properties and returns the data updated in the database.
     * @param {PropertyUpdateManyAndReturnArgs} args - Arguments to update many Properties.
     * @example
     * // Update many Properties
     * const property = await prisma.property.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Properties and only return the `id`
     * const propertyWithIdOnly = await prisma.property.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Property.
     * @param {PropertyUpsertArgs} args - Arguments to update or create a Property.
     * @example
     * // Update or create a Property
     * const property = await prisma.property.upsert({
     *   create: {
     *     // ... data to create a Property
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Property we want to update
     *   }
     * })
     */
    upsert<T extends PropertyUpsertArgs>(args: SelectSubset<T, PropertyUpsertArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Properties.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyCountArgs} args - Arguments to filter Properties to count.
     * @example
     * // Count the number of Properties
     * const count = await prisma.property.count({
     *   where: {
     *     // ... the filter for the Properties we want to count
     *   }
     * })
    **/
    count<T extends PropertyCountArgs>(
      args?: Subset<T, PropertyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAggregateArgs>(args: Subset<T, PropertyAggregateArgs>): Prisma.PrismaPromise<GetPropertyAggregateType<T>>

    /**
     * Group by Property.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Property model
   */
  readonly fields: PropertyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Property.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Property$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Property$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Property$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Property$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    amenities<T extends Property$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Property$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability<T extends Property$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, Property$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenance<T extends Property$maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, Property$maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rooms<T extends Property$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Property$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notes<T extends Property$notesArgs<ExtArgs> = {}>(args?: Subset<T, Property$notesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    analytics<T extends Property$analyticsArgs<ExtArgs> = {}>(args?: Subset<T, Property$analyticsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    cleaningSchedules<T extends Property$cleaningSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Property$cleaningSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    propertyGroup<T extends Property$propertyGroupArgs<ExtArgs> = {}>(args?: Subset<T, Property$propertyGroupArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payments<T extends Property$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Property$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inquiries<T extends Property$inquiriesArgs<ExtArgs> = {}>(args?: Subset<T, Property$inquiriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Property model
   */
  interface PropertyFieldRefs {
    readonly id: FieldRef<"Property", 'String'>
    readonly titleGr: FieldRef<"Property", 'String'>
    readonly titleEn: FieldRef<"Property", 'String'>
    readonly descriptionGr: FieldRef<"Property", 'String'>
    readonly descriptionEn: FieldRef<"Property", 'String'>
    readonly type: FieldRef<"Property", 'PropertyType'>
    readonly status: FieldRef<"Property", 'PropertyStatus'>
    readonly address: FieldRef<"Property", 'String'>
    readonly city: FieldRef<"Property", 'String'>
    readonly country: FieldRef<"Property", 'String'>
    readonly latitude: FieldRef<"Property", 'Float'>
    readonly longitude: FieldRef<"Property", 'Float'>
    readonly postalCode: FieldRef<"Property", 'String'>
    readonly maxGuests: FieldRef<"Property", 'Int'>
    readonly bedrooms: FieldRef<"Property", 'Int'>
    readonly bathrooms: FieldRef<"Property", 'Int'>
    readonly area: FieldRef<"Property", 'Float'>
    readonly basePrice: FieldRef<"Property", 'Float'>
    readonly currency: FieldRef<"Property", 'String'>
    readonly cleaningFee: FieldRef<"Property", 'Float'>
    readonly serviceFeePercentage: FieldRef<"Property", 'Float'>
    readonly taxes: FieldRef<"Property", 'Float'>
    readonly taxRate: FieldRef<"Property", 'Float'>
    readonly minStay: FieldRef<"Property", 'Int'>
    readonly maxStay: FieldRef<"Property", 'Int'>
    readonly advanceBooking: FieldRef<"Property", 'Int'>
    readonly checkInTime: FieldRef<"Property", 'String'>
    readonly checkOutTime: FieldRef<"Property", 'String'>
    readonly cancellationPolicy: FieldRef<"Property", 'CancellationPolicy'>
    readonly houseRules: FieldRef<"Property", 'String'>
    readonly petFriendly: FieldRef<"Property", 'Boolean'>
    readonly smokingAllowed: FieldRef<"Property", 'Boolean'>
    readonly partyAllowed: FieldRef<"Property", 'Boolean'>
    readonly hasDynamicRooms: FieldRef<"Property", 'Boolean'>
    readonly averageCleanlinessRating: FieldRef<"Property", 'Float'>
    readonly lastCleaningDate: FieldRef<"Property", 'DateTime'>
    readonly propertyGroupId: FieldRef<"Property", 'String'>
    readonly images: FieldRef<"Property", 'Json'>
    readonly videos: FieldRef<"Property", 'Json'>
    readonly ownerId: FieldRef<"Property", 'String'>
    readonly createdAt: FieldRef<"Property", 'DateTime'>
    readonly updatedAt: FieldRef<"Property", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Property findUnique
   */
  export type PropertyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findUniqueOrThrow
   */
  export type PropertyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property findFirst
   */
  export type PropertyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findFirstOrThrow
   */
  export type PropertyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Property to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Properties.
     */
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property findMany
   */
  export type PropertyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter, which Properties to fetch.
     */
    where?: PropertyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Properties to fetch.
     */
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Properties.
     */
    cursor?: PropertyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Properties from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Properties.
     */
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * Property create
   */
  export type PropertyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to create a Property.
     */
    data: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
  }

  /**
   * Property createMany
   */
  export type PropertyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
  }

  /**
   * Property createManyAndReturn
   */
  export type PropertyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to create many Properties.
     */
    data: PropertyCreateManyInput | PropertyCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property update
   */
  export type PropertyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The data needed to update a Property.
     */
    data: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
    /**
     * Choose, which Property to update.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property updateMany
   */
  export type PropertyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
  }

  /**
   * Property updateManyAndReturn
   */
  export type PropertyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * The data used to update Properties.
     */
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyInput>
    /**
     * Filter which Properties to update
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Property upsert
   */
  export type PropertyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * The filter to search for the Property to update in case it exists.
     */
    where: PropertyWhereUniqueInput
    /**
     * In case the Property found by the `where` argument doesn't exist, create a new Property with this data.
     */
    create: XOR<PropertyCreateInput, PropertyUncheckedCreateInput>
    /**
     * In case the Property was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyUpdateInput, PropertyUncheckedUpdateInput>
  }

  /**
   * Property delete
   */
  export type PropertyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    /**
     * Filter which Property to delete.
     */
    where: PropertyWhereUniqueInput
  }

  /**
   * Property deleteMany
   */
  export type PropertyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Properties to delete
     */
    where?: PropertyWhereInput
    /**
     * Limit how many Properties to delete.
     */
    limit?: number
  }

  /**
   * Property.bookings
   */
  export type Property$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Property.reviews
   */
  export type Property$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Property.amenities
   */
  export type Property$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    where?: PropertyAmenityWhereInput
    orderBy?: PropertyAmenityOrderByWithRelationInput | PropertyAmenityOrderByWithRelationInput[]
    cursor?: PropertyAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAmenityScalarFieldEnum | PropertyAmenityScalarFieldEnum[]
  }

  /**
   * Property.availability
   */
  export type Property$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    where?: PropertyAvailabilityWhereInput
    orderBy?: PropertyAvailabilityOrderByWithRelationInput | PropertyAvailabilityOrderByWithRelationInput[]
    cursor?: PropertyAvailabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAvailabilityScalarFieldEnum | PropertyAvailabilityScalarFieldEnum[]
  }

  /**
   * Property.maintenance
   */
  export type Property$maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Property.rooms
   */
  export type Property$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Property.notes
   */
  export type Property$notesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    where?: PropertyNoteWhereInput
    orderBy?: PropertyNoteOrderByWithRelationInput | PropertyNoteOrderByWithRelationInput[]
    cursor?: PropertyNoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyNoteScalarFieldEnum | PropertyNoteScalarFieldEnum[]
  }

  /**
   * Property.analytics
   */
  export type Property$analyticsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    where?: PropertyAnalyticsWhereInput
    orderBy?: PropertyAnalyticsOrderByWithRelationInput | PropertyAnalyticsOrderByWithRelationInput[]
    cursor?: PropertyAnalyticsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAnalyticsScalarFieldEnum | PropertyAnalyticsScalarFieldEnum[]
  }

  /**
   * Property.cleaningSchedules
   */
  export type Property$cleaningSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    where?: CleaningScheduleWhereInput
    orderBy?: CleaningScheduleOrderByWithRelationInput | CleaningScheduleOrderByWithRelationInput[]
    cursor?: CleaningScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CleaningScheduleScalarFieldEnum | CleaningScheduleScalarFieldEnum[]
  }

  /**
   * Property.propertyGroup
   */
  export type Property$propertyGroupArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    where?: PropertyGroupWhereInput
  }

  /**
   * Property.payments
   */
  export type Property$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Property.inquiries
   */
  export type Property$inquiriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    cursor?: InquiryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Property without action
   */
  export type PropertyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
  }


  /**
   * Model Amenity
   */

  export type AggregateAmenity = {
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  export type AmenityMinAggregateOutputType = {
    id: string | null
    nameGr: string | null
    nameEn: string | null
    icon: string | null
    category: string | null
    createdAt: Date | null
  }

  export type AmenityMaxAggregateOutputType = {
    id: string | null
    nameGr: string | null
    nameEn: string | null
    icon: string | null
    category: string | null
    createdAt: Date | null
  }

  export type AmenityCountAggregateOutputType = {
    id: number
    nameGr: number
    nameEn: number
    icon: number
    category: number
    createdAt: number
    _all: number
  }


  export type AmenityMinAggregateInputType = {
    id?: true
    nameGr?: true
    nameEn?: true
    icon?: true
    category?: true
    createdAt?: true
  }

  export type AmenityMaxAggregateInputType = {
    id?: true
    nameGr?: true
    nameEn?: true
    icon?: true
    category?: true
    createdAt?: true
  }

  export type AmenityCountAggregateInputType = {
    id?: true
    nameGr?: true
    nameEn?: true
    icon?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type AmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenity to aggregate.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenityMaxAggregateInputType
  }

  export type GetAmenityAggregateType<T extends AmenityAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenity[P]>
      : GetScalarType<T[P], AggregateAmenity[P]>
  }




  export type AmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenityWhereInput
    orderBy?: AmenityOrderByWithAggregationInput | AmenityOrderByWithAggregationInput[]
    by: AmenityScalarFieldEnum[] | AmenityScalarFieldEnum
    having?: AmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenityCountAggregateInputType | true
    _min?: AmenityMinAggregateInputType
    _max?: AmenityMaxAggregateInputType
  }

  export type AmenityGroupByOutputType = {
    id: string
    nameGr: string
    nameEn: string
    icon: string | null
    category: string
    createdAt: Date
    _count: AmenityCountAggregateOutputType | null
    _min: AmenityMinAggregateOutputType | null
    _max: AmenityMaxAggregateOutputType | null
  }

  type GetAmenityGroupByPayload<T extends AmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenityGroupByOutputType[P]>
            : GetScalarType<T[P], AmenityGroupByOutputType[P]>
        }
      >
    >


  export type AmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameGr?: boolean
    nameEn?: boolean
    icon?: boolean
    category?: boolean
    createdAt?: boolean
    properties?: boolean | Amenity$propertiesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameGr?: boolean
    nameEn?: boolean
    icon?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nameGr?: boolean
    nameEn?: boolean
    icon?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["amenity"]>

  export type AmenitySelectScalar = {
    id?: boolean
    nameGr?: boolean
    nameEn?: boolean
    icon?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type AmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nameGr" | "nameEn" | "icon" | "category" | "createdAt", ExtArgs["result"]["amenity"]>
  export type AmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    properties?: boolean | Amenity$propertiesArgs<ExtArgs>
    _count?: boolean | AmenityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenity"
    objects: {
      properties: Prisma.$PropertyAmenityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nameGr: string
      nameEn: string
      icon: string | null
      category: string
      createdAt: Date
    }, ExtArgs["result"]["amenity"]>
    composites: {}
  }

  type AmenityGetPayload<S extends boolean | null | undefined | AmenityDefaultArgs> = $Result.GetResult<Prisma.$AmenityPayload, S>

  type AmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenityCountAggregateInputType | true
    }

  export interface AmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenity'], meta: { name: 'Amenity' } }
    /**
     * Find zero or one Amenity that matches the filter.
     * @param {AmenityFindUniqueArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenityFindUniqueArgs>(args: SelectSubset<T, AmenityFindUniqueArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenityFindUniqueOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenityFindFirstArgs>(args?: SelectSubset<T, AmenityFindFirstArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindFirstOrThrowArgs} args - Arguments to find a Amenity
     * @example
     * // Get one Amenity
     * const amenity = await prisma.amenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenity.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenityWithIdOnly = await prisma.amenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenityFindManyArgs>(args?: SelectSubset<T, AmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenity.
     * @param {AmenityCreateArgs} args - Arguments to create a Amenity.
     * @example
     * // Create one Amenity
     * const Amenity = await prisma.amenity.create({
     *   data: {
     *     // ... data to create a Amenity
     *   }
     * })
     * 
     */
    create<T extends AmenityCreateArgs>(args: SelectSubset<T, AmenityCreateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenityCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenityCreateManyArgs>(args?: SelectSubset<T, AmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenityCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenity = await prisma.amenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenity.
     * @param {AmenityDeleteArgs} args - Arguments to delete one Amenity.
     * @example
     * // Delete one Amenity
     * const Amenity = await prisma.amenity.delete({
     *   where: {
     *     // ... filter to delete one Amenity
     *   }
     * })
     * 
     */
    delete<T extends AmenityDeleteArgs>(args: SelectSubset<T, AmenityDeleteArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenity.
     * @param {AmenityUpdateArgs} args - Arguments to update one Amenity.
     * @example
     * // Update one Amenity
     * const amenity = await prisma.amenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenityUpdateArgs>(args: SelectSubset<T, AmenityUpdateArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenityDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenityDeleteManyArgs>(args?: SelectSubset<T, AmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenityUpdateManyArgs>(args: SelectSubset<T, AmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenityUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenity = await prisma.amenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenityWithIdOnly = await prisma.amenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenity.
     * @param {AmenityUpsertArgs} args - Arguments to update or create a Amenity.
     * @example
     * // Update or create a Amenity
     * const amenity = await prisma.amenity.upsert({
     *   create: {
     *     // ... data to create a Amenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenity we want to update
     *   }
     * })
     */
    upsert<T extends AmenityUpsertArgs>(args: SelectSubset<T, AmenityUpsertArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenity.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenityCountArgs>(
      args?: Subset<T, AmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenityAggregateArgs>(args: Subset<T, AmenityAggregateArgs>): Prisma.PrismaPromise<GetAmenityAggregateType<T>>

    /**
     * Group by Amenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenityGroupByArgs['orderBy'] }
        : { orderBy?: AmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenity model
   */
  readonly fields: AmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    properties<T extends Amenity$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, Amenity$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenity model
   */
  interface AmenityFieldRefs {
    readonly id: FieldRef<"Amenity", 'String'>
    readonly nameGr: FieldRef<"Amenity", 'String'>
    readonly nameEn: FieldRef<"Amenity", 'String'>
    readonly icon: FieldRef<"Amenity", 'String'>
    readonly category: FieldRef<"Amenity", 'String'>
    readonly createdAt: FieldRef<"Amenity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Amenity findUnique
   */
  export type AmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findUniqueOrThrow
   */
  export type AmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity findFirst
   */
  export type AmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findFirstOrThrow
   */
  export type AmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenity to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity findMany
   */
  export type AmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenityOrderByWithRelationInput | AmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenityScalarFieldEnum | AmenityScalarFieldEnum[]
  }

  /**
   * Amenity create
   */
  export type AmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenity.
     */
    data: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
  }

  /**
   * Amenity createMany
   */
  export type AmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
  }

  /**
   * Amenity createManyAndReturn
   */
  export type AmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenityCreateManyInput | AmenityCreateManyInput[]
  }

  /**
   * Amenity update
   */
  export type AmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenity.
     */
    data: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
    /**
     * Choose, which Amenity to update.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity updateMany
   */
  export type AmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity updateManyAndReturn
   */
  export type AmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenityUpdateManyMutationInput, AmenityUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenity upsert
   */
  export type AmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenity to update in case it exists.
     */
    where: AmenityWhereUniqueInput
    /**
     * In case the Amenity found by the `where` argument doesn't exist, create a new Amenity with this data.
     */
    create: XOR<AmenityCreateInput, AmenityUncheckedCreateInput>
    /**
     * In case the Amenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenityUpdateInput, AmenityUncheckedUpdateInput>
  }

  /**
   * Amenity delete
   */
  export type AmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
    /**
     * Filter which Amenity to delete.
     */
    where: AmenityWhereUniqueInput
  }

  /**
   * Amenity deleteMany
   */
  export type AmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenityWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenity.properties
   */
  export type Amenity$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    where?: PropertyAmenityWhereInput
    orderBy?: PropertyAmenityOrderByWithRelationInput | PropertyAmenityOrderByWithRelationInput[]
    cursor?: PropertyAmenityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyAmenityScalarFieldEnum | PropertyAmenityScalarFieldEnum[]
  }

  /**
   * Amenity without action
   */
  export type AmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenity
     */
    select?: AmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenity
     */
    omit?: AmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenityInclude<ExtArgs> | null
  }


  /**
   * Model PropertyAmenity
   */

  export type AggregatePropertyAmenity = {
    _count: PropertyAmenityCountAggregateOutputType | null
    _min: PropertyAmenityMinAggregateOutputType | null
    _max: PropertyAmenityMaxAggregateOutputType | null
  }

  export type PropertyAmenityMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    amenityId: string | null
  }

  export type PropertyAmenityMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    amenityId: string | null
  }

  export type PropertyAmenityCountAggregateOutputType = {
    id: number
    propertyId: number
    amenityId: number
    _all: number
  }


  export type PropertyAmenityMinAggregateInputType = {
    id?: true
    propertyId?: true
    amenityId?: true
  }

  export type PropertyAmenityMaxAggregateInputType = {
    id?: true
    propertyId?: true
    amenityId?: true
  }

  export type PropertyAmenityCountAggregateInputType = {
    id?: true
    propertyId?: true
    amenityId?: true
    _all?: true
  }

  export type PropertyAmenityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAmenity to aggregate.
     */
    where?: PropertyAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAmenities to fetch.
     */
    orderBy?: PropertyAmenityOrderByWithRelationInput | PropertyAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAmenities
    **/
    _count?: true | PropertyAmenityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAmenityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAmenityMaxAggregateInputType
  }

  export type GetPropertyAmenityAggregateType<T extends PropertyAmenityAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAmenity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAmenity[P]>
      : GetScalarType<T[P], AggregatePropertyAmenity[P]>
  }




  export type PropertyAmenityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAmenityWhereInput
    orderBy?: PropertyAmenityOrderByWithAggregationInput | PropertyAmenityOrderByWithAggregationInput[]
    by: PropertyAmenityScalarFieldEnum[] | PropertyAmenityScalarFieldEnum
    having?: PropertyAmenityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAmenityCountAggregateInputType | true
    _min?: PropertyAmenityMinAggregateInputType
    _max?: PropertyAmenityMaxAggregateInputType
  }

  export type PropertyAmenityGroupByOutputType = {
    id: string
    propertyId: string
    amenityId: string
    _count: PropertyAmenityCountAggregateOutputType | null
    _min: PropertyAmenityMinAggregateOutputType | null
    _max: PropertyAmenityMaxAggregateOutputType | null
  }

  type GetPropertyAmenityGroupByPayload<T extends PropertyAmenityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAmenityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAmenityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAmenityGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAmenityGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAmenitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    amenityId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAmenity"]>

  export type PropertyAmenitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    amenityId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAmenity"]>

  export type PropertyAmenitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    amenityId?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAmenity"]>

  export type PropertyAmenitySelectScalar = {
    id?: boolean
    propertyId?: boolean
    amenityId?: boolean
  }

  export type PropertyAmenityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "amenityId", ExtArgs["result"]["propertyAmenity"]>
  export type PropertyAmenityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type PropertyAmenityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }
  export type PropertyAmenityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    amenity?: boolean | AmenityDefaultArgs<ExtArgs>
  }

  export type $PropertyAmenityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAmenity"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      amenity: Prisma.$AmenityPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      amenityId: string
    }, ExtArgs["result"]["propertyAmenity"]>
    composites: {}
  }

  type PropertyAmenityGetPayload<S extends boolean | null | undefined | PropertyAmenityDefaultArgs> = $Result.GetResult<Prisma.$PropertyAmenityPayload, S>

  type PropertyAmenityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyAmenityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyAmenityCountAggregateInputType | true
    }

  export interface PropertyAmenityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAmenity'], meta: { name: 'PropertyAmenity' } }
    /**
     * Find zero or one PropertyAmenity that matches the filter.
     * @param {PropertyAmenityFindUniqueArgs} args - Arguments to find a PropertyAmenity
     * @example
     * // Get one PropertyAmenity
     * const propertyAmenity = await prisma.propertyAmenity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAmenityFindUniqueArgs>(args: SelectSubset<T, PropertyAmenityFindUniqueArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyAmenity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyAmenityFindUniqueOrThrowArgs} args - Arguments to find a PropertyAmenity
     * @example
     * // Get one PropertyAmenity
     * const propertyAmenity = await prisma.propertyAmenity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAmenityFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAmenityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAmenity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityFindFirstArgs} args - Arguments to find a PropertyAmenity
     * @example
     * // Get one PropertyAmenity
     * const propertyAmenity = await prisma.propertyAmenity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAmenityFindFirstArgs>(args?: SelectSubset<T, PropertyAmenityFindFirstArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAmenity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityFindFirstOrThrowArgs} args - Arguments to find a PropertyAmenity
     * @example
     * // Get one PropertyAmenity
     * const propertyAmenity = await prisma.propertyAmenity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAmenityFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAmenityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyAmenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAmenities
     * const propertyAmenities = await prisma.propertyAmenity.findMany()
     * 
     * // Get first 10 PropertyAmenities
     * const propertyAmenities = await prisma.propertyAmenity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAmenityWithIdOnly = await prisma.propertyAmenity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAmenityFindManyArgs>(args?: SelectSubset<T, PropertyAmenityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyAmenity.
     * @param {PropertyAmenityCreateArgs} args - Arguments to create a PropertyAmenity.
     * @example
     * // Create one PropertyAmenity
     * const PropertyAmenity = await prisma.propertyAmenity.create({
     *   data: {
     *     // ... data to create a PropertyAmenity
     *   }
     * })
     * 
     */
    create<T extends PropertyAmenityCreateArgs>(args: SelectSubset<T, PropertyAmenityCreateArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyAmenities.
     * @param {PropertyAmenityCreateManyArgs} args - Arguments to create many PropertyAmenities.
     * @example
     * // Create many PropertyAmenities
     * const propertyAmenity = await prisma.propertyAmenity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAmenityCreateManyArgs>(args?: SelectSubset<T, PropertyAmenityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAmenities and returns the data saved in the database.
     * @param {PropertyAmenityCreateManyAndReturnArgs} args - Arguments to create many PropertyAmenities.
     * @example
     * // Create many PropertyAmenities
     * const propertyAmenity = await prisma.propertyAmenity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAmenities and only return the `id`
     * const propertyAmenityWithIdOnly = await prisma.propertyAmenity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAmenityCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAmenityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyAmenity.
     * @param {PropertyAmenityDeleteArgs} args - Arguments to delete one PropertyAmenity.
     * @example
     * // Delete one PropertyAmenity
     * const PropertyAmenity = await prisma.propertyAmenity.delete({
     *   where: {
     *     // ... filter to delete one PropertyAmenity
     *   }
     * })
     * 
     */
    delete<T extends PropertyAmenityDeleteArgs>(args: SelectSubset<T, PropertyAmenityDeleteArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyAmenity.
     * @param {PropertyAmenityUpdateArgs} args - Arguments to update one PropertyAmenity.
     * @example
     * // Update one PropertyAmenity
     * const propertyAmenity = await prisma.propertyAmenity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAmenityUpdateArgs>(args: SelectSubset<T, PropertyAmenityUpdateArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyAmenities.
     * @param {PropertyAmenityDeleteManyArgs} args - Arguments to filter PropertyAmenities to delete.
     * @example
     * // Delete a few PropertyAmenities
     * const { count } = await prisma.propertyAmenity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAmenityDeleteManyArgs>(args?: SelectSubset<T, PropertyAmenityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAmenities
     * const propertyAmenity = await prisma.propertyAmenity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAmenityUpdateManyArgs>(args: SelectSubset<T, PropertyAmenityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAmenities and returns the data updated in the database.
     * @param {PropertyAmenityUpdateManyAndReturnArgs} args - Arguments to update many PropertyAmenities.
     * @example
     * // Update many PropertyAmenities
     * const propertyAmenity = await prisma.propertyAmenity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyAmenities and only return the `id`
     * const propertyAmenityWithIdOnly = await prisma.propertyAmenity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyAmenityUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyAmenityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyAmenity.
     * @param {PropertyAmenityUpsertArgs} args - Arguments to update or create a PropertyAmenity.
     * @example
     * // Update or create a PropertyAmenity
     * const propertyAmenity = await prisma.propertyAmenity.upsert({
     *   create: {
     *     // ... data to create a PropertyAmenity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAmenity we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAmenityUpsertArgs>(args: SelectSubset<T, PropertyAmenityUpsertArgs<ExtArgs>>): Prisma__PropertyAmenityClient<$Result.GetResult<Prisma.$PropertyAmenityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyAmenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityCountArgs} args - Arguments to filter PropertyAmenities to count.
     * @example
     * // Count the number of PropertyAmenities
     * const count = await prisma.propertyAmenity.count({
     *   where: {
     *     // ... the filter for the PropertyAmenities we want to count
     *   }
     * })
    **/
    count<T extends PropertyAmenityCountArgs>(
      args?: Subset<T, PropertyAmenityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAmenityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAmenityAggregateArgs>(args: Subset<T, PropertyAmenityAggregateArgs>): Prisma.PrismaPromise<GetPropertyAmenityAggregateType<T>>

    /**
     * Group by PropertyAmenity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAmenityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAmenityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAmenityGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAmenityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAmenityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAmenityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAmenity model
   */
  readonly fields: PropertyAmenityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAmenity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAmenityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    amenity<T extends AmenityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AmenityDefaultArgs<ExtArgs>>): Prisma__AmenityClient<$Result.GetResult<Prisma.$AmenityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAmenity model
   */
  interface PropertyAmenityFieldRefs {
    readonly id: FieldRef<"PropertyAmenity", 'String'>
    readonly propertyId: FieldRef<"PropertyAmenity", 'String'>
    readonly amenityId: FieldRef<"PropertyAmenity", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAmenity findUnique
   */
  export type PropertyAmenityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAmenity to fetch.
     */
    where: PropertyAmenityWhereUniqueInput
  }

  /**
   * PropertyAmenity findUniqueOrThrow
   */
  export type PropertyAmenityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAmenity to fetch.
     */
    where: PropertyAmenityWhereUniqueInput
  }

  /**
   * PropertyAmenity findFirst
   */
  export type PropertyAmenityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAmenity to fetch.
     */
    where?: PropertyAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAmenities to fetch.
     */
    orderBy?: PropertyAmenityOrderByWithRelationInput | PropertyAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAmenities.
     */
    cursor?: PropertyAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAmenities.
     */
    distinct?: PropertyAmenityScalarFieldEnum | PropertyAmenityScalarFieldEnum[]
  }

  /**
   * PropertyAmenity findFirstOrThrow
   */
  export type PropertyAmenityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAmenity to fetch.
     */
    where?: PropertyAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAmenities to fetch.
     */
    orderBy?: PropertyAmenityOrderByWithRelationInput | PropertyAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAmenities.
     */
    cursor?: PropertyAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAmenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAmenities.
     */
    distinct?: PropertyAmenityScalarFieldEnum | PropertyAmenityScalarFieldEnum[]
  }

  /**
   * PropertyAmenity findMany
   */
  export type PropertyAmenityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAmenities to fetch.
     */
    where?: PropertyAmenityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAmenities to fetch.
     */
    orderBy?: PropertyAmenityOrderByWithRelationInput | PropertyAmenityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAmenities.
     */
    cursor?: PropertyAmenityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAmenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAmenities.
     */
    skip?: number
    distinct?: PropertyAmenityScalarFieldEnum | PropertyAmenityScalarFieldEnum[]
  }

  /**
   * PropertyAmenity create
   */
  export type PropertyAmenityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyAmenity.
     */
    data: XOR<PropertyAmenityCreateInput, PropertyAmenityUncheckedCreateInput>
  }

  /**
   * PropertyAmenity createMany
   */
  export type PropertyAmenityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAmenities.
     */
    data: PropertyAmenityCreateManyInput | PropertyAmenityCreateManyInput[]
  }

  /**
   * PropertyAmenity createManyAndReturn
   */
  export type PropertyAmenityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyAmenities.
     */
    data: PropertyAmenityCreateManyInput | PropertyAmenityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAmenity update
   */
  export type PropertyAmenityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyAmenity.
     */
    data: XOR<PropertyAmenityUpdateInput, PropertyAmenityUncheckedUpdateInput>
    /**
     * Choose, which PropertyAmenity to update.
     */
    where: PropertyAmenityWhereUniqueInput
  }

  /**
   * PropertyAmenity updateMany
   */
  export type PropertyAmenityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAmenities.
     */
    data: XOR<PropertyAmenityUpdateManyMutationInput, PropertyAmenityUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAmenities to update
     */
    where?: PropertyAmenityWhereInput
    /**
     * Limit how many PropertyAmenities to update.
     */
    limit?: number
  }

  /**
   * PropertyAmenity updateManyAndReturn
   */
  export type PropertyAmenityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * The data used to update PropertyAmenities.
     */
    data: XOR<PropertyAmenityUpdateManyMutationInput, PropertyAmenityUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAmenities to update
     */
    where?: PropertyAmenityWhereInput
    /**
     * Limit how many PropertyAmenities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAmenity upsert
   */
  export type PropertyAmenityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyAmenity to update in case it exists.
     */
    where: PropertyAmenityWhereUniqueInput
    /**
     * In case the PropertyAmenity found by the `where` argument doesn't exist, create a new PropertyAmenity with this data.
     */
    create: XOR<PropertyAmenityCreateInput, PropertyAmenityUncheckedCreateInput>
    /**
     * In case the PropertyAmenity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAmenityUpdateInput, PropertyAmenityUncheckedUpdateInput>
  }

  /**
   * PropertyAmenity delete
   */
  export type PropertyAmenityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
    /**
     * Filter which PropertyAmenity to delete.
     */
    where: PropertyAmenityWhereUniqueInput
  }

  /**
   * PropertyAmenity deleteMany
   */
  export type PropertyAmenityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAmenities to delete
     */
    where?: PropertyAmenityWhereInput
    /**
     * Limit how many PropertyAmenities to delete.
     */
    limit?: number
  }

  /**
   * PropertyAmenity without action
   */
  export type PropertyAmenityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAmenity
     */
    select?: PropertyAmenitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAmenity
     */
    omit?: PropertyAmenityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAmenityInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    guests: number | null
    totalPrice: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    ownerRevenue: number | null
    platformFee: number | null
    commissionRate: number | null
    commissionAmount: number | null
    netRevenue: number | null
  }

  export type BookingSumAggregateOutputType = {
    guests: number | null
    totalPrice: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    ownerRevenue: number | null
    platformFee: number | null
    commissionRate: number | null
    commissionAmount: number | null
    netRevenue: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    guestId: string | null
    status: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    checkIn: Date | null
    checkOut: Date | null
    guests: number | null
    totalPrice: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    currency: string | null
    ownerRevenue: number | null
    platformFee: number | null
    source: $Enums.BookingSource | null
    externalId: string | null
    externalPlatform: string | null
    commissionRate: number | null
    commissionAmount: number | null
    netRevenue: number | null
    externalGuestId: string | null
    iCalUid: string | null
    lastSyncedAt: Date | null
    roomId: string | null
    roomName: string | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    specialRequests: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    guestId: string | null
    status: $Enums.BookingStatus | null
    paymentStatus: $Enums.PaymentStatus | null
    checkIn: Date | null
    checkOut: Date | null
    guests: number | null
    totalPrice: number | null
    basePrice: number | null
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    currency: string | null
    ownerRevenue: number | null
    platformFee: number | null
    source: $Enums.BookingSource | null
    externalId: string | null
    externalPlatform: string | null
    commissionRate: number | null
    commissionAmount: number | null
    netRevenue: number | null
    externalGuestId: string | null
    iCalUid: string | null
    lastSyncedAt: Date | null
    roomId: string | null
    roomName: string | null
    guestName: string | null
    guestEmail: string | null
    guestPhone: string | null
    specialRequests: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    propertyId: number
    guestId: number
    status: number
    paymentStatus: number
    checkIn: number
    checkOut: number
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee: number
    serviceFee: number
    taxes: number
    currency: number
    ownerRevenue: number
    platformFee: number
    source: number
    externalId: number
    externalPlatform: number
    externalData: number
    commissionRate: number
    commissionAmount: number
    netRevenue: number
    externalGuestId: number
    iCalUid: number
    lastSyncedAt: number
    roomId: number
    roomName: number
    guestName: number
    guestEmail: number
    guestPhone: number
    specialRequests: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    guests?: true
    totalPrice?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    ownerRevenue?: true
    platformFee?: true
    commissionRate?: true
    commissionAmount?: true
    netRevenue?: true
  }

  export type BookingSumAggregateInputType = {
    guests?: true
    totalPrice?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    ownerRevenue?: true
    platformFee?: true
    commissionRate?: true
    commissionAmount?: true
    netRevenue?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    propertyId?: true
    guestId?: true
    status?: true
    paymentStatus?: true
    checkIn?: true
    checkOut?: true
    guests?: true
    totalPrice?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    currency?: true
    ownerRevenue?: true
    platformFee?: true
    source?: true
    externalId?: true
    externalPlatform?: true
    commissionRate?: true
    commissionAmount?: true
    netRevenue?: true
    externalGuestId?: true
    iCalUid?: true
    lastSyncedAt?: true
    roomId?: true
    roomName?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    propertyId?: true
    guestId?: true
    status?: true
    paymentStatus?: true
    checkIn?: true
    checkOut?: true
    guests?: true
    totalPrice?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    currency?: true
    ownerRevenue?: true
    platformFee?: true
    source?: true
    externalId?: true
    externalPlatform?: true
    commissionRate?: true
    commissionAmount?: true
    netRevenue?: true
    externalGuestId?: true
    iCalUid?: true
    lastSyncedAt?: true
    roomId?: true
    roomName?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    propertyId?: true
    guestId?: true
    status?: true
    paymentStatus?: true
    checkIn?: true
    checkOut?: true
    guests?: true
    totalPrice?: true
    basePrice?: true
    cleaningFee?: true
    serviceFee?: true
    taxes?: true
    currency?: true
    ownerRevenue?: true
    platformFee?: true
    source?: true
    externalId?: true
    externalPlatform?: true
    externalData?: true
    commissionRate?: true
    commissionAmount?: true
    netRevenue?: true
    externalGuestId?: true
    iCalUid?: true
    lastSyncedAt?: true
    roomId?: true
    roomName?: true
    guestName?: true
    guestEmail?: true
    guestPhone?: true
    specialRequests?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    propertyId: string
    guestId: string
    status: $Enums.BookingStatus
    paymentStatus: $Enums.PaymentStatus
    checkIn: Date
    checkOut: Date
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee: number | null
    serviceFee: number | null
    taxes: number | null
    currency: string
    ownerRevenue: number | null
    platformFee: number | null
    source: $Enums.BookingSource
    externalId: string | null
    externalPlatform: string | null
    externalData: JsonValue | null
    commissionRate: number | null
    commissionAmount: number | null
    netRevenue: number | null
    externalGuestId: string | null
    iCalUid: string | null
    lastSyncedAt: Date | null
    roomId: string | null
    roomName: string | null
    guestName: string
    guestEmail: string
    guestPhone: string | null
    specialRequests: string | null
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    guestId?: boolean
    status?: boolean
    paymentStatus?: boolean
    checkIn?: boolean
    checkOut?: boolean
    guests?: boolean
    totalPrice?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    currency?: boolean
    ownerRevenue?: boolean
    platformFee?: boolean
    source?: boolean
    externalId?: boolean
    externalPlatform?: boolean
    externalData?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    netRevenue?: boolean
    externalGuestId?: boolean
    iCalUid?: boolean
    lastSyncedAt?: boolean
    roomId?: boolean
    roomName?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    reviews?: boolean | Booking$reviewsArgs<ExtArgs>
    messages?: boolean | Booking$messagesArgs<ExtArgs>
    maintenance?: boolean | Booking$maintenanceArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    guestId?: boolean
    status?: boolean
    paymentStatus?: boolean
    checkIn?: boolean
    checkOut?: boolean
    guests?: boolean
    totalPrice?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    currency?: boolean
    ownerRevenue?: boolean
    platformFee?: boolean
    source?: boolean
    externalId?: boolean
    externalPlatform?: boolean
    externalData?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    netRevenue?: boolean
    externalGuestId?: boolean
    iCalUid?: boolean
    lastSyncedAt?: boolean
    roomId?: boolean
    roomName?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    guestId?: boolean
    status?: boolean
    paymentStatus?: boolean
    checkIn?: boolean
    checkOut?: boolean
    guests?: boolean
    totalPrice?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    currency?: boolean
    ownerRevenue?: boolean
    platformFee?: boolean
    source?: boolean
    externalId?: boolean
    externalPlatform?: boolean
    externalData?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    netRevenue?: boolean
    externalGuestId?: boolean
    iCalUid?: boolean
    lastSyncedAt?: boolean
    roomId?: boolean
    roomName?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    propertyId?: boolean
    guestId?: boolean
    status?: boolean
    paymentStatus?: boolean
    checkIn?: boolean
    checkOut?: boolean
    guests?: boolean
    totalPrice?: boolean
    basePrice?: boolean
    cleaningFee?: boolean
    serviceFee?: boolean
    taxes?: boolean
    currency?: boolean
    ownerRevenue?: boolean
    platformFee?: boolean
    source?: boolean
    externalId?: boolean
    externalPlatform?: boolean
    externalData?: boolean
    commissionRate?: boolean
    commissionAmount?: boolean
    netRevenue?: boolean
    externalGuestId?: boolean
    iCalUid?: boolean
    lastSyncedAt?: boolean
    roomId?: boolean
    roomName?: boolean
    guestName?: boolean
    guestEmail?: boolean
    guestPhone?: boolean
    specialRequests?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "guestId" | "status" | "paymentStatus" | "checkIn" | "checkOut" | "guests" | "totalPrice" | "basePrice" | "cleaningFee" | "serviceFee" | "taxes" | "currency" | "ownerRevenue" | "platformFee" | "source" | "externalId" | "externalPlatform" | "externalData" | "commissionRate" | "commissionAmount" | "netRevenue" | "externalGuestId" | "iCalUid" | "lastSyncedAt" | "roomId" | "roomName" | "guestName" | "guestEmail" | "guestPhone" | "specialRequests" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Booking$paymentsArgs<ExtArgs>
    reviews?: boolean | Booking$reviewsArgs<ExtArgs>
    messages?: boolean | Booking$messagesArgs<ExtArgs>
    maintenance?: boolean | Booking$maintenanceArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      guest: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      maintenance: Prisma.$MaintenanceRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      guestId: string
      status: $Enums.BookingStatus
      paymentStatus: $Enums.PaymentStatus
      checkIn: Date
      checkOut: Date
      guests: number
      totalPrice: number
      basePrice: number
      cleaningFee: number | null
      serviceFee: number | null
      taxes: number | null
      currency: string
      ownerRevenue: number | null
      platformFee: number | null
      source: $Enums.BookingSource
      externalId: string | null
      externalPlatform: string | null
      externalData: Prisma.JsonValue | null
      commissionRate: number | null
      commissionAmount: number | null
      netRevenue: number | null
      externalGuestId: string | null
      iCalUid: string | null
      lastSyncedAt: Date | null
      roomId: string | null
      roomName: string | null
      guestName: string
      guestEmail: string
      guestPhone: string | null
      specialRequests: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guest<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Booking$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Booking$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Booking$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends Booking$messagesArgs<ExtArgs> = {}>(args?: Subset<T, Booking$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    maintenance<T extends Booking$maintenanceArgs<ExtArgs> = {}>(args?: Subset<T, Booking$maintenanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly propertyId: FieldRef<"Booking", 'String'>
    readonly guestId: FieldRef<"Booking", 'String'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly paymentStatus: FieldRef<"Booking", 'PaymentStatus'>
    readonly checkIn: FieldRef<"Booking", 'DateTime'>
    readonly checkOut: FieldRef<"Booking", 'DateTime'>
    readonly guests: FieldRef<"Booking", 'Int'>
    readonly totalPrice: FieldRef<"Booking", 'Float'>
    readonly basePrice: FieldRef<"Booking", 'Float'>
    readonly cleaningFee: FieldRef<"Booking", 'Float'>
    readonly serviceFee: FieldRef<"Booking", 'Float'>
    readonly taxes: FieldRef<"Booking", 'Float'>
    readonly currency: FieldRef<"Booking", 'String'>
    readonly ownerRevenue: FieldRef<"Booking", 'Float'>
    readonly platformFee: FieldRef<"Booking", 'Float'>
    readonly source: FieldRef<"Booking", 'BookingSource'>
    readonly externalId: FieldRef<"Booking", 'String'>
    readonly externalPlatform: FieldRef<"Booking", 'String'>
    readonly externalData: FieldRef<"Booking", 'Json'>
    readonly commissionRate: FieldRef<"Booking", 'Float'>
    readonly commissionAmount: FieldRef<"Booking", 'Float'>
    readonly netRevenue: FieldRef<"Booking", 'Float'>
    readonly externalGuestId: FieldRef<"Booking", 'String'>
    readonly iCalUid: FieldRef<"Booking", 'String'>
    readonly lastSyncedAt: FieldRef<"Booking", 'DateTime'>
    readonly roomId: FieldRef<"Booking", 'String'>
    readonly roomName: FieldRef<"Booking", 'String'>
    readonly guestName: FieldRef<"Booking", 'String'>
    readonly guestEmail: FieldRef<"Booking", 'String'>
    readonly guestPhone: FieldRef<"Booking", 'String'>
    readonly specialRequests: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.payments
   */
  export type Booking$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking.reviews
   */
  export type Booking$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Booking.messages
   */
  export type Booking$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Booking.maintenance
   */
  export type Booking$maintenanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    cursor?: MaintenanceRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model PropertyAvailability
   */

  export type AggregatePropertyAvailability = {
    _count: PropertyAvailabilityCountAggregateOutputType | null
    _avg: PropertyAvailabilityAvgAggregateOutputType | null
    _sum: PropertyAvailabilitySumAggregateOutputType | null
    _min: PropertyAvailabilityMinAggregateOutputType | null
    _max: PropertyAvailabilityMaxAggregateOutputType | null
  }

  export type PropertyAvailabilityAvgAggregateOutputType = {
    price: number | null
    minStay: number | null
  }

  export type PropertyAvailabilitySumAggregateOutputType = {
    price: number | null
    minStay: number | null
  }

  export type PropertyAvailabilityMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    date: Date | null
    available: boolean | null
    price: number | null
    minStay: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyAvailabilityMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    date: Date | null
    available: boolean | null
    price: number | null
    minStay: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyAvailabilityCountAggregateOutputType = {
    id: number
    propertyId: number
    date: number
    available: number
    price: number
    minStay: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAvailabilityAvgAggregateInputType = {
    price?: true
    minStay?: true
  }

  export type PropertyAvailabilitySumAggregateInputType = {
    price?: true
    minStay?: true
  }

  export type PropertyAvailabilityMinAggregateInputType = {
    id?: true
    propertyId?: true
    date?: true
    available?: true
    price?: true
    minStay?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyAvailabilityMaxAggregateInputType = {
    id?: true
    propertyId?: true
    date?: true
    available?: true
    price?: true
    minStay?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyAvailabilityCountAggregateInputType = {
    id?: true
    propertyId?: true
    date?: true
    available?: true
    price?: true
    minStay?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAvailabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAvailability to aggregate.
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAvailabilities to fetch.
     */
    orderBy?: PropertyAvailabilityOrderByWithRelationInput | PropertyAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAvailabilities
    **/
    _count?: true | PropertyAvailabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAvailabilityAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyAvailabilitySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAvailabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAvailabilityMaxAggregateInputType
  }

  export type GetPropertyAvailabilityAggregateType<T extends PropertyAvailabilityAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAvailability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAvailability[P]>
      : GetScalarType<T[P], AggregatePropertyAvailability[P]>
  }




  export type PropertyAvailabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAvailabilityWhereInput
    orderBy?: PropertyAvailabilityOrderByWithAggregationInput | PropertyAvailabilityOrderByWithAggregationInput[]
    by: PropertyAvailabilityScalarFieldEnum[] | PropertyAvailabilityScalarFieldEnum
    having?: PropertyAvailabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAvailabilityCountAggregateInputType | true
    _avg?: PropertyAvailabilityAvgAggregateInputType
    _sum?: PropertyAvailabilitySumAggregateInputType
    _min?: PropertyAvailabilityMinAggregateInputType
    _max?: PropertyAvailabilityMaxAggregateInputType
  }

  export type PropertyAvailabilityGroupByOutputType = {
    id: string
    propertyId: string
    date: Date
    available: boolean
    price: number | null
    minStay: number | null
    createdAt: Date
    updatedAt: Date
    _count: PropertyAvailabilityCountAggregateOutputType | null
    _avg: PropertyAvailabilityAvgAggregateOutputType | null
    _sum: PropertyAvailabilitySumAggregateOutputType | null
    _min: PropertyAvailabilityMinAggregateOutputType | null
    _max: PropertyAvailabilityMaxAggregateOutputType | null
  }

  type GetPropertyAvailabilityGroupByPayload<T extends PropertyAvailabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAvailabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAvailabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAvailabilityGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAvailabilityGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAvailabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAvailability"]>

  export type PropertyAvailabilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAvailability"]>

  export type PropertyAvailabilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAvailability"]>

  export type PropertyAvailabilitySelectScalar = {
    id?: boolean
    propertyId?: boolean
    date?: boolean
    available?: boolean
    price?: boolean
    minStay?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyAvailabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "date" | "available" | "price" | "minStay" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyAvailability"]>
  export type PropertyAvailabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyAvailabilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyAvailabilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyAvailabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAvailability"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      date: Date
      available: boolean
      price: number | null
      minStay: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyAvailability"]>
    composites: {}
  }

  type PropertyAvailabilityGetPayload<S extends boolean | null | undefined | PropertyAvailabilityDefaultArgs> = $Result.GetResult<Prisma.$PropertyAvailabilityPayload, S>

  type PropertyAvailabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyAvailabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyAvailabilityCountAggregateInputType | true
    }

  export interface PropertyAvailabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAvailability'], meta: { name: 'PropertyAvailability' } }
    /**
     * Find zero or one PropertyAvailability that matches the filter.
     * @param {PropertyAvailabilityFindUniqueArgs} args - Arguments to find a PropertyAvailability
     * @example
     * // Get one PropertyAvailability
     * const propertyAvailability = await prisma.propertyAvailability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAvailabilityFindUniqueArgs>(args: SelectSubset<T, PropertyAvailabilityFindUniqueArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyAvailability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyAvailabilityFindUniqueOrThrowArgs} args - Arguments to find a PropertyAvailability
     * @example
     * // Get one PropertyAvailability
     * const propertyAvailability = await prisma.propertyAvailability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAvailabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAvailabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAvailability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityFindFirstArgs} args - Arguments to find a PropertyAvailability
     * @example
     * // Get one PropertyAvailability
     * const propertyAvailability = await prisma.propertyAvailability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAvailabilityFindFirstArgs>(args?: SelectSubset<T, PropertyAvailabilityFindFirstArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAvailability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityFindFirstOrThrowArgs} args - Arguments to find a PropertyAvailability
     * @example
     * // Get one PropertyAvailability
     * const propertyAvailability = await prisma.propertyAvailability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAvailabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAvailabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyAvailabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAvailabilities
     * const propertyAvailabilities = await prisma.propertyAvailability.findMany()
     * 
     * // Get first 10 PropertyAvailabilities
     * const propertyAvailabilities = await prisma.propertyAvailability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAvailabilityWithIdOnly = await prisma.propertyAvailability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAvailabilityFindManyArgs>(args?: SelectSubset<T, PropertyAvailabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyAvailability.
     * @param {PropertyAvailabilityCreateArgs} args - Arguments to create a PropertyAvailability.
     * @example
     * // Create one PropertyAvailability
     * const PropertyAvailability = await prisma.propertyAvailability.create({
     *   data: {
     *     // ... data to create a PropertyAvailability
     *   }
     * })
     * 
     */
    create<T extends PropertyAvailabilityCreateArgs>(args: SelectSubset<T, PropertyAvailabilityCreateArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyAvailabilities.
     * @param {PropertyAvailabilityCreateManyArgs} args - Arguments to create many PropertyAvailabilities.
     * @example
     * // Create many PropertyAvailabilities
     * const propertyAvailability = await prisma.propertyAvailability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAvailabilityCreateManyArgs>(args?: SelectSubset<T, PropertyAvailabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAvailabilities and returns the data saved in the database.
     * @param {PropertyAvailabilityCreateManyAndReturnArgs} args - Arguments to create many PropertyAvailabilities.
     * @example
     * // Create many PropertyAvailabilities
     * const propertyAvailability = await prisma.propertyAvailability.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAvailabilities and only return the `id`
     * const propertyAvailabilityWithIdOnly = await prisma.propertyAvailability.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAvailabilityCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAvailabilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyAvailability.
     * @param {PropertyAvailabilityDeleteArgs} args - Arguments to delete one PropertyAvailability.
     * @example
     * // Delete one PropertyAvailability
     * const PropertyAvailability = await prisma.propertyAvailability.delete({
     *   where: {
     *     // ... filter to delete one PropertyAvailability
     *   }
     * })
     * 
     */
    delete<T extends PropertyAvailabilityDeleteArgs>(args: SelectSubset<T, PropertyAvailabilityDeleteArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyAvailability.
     * @param {PropertyAvailabilityUpdateArgs} args - Arguments to update one PropertyAvailability.
     * @example
     * // Update one PropertyAvailability
     * const propertyAvailability = await prisma.propertyAvailability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAvailabilityUpdateArgs>(args: SelectSubset<T, PropertyAvailabilityUpdateArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyAvailabilities.
     * @param {PropertyAvailabilityDeleteManyArgs} args - Arguments to filter PropertyAvailabilities to delete.
     * @example
     * // Delete a few PropertyAvailabilities
     * const { count } = await prisma.propertyAvailability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAvailabilityDeleteManyArgs>(args?: SelectSubset<T, PropertyAvailabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAvailabilities
     * const propertyAvailability = await prisma.propertyAvailability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAvailabilityUpdateManyArgs>(args: SelectSubset<T, PropertyAvailabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAvailabilities and returns the data updated in the database.
     * @param {PropertyAvailabilityUpdateManyAndReturnArgs} args - Arguments to update many PropertyAvailabilities.
     * @example
     * // Update many PropertyAvailabilities
     * const propertyAvailability = await prisma.propertyAvailability.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyAvailabilities and only return the `id`
     * const propertyAvailabilityWithIdOnly = await prisma.propertyAvailability.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyAvailabilityUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyAvailabilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyAvailability.
     * @param {PropertyAvailabilityUpsertArgs} args - Arguments to update or create a PropertyAvailability.
     * @example
     * // Update or create a PropertyAvailability
     * const propertyAvailability = await prisma.propertyAvailability.upsert({
     *   create: {
     *     // ... data to create a PropertyAvailability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAvailability we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAvailabilityUpsertArgs>(args: SelectSubset<T, PropertyAvailabilityUpsertArgs<ExtArgs>>): Prisma__PropertyAvailabilityClient<$Result.GetResult<Prisma.$PropertyAvailabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyAvailabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityCountArgs} args - Arguments to filter PropertyAvailabilities to count.
     * @example
     * // Count the number of PropertyAvailabilities
     * const count = await prisma.propertyAvailability.count({
     *   where: {
     *     // ... the filter for the PropertyAvailabilities we want to count
     *   }
     * })
    **/
    count<T extends PropertyAvailabilityCountArgs>(
      args?: Subset<T, PropertyAvailabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAvailabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAvailabilityAggregateArgs>(args: Subset<T, PropertyAvailabilityAggregateArgs>): Prisma.PrismaPromise<GetPropertyAvailabilityAggregateType<T>>

    /**
     * Group by PropertyAvailability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAvailabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAvailabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAvailabilityGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAvailabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAvailabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAvailabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAvailability model
   */
  readonly fields: PropertyAvailabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAvailability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAvailabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAvailability model
   */
  interface PropertyAvailabilityFieldRefs {
    readonly id: FieldRef<"PropertyAvailability", 'String'>
    readonly propertyId: FieldRef<"PropertyAvailability", 'String'>
    readonly date: FieldRef<"PropertyAvailability", 'DateTime'>
    readonly available: FieldRef<"PropertyAvailability", 'Boolean'>
    readonly price: FieldRef<"PropertyAvailability", 'Float'>
    readonly minStay: FieldRef<"PropertyAvailability", 'Int'>
    readonly createdAt: FieldRef<"PropertyAvailability", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyAvailability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAvailability findUnique
   */
  export type PropertyAvailabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAvailability to fetch.
     */
    where: PropertyAvailabilityWhereUniqueInput
  }

  /**
   * PropertyAvailability findUniqueOrThrow
   */
  export type PropertyAvailabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAvailability to fetch.
     */
    where: PropertyAvailabilityWhereUniqueInput
  }

  /**
   * PropertyAvailability findFirst
   */
  export type PropertyAvailabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAvailability to fetch.
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAvailabilities to fetch.
     */
    orderBy?: PropertyAvailabilityOrderByWithRelationInput | PropertyAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAvailabilities.
     */
    cursor?: PropertyAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAvailabilities.
     */
    distinct?: PropertyAvailabilityScalarFieldEnum | PropertyAvailabilityScalarFieldEnum[]
  }

  /**
   * PropertyAvailability findFirstOrThrow
   */
  export type PropertyAvailabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAvailability to fetch.
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAvailabilities to fetch.
     */
    orderBy?: PropertyAvailabilityOrderByWithRelationInput | PropertyAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAvailabilities.
     */
    cursor?: PropertyAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAvailabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAvailabilities.
     */
    distinct?: PropertyAvailabilityScalarFieldEnum | PropertyAvailabilityScalarFieldEnum[]
  }

  /**
   * PropertyAvailability findMany
   */
  export type PropertyAvailabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAvailabilities to fetch.
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAvailabilities to fetch.
     */
    orderBy?: PropertyAvailabilityOrderByWithRelationInput | PropertyAvailabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAvailabilities.
     */
    cursor?: PropertyAvailabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAvailabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAvailabilities.
     */
    skip?: number
    distinct?: PropertyAvailabilityScalarFieldEnum | PropertyAvailabilityScalarFieldEnum[]
  }

  /**
   * PropertyAvailability create
   */
  export type PropertyAvailabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyAvailability.
     */
    data: XOR<PropertyAvailabilityCreateInput, PropertyAvailabilityUncheckedCreateInput>
  }

  /**
   * PropertyAvailability createMany
   */
  export type PropertyAvailabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAvailabilities.
     */
    data: PropertyAvailabilityCreateManyInput | PropertyAvailabilityCreateManyInput[]
  }

  /**
   * PropertyAvailability createManyAndReturn
   */
  export type PropertyAvailabilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyAvailabilities.
     */
    data: PropertyAvailabilityCreateManyInput | PropertyAvailabilityCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAvailability update
   */
  export type PropertyAvailabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyAvailability.
     */
    data: XOR<PropertyAvailabilityUpdateInput, PropertyAvailabilityUncheckedUpdateInput>
    /**
     * Choose, which PropertyAvailability to update.
     */
    where: PropertyAvailabilityWhereUniqueInput
  }

  /**
   * PropertyAvailability updateMany
   */
  export type PropertyAvailabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAvailabilities.
     */
    data: XOR<PropertyAvailabilityUpdateManyMutationInput, PropertyAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAvailabilities to update
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * Limit how many PropertyAvailabilities to update.
     */
    limit?: number
  }

  /**
   * PropertyAvailability updateManyAndReturn
   */
  export type PropertyAvailabilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * The data used to update PropertyAvailabilities.
     */
    data: XOR<PropertyAvailabilityUpdateManyMutationInput, PropertyAvailabilityUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAvailabilities to update
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * Limit how many PropertyAvailabilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAvailability upsert
   */
  export type PropertyAvailabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyAvailability to update in case it exists.
     */
    where: PropertyAvailabilityWhereUniqueInput
    /**
     * In case the PropertyAvailability found by the `where` argument doesn't exist, create a new PropertyAvailability with this data.
     */
    create: XOR<PropertyAvailabilityCreateInput, PropertyAvailabilityUncheckedCreateInput>
    /**
     * In case the PropertyAvailability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAvailabilityUpdateInput, PropertyAvailabilityUncheckedUpdateInput>
  }

  /**
   * PropertyAvailability delete
   */
  export type PropertyAvailabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
    /**
     * Filter which PropertyAvailability to delete.
     */
    where: PropertyAvailabilityWhereUniqueInput
  }

  /**
   * PropertyAvailability deleteMany
   */
  export type PropertyAvailabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAvailabilities to delete
     */
    where?: PropertyAvailabilityWhereInput
    /**
     * Limit how many PropertyAvailabilities to delete.
     */
    limit?: number
  }

  /**
   * PropertyAvailability without action
   */
  export type PropertyAvailabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAvailability
     */
    select?: PropertyAvailabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAvailability
     */
    omit?: PropertyAvailabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAvailabilityInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
    cleanlinessRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    locationRating: number | null
    valueRating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
    cleanlinessRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    locationRating: number | null
    valueRating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    bookingId: string | null
    guestId: string | null
    rating: number | null
    cleanlinessRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    locationRating: number | null
    valueRating: number | null
    title: string | null
    comment: string | null
    response: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    bookingId: string | null
    guestId: string | null
    rating: number | null
    cleanlinessRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    locationRating: number | null
    valueRating: number | null
    title: string | null
    comment: string | null
    response: string | null
    isPublic: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    propertyId: number
    bookingId: number
    guestId: number
    rating: number
    cleanlinessRating: number
    accuracyRating: number
    communicationRating: number
    locationRating: number
    valueRating: number
    title: number
    comment: number
    response: number
    isPublic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
    cleanlinessRating?: true
    accuracyRating?: true
    communicationRating?: true
    locationRating?: true
    valueRating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
    cleanlinessRating?: true
    accuracyRating?: true
    communicationRating?: true
    locationRating?: true
    valueRating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    propertyId?: true
    bookingId?: true
    guestId?: true
    rating?: true
    cleanlinessRating?: true
    accuracyRating?: true
    communicationRating?: true
    locationRating?: true
    valueRating?: true
    title?: true
    comment?: true
    response?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    propertyId?: true
    bookingId?: true
    guestId?: true
    rating?: true
    cleanlinessRating?: true
    accuracyRating?: true
    communicationRating?: true
    locationRating?: true
    valueRating?: true
    title?: true
    comment?: true
    response?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    propertyId?: true
    bookingId?: true
    guestId?: true
    rating?: true
    cleanlinessRating?: true
    accuracyRating?: true
    communicationRating?: true
    locationRating?: true
    valueRating?: true
    title?: true
    comment?: true
    response?: true
    isPublic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    propertyId: string
    bookingId: string
    guestId: string
    rating: number
    cleanlinessRating: number | null
    accuracyRating: number | null
    communicationRating: number | null
    locationRating: number | null
    valueRating: number | null
    title: string | null
    comment: string | null
    response: string | null
    isPublic: boolean
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    guestId?: boolean
    rating?: boolean
    cleanlinessRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    locationRating?: boolean
    valueRating?: boolean
    title?: boolean
    comment?: boolean
    response?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    guestId?: boolean
    rating?: boolean
    cleanlinessRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    locationRating?: boolean
    valueRating?: boolean
    title?: boolean
    comment?: boolean
    response?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    guestId?: boolean
    rating?: boolean
    cleanlinessRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    locationRating?: boolean
    valueRating?: boolean
    title?: boolean
    comment?: boolean
    response?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    guestId?: boolean
    rating?: boolean
    cleanlinessRating?: boolean
    accuracyRating?: boolean
    communicationRating?: boolean
    locationRating?: boolean
    valueRating?: boolean
    title?: boolean
    comment?: boolean
    response?: boolean
    isPublic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "bookingId" | "guestId" | "rating" | "cleanlinessRating" | "accuracyRating" | "communicationRating" | "locationRating" | "valueRating" | "title" | "comment" | "response" | "isPublic" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    guest?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs>
      guest: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      bookingId: string
      guestId: string
      rating: number
      cleanlinessRating: number | null
      accuracyRating: number | null
      communicationRating: number | null
      locationRating: number | null
      valueRating: number | null
      title: string | null
      comment: string | null
      response: string | null
      isPublic: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    guest<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly propertyId: FieldRef<"Review", 'String'>
    readonly bookingId: FieldRef<"Review", 'String'>
    readonly guestId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly cleanlinessRating: FieldRef<"Review", 'Int'>
    readonly accuracyRating: FieldRef<"Review", 'Int'>
    readonly communicationRating: FieldRef<"Review", 'Int'>
    readonly locationRating: FieldRef<"Review", 'Int'>
    readonly valueRating: FieldRef<"Review", 'Int'>
    readonly title: FieldRef<"Review", 'String'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly response: FieldRef<"Review", 'String'>
    readonly isPublic: FieldRef<"Review", 'Boolean'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model MaintenanceRequest
   */

  export type AggregateMaintenanceRequest = {
    _count: MaintenanceRequestCountAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  export type MaintenanceRequestMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    bookingId: string | null
    title: string | null
    description: string | null
    priority: $Enums.MaintenancePriority | null
    status: $Enums.MaintenanceStatus | null
    assignedTo: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceRequestMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    bookingId: string | null
    title: string | null
    description: string | null
    priority: $Enums.MaintenancePriority | null
    status: $Enums.MaintenanceStatus | null
    assignedTo: string | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MaintenanceRequestCountAggregateOutputType = {
    id: number
    propertyId: number
    bookingId: number
    title: number
    description: number
    priority: number
    status: number
    assignedTo: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MaintenanceRequestMinAggregateInputType = {
    id?: true
    propertyId?: true
    bookingId?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    assignedTo?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceRequestMaxAggregateInputType = {
    id?: true
    propertyId?: true
    bookingId?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    assignedTo?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MaintenanceRequestCountAggregateInputType = {
    id?: true
    propertyId?: true
    bookingId?: true
    title?: true
    description?: true
    priority?: true
    status?: true
    assignedTo?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MaintenanceRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequest to aggregate.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MaintenanceRequests
    **/
    _count?: true | MaintenanceRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaintenanceRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type GetMaintenanceRequestAggregateType<T extends MaintenanceRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMaintenanceRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
      : GetScalarType<T[P], AggregateMaintenanceRequest[P]>
  }




  export type MaintenanceRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaintenanceRequestWhereInput
    orderBy?: MaintenanceRequestOrderByWithAggregationInput | MaintenanceRequestOrderByWithAggregationInput[]
    by: MaintenanceRequestScalarFieldEnum[] | MaintenanceRequestScalarFieldEnum
    having?: MaintenanceRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaintenanceRequestCountAggregateInputType | true
    _min?: MaintenanceRequestMinAggregateInputType
    _max?: MaintenanceRequestMaxAggregateInputType
  }

  export type MaintenanceRequestGroupByOutputType = {
    id: string
    propertyId: string
    bookingId: string | null
    title: string
    description: string
    priority: $Enums.MaintenancePriority
    status: $Enums.MaintenanceStatus
    assignedTo: string | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: MaintenanceRequestCountAggregateOutputType | null
    _min: MaintenanceRequestMinAggregateOutputType | null
    _max: MaintenanceRequestMaxAggregateOutputType | null
  }

  type GetMaintenanceRequestGroupByPayload<T extends MaintenanceRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaintenanceRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaintenanceRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MaintenanceRequestGroupByOutputType[P]>
        }
      >
    >


  export type MaintenanceRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | MaintenanceRequest$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | MaintenanceRequest$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | MaintenanceRequest$bookingArgs<ExtArgs>
  }, ExtArgs["result"]["maintenanceRequest"]>

  export type MaintenanceRequestSelectScalar = {
    id?: boolean
    propertyId?: boolean
    bookingId?: boolean
    title?: boolean
    description?: boolean
    priority?: boolean
    status?: boolean
    assignedTo?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MaintenanceRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "bookingId" | "title" | "description" | "priority" | "status" | "assignedTo" | "completedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["maintenanceRequest"]>
  export type MaintenanceRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | MaintenanceRequest$bookingArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | MaintenanceRequest$bookingArgs<ExtArgs>
  }
  export type MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    booking?: boolean | MaintenanceRequest$bookingArgs<ExtArgs>
  }

  export type $MaintenanceRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MaintenanceRequest"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      bookingId: string | null
      title: string
      description: string
      priority: $Enums.MaintenancePriority
      status: $Enums.MaintenanceStatus
      assignedTo: string | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["maintenanceRequest"]>
    composites: {}
  }

  type MaintenanceRequestGetPayload<S extends boolean | null | undefined | MaintenanceRequestDefaultArgs> = $Result.GetResult<Prisma.$MaintenanceRequestPayload, S>

  type MaintenanceRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaintenanceRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaintenanceRequestCountAggregateInputType | true
    }

  export interface MaintenanceRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MaintenanceRequest'], meta: { name: 'MaintenanceRequest' } }
    /**
     * Find zero or one MaintenanceRequest that matches the filter.
     * @param {MaintenanceRequestFindUniqueArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaintenanceRequestFindUniqueArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MaintenanceRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaintenanceRequestFindUniqueOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaintenanceRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaintenanceRequestFindFirstArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MaintenanceRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindFirstOrThrowArgs} args - Arguments to find a MaintenanceRequest
     * @example
     * // Get one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaintenanceRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MaintenanceRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MaintenanceRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany()
     * 
     * // Get first 10 MaintenanceRequests
     * const maintenanceRequests = await prisma.maintenanceRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaintenanceRequestFindManyArgs>(args?: SelectSubset<T, MaintenanceRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MaintenanceRequest.
     * @param {MaintenanceRequestCreateArgs} args - Arguments to create a MaintenanceRequest.
     * @example
     * // Create one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.create({
     *   data: {
     *     // ... data to create a MaintenanceRequest
     *   }
     * })
     * 
     */
    create<T extends MaintenanceRequestCreateArgs>(args: SelectSubset<T, MaintenanceRequestCreateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MaintenanceRequests.
     * @param {MaintenanceRequestCreateManyArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaintenanceRequestCreateManyArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MaintenanceRequests and returns the data saved in the database.
     * @param {MaintenanceRequestCreateManyAndReturnArgs} args - Arguments to create many MaintenanceRequests.
     * @example
     * // Create many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaintenanceRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MaintenanceRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MaintenanceRequest.
     * @param {MaintenanceRequestDeleteArgs} args - Arguments to delete one MaintenanceRequest.
     * @example
     * // Delete one MaintenanceRequest
     * const MaintenanceRequest = await prisma.maintenanceRequest.delete({
     *   where: {
     *     // ... filter to delete one MaintenanceRequest
     *   }
     * })
     * 
     */
    delete<T extends MaintenanceRequestDeleteArgs>(args: SelectSubset<T, MaintenanceRequestDeleteArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MaintenanceRequest.
     * @param {MaintenanceRequestUpdateArgs} args - Arguments to update one MaintenanceRequest.
     * @example
     * // Update one MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaintenanceRequestUpdateArgs>(args: SelectSubset<T, MaintenanceRequestUpdateArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MaintenanceRequests.
     * @param {MaintenanceRequestDeleteManyArgs} args - Arguments to filter MaintenanceRequests to delete.
     * @example
     * // Delete a few MaintenanceRequests
     * const { count } = await prisma.maintenanceRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaintenanceRequestDeleteManyArgs>(args?: SelectSubset<T, MaintenanceRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaintenanceRequestUpdateManyArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MaintenanceRequests and returns the data updated in the database.
     * @param {MaintenanceRequestUpdateManyAndReturnArgs} args - Arguments to update many MaintenanceRequests.
     * @example
     * // Update many MaintenanceRequests
     * const maintenanceRequest = await prisma.maintenanceRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MaintenanceRequests and only return the `id`
     * const maintenanceRequestWithIdOnly = await prisma.maintenanceRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaintenanceRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MaintenanceRequest.
     * @param {MaintenanceRequestUpsertArgs} args - Arguments to update or create a MaintenanceRequest.
     * @example
     * // Update or create a MaintenanceRequest
     * const maintenanceRequest = await prisma.maintenanceRequest.upsert({
     *   create: {
     *     // ... data to create a MaintenanceRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MaintenanceRequest we want to update
     *   }
     * })
     */
    upsert<T extends MaintenanceRequestUpsertArgs>(args: SelectSubset<T, MaintenanceRequestUpsertArgs<ExtArgs>>): Prisma__MaintenanceRequestClient<$Result.GetResult<Prisma.$MaintenanceRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MaintenanceRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestCountArgs} args - Arguments to filter MaintenanceRequests to count.
     * @example
     * // Count the number of MaintenanceRequests
     * const count = await prisma.maintenanceRequest.count({
     *   where: {
     *     // ... the filter for the MaintenanceRequests we want to count
     *   }
     * })
    **/
    count<T extends MaintenanceRequestCountArgs>(
      args?: Subset<T, MaintenanceRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaintenanceRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaintenanceRequestAggregateArgs>(args: Subset<T, MaintenanceRequestAggregateArgs>): Prisma.PrismaPromise<GetMaintenanceRequestAggregateType<T>>

    /**
     * Group by MaintenanceRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaintenanceRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaintenanceRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaintenanceRequestGroupByArgs['orderBy'] }
        : { orderBy?: MaintenanceRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaintenanceRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaintenanceRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MaintenanceRequest model
   */
  readonly fields: MaintenanceRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MaintenanceRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaintenanceRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    booking<T extends MaintenanceRequest$bookingArgs<ExtArgs> = {}>(args?: Subset<T, MaintenanceRequest$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MaintenanceRequest model
   */
  interface MaintenanceRequestFieldRefs {
    readonly id: FieldRef<"MaintenanceRequest", 'String'>
    readonly propertyId: FieldRef<"MaintenanceRequest", 'String'>
    readonly bookingId: FieldRef<"MaintenanceRequest", 'String'>
    readonly title: FieldRef<"MaintenanceRequest", 'String'>
    readonly description: FieldRef<"MaintenanceRequest", 'String'>
    readonly priority: FieldRef<"MaintenanceRequest", 'MaintenancePriority'>
    readonly status: FieldRef<"MaintenanceRequest", 'MaintenanceStatus'>
    readonly assignedTo: FieldRef<"MaintenanceRequest", 'String'>
    readonly completedAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly createdAt: FieldRef<"MaintenanceRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"MaintenanceRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MaintenanceRequest findUnique
   */
  export type MaintenanceRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findUniqueOrThrow
   */
  export type MaintenanceRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest findFirst
   */
  export type MaintenanceRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findFirstOrThrow
   */
  export type MaintenanceRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequest to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MaintenanceRequests.
     */
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest findMany
   */
  export type MaintenanceRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter, which MaintenanceRequests to fetch.
     */
    where?: MaintenanceRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MaintenanceRequests to fetch.
     */
    orderBy?: MaintenanceRequestOrderByWithRelationInput | MaintenanceRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MaintenanceRequests.
     */
    cursor?: MaintenanceRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MaintenanceRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MaintenanceRequests.
     */
    skip?: number
    distinct?: MaintenanceRequestScalarFieldEnum | MaintenanceRequestScalarFieldEnum[]
  }

  /**
   * MaintenanceRequest create
   */
  export type MaintenanceRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
  }

  /**
   * MaintenanceRequest createMany
   */
  export type MaintenanceRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
  }

  /**
   * MaintenanceRequest createManyAndReturn
   */
  export type MaintenanceRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MaintenanceRequests.
     */
    data: MaintenanceRequestCreateManyInput | MaintenanceRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest update
   */
  export type MaintenanceRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MaintenanceRequest.
     */
    data: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
    /**
     * Choose, which MaintenanceRequest to update.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest updateMany
   */
  export type MaintenanceRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest updateManyAndReturn
   */
  export type MaintenanceRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * The data used to update MaintenanceRequests.
     */
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyInput>
    /**
     * Filter which MaintenanceRequests to update
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MaintenanceRequest upsert
   */
  export type MaintenanceRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MaintenanceRequest to update in case it exists.
     */
    where: MaintenanceRequestWhereUniqueInput
    /**
     * In case the MaintenanceRequest found by the `where` argument doesn't exist, create a new MaintenanceRequest with this data.
     */
    create: XOR<MaintenanceRequestCreateInput, MaintenanceRequestUncheckedCreateInput>
    /**
     * In case the MaintenanceRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaintenanceRequestUpdateInput, MaintenanceRequestUncheckedUpdateInput>
  }

  /**
   * MaintenanceRequest delete
   */
  export type MaintenanceRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
    /**
     * Filter which MaintenanceRequest to delete.
     */
    where: MaintenanceRequestWhereUniqueInput
  }

  /**
   * MaintenanceRequest deleteMany
   */
  export type MaintenanceRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MaintenanceRequests to delete
     */
    where?: MaintenanceRequestWhereInput
    /**
     * Limit how many MaintenanceRequests to delete.
     */
    limit?: number
  }

  /**
   * MaintenanceRequest.booking
   */
  export type MaintenanceRequest$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * MaintenanceRequest without action
   */
  export type MaintenanceRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MaintenanceRequest
     */
    select?: MaintenanceRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MaintenanceRequest
     */
    omit?: MaintenanceRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaintenanceRequestInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    senderId: string | null
    content: string | null
    type: $Enums.MessageType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    senderId: string | null
    content: string | null
    type: $Enums.MessageType | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    bookingId: number
    senderId: number
    content: number
    type: number
    isRead: number
    createdAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    bookingId?: true
    senderId?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    bookingId?: true
    senderId?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    bookingId?: true
    senderId?: true
    content?: true
    type?: true
    isRead?: true
    createdAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    bookingId: string
    senderId: string
    content: string
    type: $Enums.MessageType
    isRead: boolean
    createdAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    bookingId?: boolean
    senderId?: boolean
    content?: boolean
    type?: boolean
    isRead?: boolean
    createdAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "senderId" | "content" | "type" | "isRead" | "createdAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      senderId: string
      content: string
      type: $Enums.MessageType
      isRead: boolean
      createdAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly bookingId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'MessageType'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    message: string | null
    isRead: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    title: number
    message: number
    isRead: number
    data: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead: boolean
    data: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "title" | "message" | "isRead" | "data" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: $Enums.NotificationType
      title: string
      message: string
      isRead: boolean
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Edition
   */

  export type AggregateEdition = {
    _count: EditionCountAggregateOutputType | null
    _avg: EditionAvgAggregateOutputType | null
    _sum: EditionSumAggregateOutputType | null
    _min: EditionMinAggregateOutputType | null
    _max: EditionMaxAggregateOutputType | null
  }

  export type EditionAvgAggregateOutputType = {
    order: number | null
  }

  export type EditionSumAggregateOutputType = {
    order: number | null
  }

  export type EditionMinAggregateOutputType = {
    id: string | null
    category: string | null
    titleGr: string | null
    titleEn: string | null
    descriptionGr: string | null
    descriptionEn: string | null
    contentGr: string | null
    contentEn: string | null
    status: $Enums.ContentStatus | null
    featured: boolean | null
    order: number | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditionMaxAggregateOutputType = {
    id: string | null
    category: string | null
    titleGr: string | null
    titleEn: string | null
    descriptionGr: string | null
    descriptionEn: string | null
    contentGr: string | null
    contentEn: string | null
    status: $Enums.ContentStatus | null
    featured: boolean | null
    order: number | null
    icon: string | null
    color: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EditionCountAggregateOutputType = {
    id: number
    category: number
    titleGr: number
    titleEn: number
    descriptionGr: number
    descriptionEn: number
    contentGr: number
    contentEn: number
    status: number
    featured: number
    order: number
    icon: number
    color: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EditionAvgAggregateInputType = {
    order?: true
  }

  export type EditionSumAggregateInputType = {
    order?: true
  }

  export type EditionMinAggregateInputType = {
    id?: true
    category?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    contentGr?: true
    contentEn?: true
    status?: true
    featured?: true
    order?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditionMaxAggregateInputType = {
    id?: true
    category?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    contentGr?: true
    contentEn?: true
    status?: true
    featured?: true
    order?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EditionCountAggregateInputType = {
    id?: true
    category?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    contentGr?: true
    contentEn?: true
    status?: true
    featured?: true
    order?: true
    icon?: true
    color?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EditionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Edition to aggregate.
     */
    where?: EditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Editions to fetch.
     */
    orderBy?: EditionOrderByWithRelationInput | EditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Editions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Editions
    **/
    _count?: true | EditionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EditionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EditionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EditionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EditionMaxAggregateInputType
  }

  export type GetEditionAggregateType<T extends EditionAggregateArgs> = {
        [P in keyof T & keyof AggregateEdition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEdition[P]>
      : GetScalarType<T[P], AggregateEdition[P]>
  }




  export type EditionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EditionWhereInput
    orderBy?: EditionOrderByWithAggregationInput | EditionOrderByWithAggregationInput[]
    by: EditionScalarFieldEnum[] | EditionScalarFieldEnum
    having?: EditionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EditionCountAggregateInputType | true
    _avg?: EditionAvgAggregateInputType
    _sum?: EditionSumAggregateInputType
    _min?: EditionMinAggregateInputType
    _max?: EditionMaxAggregateInputType
  }

  export type EditionGroupByOutputType = {
    id: string
    category: string
    titleGr: string
    titleEn: string
    descriptionGr: string | null
    descriptionEn: string | null
    contentGr: string | null
    contentEn: string | null
    status: $Enums.ContentStatus
    featured: boolean
    order: number | null
    icon: string | null
    color: string | null
    createdAt: Date
    updatedAt: Date
    _count: EditionCountAggregateOutputType | null
    _avg: EditionAvgAggregateOutputType | null
    _sum: EditionSumAggregateOutputType | null
    _min: EditionMinAggregateOutputType | null
    _max: EditionMaxAggregateOutputType | null
  }

  type GetEditionGroupByPayload<T extends EditionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EditionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EditionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EditionGroupByOutputType[P]>
            : GetScalarType<T[P], EditionGroupByOutputType[P]>
        }
      >
    >


  export type EditionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["edition"]>

  export type EditionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["edition"]>

  export type EditionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    category?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["edition"]>

  export type EditionSelectScalar = {
    id?: boolean
    category?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    status?: boolean
    featured?: boolean
    order?: boolean
    icon?: boolean
    color?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EditionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "category" | "titleGr" | "titleEn" | "descriptionGr" | "descriptionEn" | "contentGr" | "contentEn" | "status" | "featured" | "order" | "icon" | "color" | "createdAt" | "updatedAt", ExtArgs["result"]["edition"]>

  export type $EditionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Edition"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      category: string
      titleGr: string
      titleEn: string
      descriptionGr: string | null
      descriptionEn: string | null
      contentGr: string | null
      contentEn: string | null
      status: $Enums.ContentStatus
      featured: boolean
      order: number | null
      icon: string | null
      color: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["edition"]>
    composites: {}
  }

  type EditionGetPayload<S extends boolean | null | undefined | EditionDefaultArgs> = $Result.GetResult<Prisma.$EditionPayload, S>

  type EditionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EditionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EditionCountAggregateInputType | true
    }

  export interface EditionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Edition'], meta: { name: 'Edition' } }
    /**
     * Find zero or one Edition that matches the filter.
     * @param {EditionFindUniqueArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EditionFindUniqueArgs>(args: SelectSubset<T, EditionFindUniqueArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Edition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EditionFindUniqueOrThrowArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EditionFindUniqueOrThrowArgs>(args: SelectSubset<T, EditionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionFindFirstArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EditionFindFirstArgs>(args?: SelectSubset<T, EditionFindFirstArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Edition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionFindFirstOrThrowArgs} args - Arguments to find a Edition
     * @example
     * // Get one Edition
     * const edition = await prisma.edition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EditionFindFirstOrThrowArgs>(args?: SelectSubset<T, EditionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Editions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Editions
     * const editions = await prisma.edition.findMany()
     * 
     * // Get first 10 Editions
     * const editions = await prisma.edition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const editionWithIdOnly = await prisma.edition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EditionFindManyArgs>(args?: SelectSubset<T, EditionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Edition.
     * @param {EditionCreateArgs} args - Arguments to create a Edition.
     * @example
     * // Create one Edition
     * const Edition = await prisma.edition.create({
     *   data: {
     *     // ... data to create a Edition
     *   }
     * })
     * 
     */
    create<T extends EditionCreateArgs>(args: SelectSubset<T, EditionCreateArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Editions.
     * @param {EditionCreateManyArgs} args - Arguments to create many Editions.
     * @example
     * // Create many Editions
     * const edition = await prisma.edition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EditionCreateManyArgs>(args?: SelectSubset<T, EditionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Editions and returns the data saved in the database.
     * @param {EditionCreateManyAndReturnArgs} args - Arguments to create many Editions.
     * @example
     * // Create many Editions
     * const edition = await prisma.edition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Editions and only return the `id`
     * const editionWithIdOnly = await prisma.edition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EditionCreateManyAndReturnArgs>(args?: SelectSubset<T, EditionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Edition.
     * @param {EditionDeleteArgs} args - Arguments to delete one Edition.
     * @example
     * // Delete one Edition
     * const Edition = await prisma.edition.delete({
     *   where: {
     *     // ... filter to delete one Edition
     *   }
     * })
     * 
     */
    delete<T extends EditionDeleteArgs>(args: SelectSubset<T, EditionDeleteArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Edition.
     * @param {EditionUpdateArgs} args - Arguments to update one Edition.
     * @example
     * // Update one Edition
     * const edition = await prisma.edition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EditionUpdateArgs>(args: SelectSubset<T, EditionUpdateArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Editions.
     * @param {EditionDeleteManyArgs} args - Arguments to filter Editions to delete.
     * @example
     * // Delete a few Editions
     * const { count } = await prisma.edition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EditionDeleteManyArgs>(args?: SelectSubset<T, EditionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Editions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Editions
     * const edition = await prisma.edition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EditionUpdateManyArgs>(args: SelectSubset<T, EditionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Editions and returns the data updated in the database.
     * @param {EditionUpdateManyAndReturnArgs} args - Arguments to update many Editions.
     * @example
     * // Update many Editions
     * const edition = await prisma.edition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Editions and only return the `id`
     * const editionWithIdOnly = await prisma.edition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EditionUpdateManyAndReturnArgs>(args: SelectSubset<T, EditionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Edition.
     * @param {EditionUpsertArgs} args - Arguments to update or create a Edition.
     * @example
     * // Update or create a Edition
     * const edition = await prisma.edition.upsert({
     *   create: {
     *     // ... data to create a Edition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Edition we want to update
     *   }
     * })
     */
    upsert<T extends EditionUpsertArgs>(args: SelectSubset<T, EditionUpsertArgs<ExtArgs>>): Prisma__EditionClient<$Result.GetResult<Prisma.$EditionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Editions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionCountArgs} args - Arguments to filter Editions to count.
     * @example
     * // Count the number of Editions
     * const count = await prisma.edition.count({
     *   where: {
     *     // ... the filter for the Editions we want to count
     *   }
     * })
    **/
    count<T extends EditionCountArgs>(
      args?: Subset<T, EditionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EditionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Edition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EditionAggregateArgs>(args: Subset<T, EditionAggregateArgs>): Prisma.PrismaPromise<GetEditionAggregateType<T>>

    /**
     * Group by Edition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EditionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EditionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EditionGroupByArgs['orderBy'] }
        : { orderBy?: EditionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EditionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEditionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Edition model
   */
  readonly fields: EditionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Edition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EditionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Edition model
   */
  interface EditionFieldRefs {
    readonly id: FieldRef<"Edition", 'String'>
    readonly category: FieldRef<"Edition", 'String'>
    readonly titleGr: FieldRef<"Edition", 'String'>
    readonly titleEn: FieldRef<"Edition", 'String'>
    readonly descriptionGr: FieldRef<"Edition", 'String'>
    readonly descriptionEn: FieldRef<"Edition", 'String'>
    readonly contentGr: FieldRef<"Edition", 'String'>
    readonly contentEn: FieldRef<"Edition", 'String'>
    readonly status: FieldRef<"Edition", 'ContentStatus'>
    readonly featured: FieldRef<"Edition", 'Boolean'>
    readonly order: FieldRef<"Edition", 'Int'>
    readonly icon: FieldRef<"Edition", 'String'>
    readonly color: FieldRef<"Edition", 'String'>
    readonly createdAt: FieldRef<"Edition", 'DateTime'>
    readonly updatedAt: FieldRef<"Edition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Edition findUnique
   */
  export type EditionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * Filter, which Edition to fetch.
     */
    where: EditionWhereUniqueInput
  }

  /**
   * Edition findUniqueOrThrow
   */
  export type EditionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * Filter, which Edition to fetch.
     */
    where: EditionWhereUniqueInput
  }

  /**
   * Edition findFirst
   */
  export type EditionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * Filter, which Edition to fetch.
     */
    where?: EditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Editions to fetch.
     */
    orderBy?: EditionOrderByWithRelationInput | EditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Editions.
     */
    cursor?: EditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Editions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Editions.
     */
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * Edition findFirstOrThrow
   */
  export type EditionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * Filter, which Edition to fetch.
     */
    where?: EditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Editions to fetch.
     */
    orderBy?: EditionOrderByWithRelationInput | EditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Editions.
     */
    cursor?: EditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Editions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Editions.
     */
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * Edition findMany
   */
  export type EditionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * Filter, which Editions to fetch.
     */
    where?: EditionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Editions to fetch.
     */
    orderBy?: EditionOrderByWithRelationInput | EditionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Editions.
     */
    cursor?: EditionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Editions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Editions.
     */
    skip?: number
    distinct?: EditionScalarFieldEnum | EditionScalarFieldEnum[]
  }

  /**
   * Edition create
   */
  export type EditionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * The data needed to create a Edition.
     */
    data: XOR<EditionCreateInput, EditionUncheckedCreateInput>
  }

  /**
   * Edition createMany
   */
  export type EditionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Editions.
     */
    data: EditionCreateManyInput | EditionCreateManyInput[]
  }

  /**
   * Edition createManyAndReturn
   */
  export type EditionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * The data used to create many Editions.
     */
    data: EditionCreateManyInput | EditionCreateManyInput[]
  }

  /**
   * Edition update
   */
  export type EditionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * The data needed to update a Edition.
     */
    data: XOR<EditionUpdateInput, EditionUncheckedUpdateInput>
    /**
     * Choose, which Edition to update.
     */
    where: EditionWhereUniqueInput
  }

  /**
   * Edition updateMany
   */
  export type EditionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Editions.
     */
    data: XOR<EditionUpdateManyMutationInput, EditionUncheckedUpdateManyInput>
    /**
     * Filter which Editions to update
     */
    where?: EditionWhereInput
    /**
     * Limit how many Editions to update.
     */
    limit?: number
  }

  /**
   * Edition updateManyAndReturn
   */
  export type EditionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * The data used to update Editions.
     */
    data: XOR<EditionUpdateManyMutationInput, EditionUncheckedUpdateManyInput>
    /**
     * Filter which Editions to update
     */
    where?: EditionWhereInput
    /**
     * Limit how many Editions to update.
     */
    limit?: number
  }

  /**
   * Edition upsert
   */
  export type EditionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * The filter to search for the Edition to update in case it exists.
     */
    where: EditionWhereUniqueInput
    /**
     * In case the Edition found by the `where` argument doesn't exist, create a new Edition with this data.
     */
    create: XOR<EditionCreateInput, EditionUncheckedCreateInput>
    /**
     * In case the Edition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EditionUpdateInput, EditionUncheckedUpdateInput>
  }

  /**
   * Edition delete
   */
  export type EditionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
    /**
     * Filter which Edition to delete.
     */
    where: EditionWhereUniqueInput
  }

  /**
   * Edition deleteMany
   */
  export type EditionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Editions to delete
     */
    where?: EditionWhereInput
    /**
     * Limit how many Editions to delete.
     */
    limit?: number
  }

  /**
   * Edition without action
   */
  export type EditionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Edition
     */
    select?: EditionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Edition
     */
    omit?: EditionOmit<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    titleGr: string | null
    titleEn: string | null
    descriptionGr: string | null
    descriptionEn: string | null
    icon: string | null
    pricingGr: string | null
    pricingEn: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    titleGr: string | null
    titleEn: string | null
    descriptionGr: string | null
    descriptionEn: string | null
    icon: string | null
    pricingGr: string | null
    pricingEn: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    titleGr: number
    titleEn: number
    descriptionGr: number
    descriptionEn: number
    icon: number
    features: number
    pricingGr: number
    pricingEn: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceMinAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    icon?: true
    pricingGr?: true
    pricingEn?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    icon?: true
    pricingGr?: true
    pricingEn?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    descriptionGr?: true
    descriptionEn?: true
    icon?: true
    features?: true
    pricingGr?: true
    pricingEn?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    titleGr: string
    titleEn: string
    descriptionGr: string | null
    descriptionEn: string | null
    icon: string | null
    features: JsonValue | null
    pricingGr: string | null
    pricingEn: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    icon?: boolean
    features?: boolean
    pricingGr?: boolean
    pricingEn?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    icon?: boolean
    features?: boolean
    pricingGr?: boolean
    pricingEn?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    icon?: boolean
    features?: boolean
    pricingGr?: boolean
    pricingEn?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    icon?: boolean
    features?: boolean
    pricingGr?: boolean
    pricingEn?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titleGr" | "titleEn" | "descriptionGr" | "descriptionEn" | "icon" | "features" | "pricingGr" | "pricingEn" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titleGr: string
      titleEn: string
      descriptionGr: string | null
      descriptionEn: string | null
      icon: string | null
      features: Prisma.JsonValue | null
      pricingGr: string | null
      pricingEn: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly titleGr: FieldRef<"Service", 'String'>
    readonly titleEn: FieldRef<"Service", 'String'>
    readonly descriptionGr: FieldRef<"Service", 'String'>
    readonly descriptionEn: FieldRef<"Service", 'String'>
    readonly icon: FieldRef<"Service", 'String'>
    readonly features: FieldRef<"Service", 'Json'>
    readonly pricingGr: FieldRef<"Service", 'String'>
    readonly pricingEn: FieldRef<"Service", 'String'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
  }


  /**
   * Model KnowledgeArticle
   */

  export type AggregateKnowledgeArticle = {
    _count: KnowledgeArticleCountAggregateOutputType | null
    _avg: KnowledgeArticleAvgAggregateOutputType | null
    _sum: KnowledgeArticleSumAggregateOutputType | null
    _min: KnowledgeArticleMinAggregateOutputType | null
    _max: KnowledgeArticleMaxAggregateOutputType | null
  }

  export type KnowledgeArticleAvgAggregateOutputType = {
    readTime: number | null
  }

  export type KnowledgeArticleSumAggregateOutputType = {
    readTime: number | null
  }

  export type KnowledgeArticleMinAggregateOutputType = {
    id: string | null
    titleGr: string | null
    titleEn: string | null
    contentGr: string | null
    contentEn: string | null
    category: string | null
    author: string | null
    readTime: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeArticleMaxAggregateOutputType = {
    id: string | null
    titleGr: string | null
    titleEn: string | null
    contentGr: string | null
    contentEn: string | null
    category: string | null
    author: string | null
    readTime: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type KnowledgeArticleCountAggregateOutputType = {
    id: number
    titleGr: number
    titleEn: number
    contentGr: number
    contentEn: number
    category: number
    tags: number
    author: number
    readTime: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type KnowledgeArticleAvgAggregateInputType = {
    readTime?: true
  }

  export type KnowledgeArticleSumAggregateInputType = {
    readTime?: true
  }

  export type KnowledgeArticleMinAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    contentGr?: true
    contentEn?: true
    category?: true
    author?: true
    readTime?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeArticleMaxAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    contentGr?: true
    contentEn?: true
    category?: true
    author?: true
    readTime?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type KnowledgeArticleCountAggregateInputType = {
    id?: true
    titleGr?: true
    titleEn?: true
    contentGr?: true
    contentEn?: true
    category?: true
    tags?: true
    author?: true
    readTime?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type KnowledgeArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeArticle to aggregate.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned KnowledgeArticles
    **/
    _count?: true | KnowledgeArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: KnowledgeArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: KnowledgeArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: KnowledgeArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: KnowledgeArticleMaxAggregateInputType
  }

  export type GetKnowledgeArticleAggregateType<T extends KnowledgeArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateKnowledgeArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateKnowledgeArticle[P]>
      : GetScalarType<T[P], AggregateKnowledgeArticle[P]>
  }




  export type KnowledgeArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: KnowledgeArticleWhereInput
    orderBy?: KnowledgeArticleOrderByWithAggregationInput | KnowledgeArticleOrderByWithAggregationInput[]
    by: KnowledgeArticleScalarFieldEnum[] | KnowledgeArticleScalarFieldEnum
    having?: KnowledgeArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: KnowledgeArticleCountAggregateInputType | true
    _avg?: KnowledgeArticleAvgAggregateInputType
    _sum?: KnowledgeArticleSumAggregateInputType
    _min?: KnowledgeArticleMinAggregateInputType
    _max?: KnowledgeArticleMaxAggregateInputType
  }

  export type KnowledgeArticleGroupByOutputType = {
    id: string
    titleGr: string
    titleEn: string
    contentGr: string | null
    contentEn: string | null
    category: string
    tags: JsonValue | null
    author: string
    readTime: number | null
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: KnowledgeArticleCountAggregateOutputType | null
    _avg: KnowledgeArticleAvgAggregateOutputType | null
    _sum: KnowledgeArticleSumAggregateOutputType | null
    _min: KnowledgeArticleMinAggregateOutputType | null
    _max: KnowledgeArticleMaxAggregateOutputType | null
  }

  type GetKnowledgeArticleGroupByPayload<T extends KnowledgeArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<KnowledgeArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof KnowledgeArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], KnowledgeArticleGroupByOutputType[P]>
            : GetScalarType<T[P], KnowledgeArticleGroupByOutputType[P]>
        }
      >
    >


  export type KnowledgeArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    category?: boolean
    tags?: boolean
    author?: boolean
    readTime?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    category?: boolean
    tags?: boolean
    author?: boolean
    readTime?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    category?: boolean
    tags?: boolean
    author?: boolean
    readTime?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["knowledgeArticle"]>

  export type KnowledgeArticleSelectScalar = {
    id?: boolean
    titleGr?: boolean
    titleEn?: boolean
    contentGr?: boolean
    contentEn?: boolean
    category?: boolean
    tags?: boolean
    author?: boolean
    readTime?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type KnowledgeArticleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "titleGr" | "titleEn" | "contentGr" | "contentEn" | "category" | "tags" | "author" | "readTime" | "publishedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["knowledgeArticle"]>

  export type $KnowledgeArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "KnowledgeArticle"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      titleGr: string
      titleEn: string
      contentGr: string | null
      contentEn: string | null
      category: string
      tags: Prisma.JsonValue | null
      author: string
      readTime: number | null
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["knowledgeArticle"]>
    composites: {}
  }

  type KnowledgeArticleGetPayload<S extends boolean | null | undefined | KnowledgeArticleDefaultArgs> = $Result.GetResult<Prisma.$KnowledgeArticlePayload, S>

  type KnowledgeArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<KnowledgeArticleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: KnowledgeArticleCountAggregateInputType | true
    }

  export interface KnowledgeArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['KnowledgeArticle'], meta: { name: 'KnowledgeArticle' } }
    /**
     * Find zero or one KnowledgeArticle that matches the filter.
     * @param {KnowledgeArticleFindUniqueArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends KnowledgeArticleFindUniqueArgs>(args: SelectSubset<T, KnowledgeArticleFindUniqueArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one KnowledgeArticle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {KnowledgeArticleFindUniqueOrThrowArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends KnowledgeArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindFirstArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends KnowledgeArticleFindFirstArgs>(args?: SelectSubset<T, KnowledgeArticleFindFirstArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first KnowledgeArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindFirstOrThrowArgs} args - Arguments to find a KnowledgeArticle
     * @example
     * // Get one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends KnowledgeArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, KnowledgeArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more KnowledgeArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all KnowledgeArticles
     * const knowledgeArticles = await prisma.knowledgeArticle.findMany()
     * 
     * // Get first 10 KnowledgeArticles
     * const knowledgeArticles = await prisma.knowledgeArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends KnowledgeArticleFindManyArgs>(args?: SelectSubset<T, KnowledgeArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a KnowledgeArticle.
     * @param {KnowledgeArticleCreateArgs} args - Arguments to create a KnowledgeArticle.
     * @example
     * // Create one KnowledgeArticle
     * const KnowledgeArticle = await prisma.knowledgeArticle.create({
     *   data: {
     *     // ... data to create a KnowledgeArticle
     *   }
     * })
     * 
     */
    create<T extends KnowledgeArticleCreateArgs>(args: SelectSubset<T, KnowledgeArticleCreateArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many KnowledgeArticles.
     * @param {KnowledgeArticleCreateManyArgs} args - Arguments to create many KnowledgeArticles.
     * @example
     * // Create many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends KnowledgeArticleCreateManyArgs>(args?: SelectSubset<T, KnowledgeArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many KnowledgeArticles and returns the data saved in the database.
     * @param {KnowledgeArticleCreateManyAndReturnArgs} args - Arguments to create many KnowledgeArticles.
     * @example
     * // Create many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many KnowledgeArticles and only return the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends KnowledgeArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, KnowledgeArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a KnowledgeArticle.
     * @param {KnowledgeArticleDeleteArgs} args - Arguments to delete one KnowledgeArticle.
     * @example
     * // Delete one KnowledgeArticle
     * const KnowledgeArticle = await prisma.knowledgeArticle.delete({
     *   where: {
     *     // ... filter to delete one KnowledgeArticle
     *   }
     * })
     * 
     */
    delete<T extends KnowledgeArticleDeleteArgs>(args: SelectSubset<T, KnowledgeArticleDeleteArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one KnowledgeArticle.
     * @param {KnowledgeArticleUpdateArgs} args - Arguments to update one KnowledgeArticle.
     * @example
     * // Update one KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends KnowledgeArticleUpdateArgs>(args: SelectSubset<T, KnowledgeArticleUpdateArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more KnowledgeArticles.
     * @param {KnowledgeArticleDeleteManyArgs} args - Arguments to filter KnowledgeArticles to delete.
     * @example
     * // Delete a few KnowledgeArticles
     * const { count } = await prisma.knowledgeArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends KnowledgeArticleDeleteManyArgs>(args?: SelectSubset<T, KnowledgeArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends KnowledgeArticleUpdateManyArgs>(args: SelectSubset<T, KnowledgeArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more KnowledgeArticles and returns the data updated in the database.
     * @param {KnowledgeArticleUpdateManyAndReturnArgs} args - Arguments to update many KnowledgeArticles.
     * @example
     * // Update many KnowledgeArticles
     * const knowledgeArticle = await prisma.knowledgeArticle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more KnowledgeArticles and only return the `id`
     * const knowledgeArticleWithIdOnly = await prisma.knowledgeArticle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends KnowledgeArticleUpdateManyAndReturnArgs>(args: SelectSubset<T, KnowledgeArticleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one KnowledgeArticle.
     * @param {KnowledgeArticleUpsertArgs} args - Arguments to update or create a KnowledgeArticle.
     * @example
     * // Update or create a KnowledgeArticle
     * const knowledgeArticle = await prisma.knowledgeArticle.upsert({
     *   create: {
     *     // ... data to create a KnowledgeArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the KnowledgeArticle we want to update
     *   }
     * })
     */
    upsert<T extends KnowledgeArticleUpsertArgs>(args: SelectSubset<T, KnowledgeArticleUpsertArgs<ExtArgs>>): Prisma__KnowledgeArticleClient<$Result.GetResult<Prisma.$KnowledgeArticlePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of KnowledgeArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleCountArgs} args - Arguments to filter KnowledgeArticles to count.
     * @example
     * // Count the number of KnowledgeArticles
     * const count = await prisma.knowledgeArticle.count({
     *   where: {
     *     // ... the filter for the KnowledgeArticles we want to count
     *   }
     * })
    **/
    count<T extends KnowledgeArticleCountArgs>(
      args?: Subset<T, KnowledgeArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], KnowledgeArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a KnowledgeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends KnowledgeArticleAggregateArgs>(args: Subset<T, KnowledgeArticleAggregateArgs>): Prisma.PrismaPromise<GetKnowledgeArticleAggregateType<T>>

    /**
     * Group by KnowledgeArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {KnowledgeArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends KnowledgeArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: KnowledgeArticleGroupByArgs['orderBy'] }
        : { orderBy?: KnowledgeArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, KnowledgeArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetKnowledgeArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the KnowledgeArticle model
   */
  readonly fields: KnowledgeArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for KnowledgeArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__KnowledgeArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the KnowledgeArticle model
   */
  interface KnowledgeArticleFieldRefs {
    readonly id: FieldRef<"KnowledgeArticle", 'String'>
    readonly titleGr: FieldRef<"KnowledgeArticle", 'String'>
    readonly titleEn: FieldRef<"KnowledgeArticle", 'String'>
    readonly contentGr: FieldRef<"KnowledgeArticle", 'String'>
    readonly contentEn: FieldRef<"KnowledgeArticle", 'String'>
    readonly category: FieldRef<"KnowledgeArticle", 'String'>
    readonly tags: FieldRef<"KnowledgeArticle", 'Json'>
    readonly author: FieldRef<"KnowledgeArticle", 'String'>
    readonly readTime: FieldRef<"KnowledgeArticle", 'Int'>
    readonly publishedAt: FieldRef<"KnowledgeArticle", 'DateTime'>
    readonly createdAt: FieldRef<"KnowledgeArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"KnowledgeArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * KnowledgeArticle findUnique
   */
  export type KnowledgeArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle findUniqueOrThrow
   */
  export type KnowledgeArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle findFirst
   */
  export type KnowledgeArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeArticles.
     */
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle findFirstOrThrow
   */
  export type KnowledgeArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticle to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of KnowledgeArticles.
     */
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle findMany
   */
  export type KnowledgeArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * Filter, which KnowledgeArticles to fetch.
     */
    where?: KnowledgeArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of KnowledgeArticles to fetch.
     */
    orderBy?: KnowledgeArticleOrderByWithRelationInput | KnowledgeArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing KnowledgeArticles.
     */
    cursor?: KnowledgeArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` KnowledgeArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` KnowledgeArticles.
     */
    skip?: number
    distinct?: KnowledgeArticleScalarFieldEnum | KnowledgeArticleScalarFieldEnum[]
  }

  /**
   * KnowledgeArticle create
   */
  export type KnowledgeArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * The data needed to create a KnowledgeArticle.
     */
    data: XOR<KnowledgeArticleCreateInput, KnowledgeArticleUncheckedCreateInput>
  }

  /**
   * KnowledgeArticle createMany
   */
  export type KnowledgeArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many KnowledgeArticles.
     */
    data: KnowledgeArticleCreateManyInput | KnowledgeArticleCreateManyInput[]
  }

  /**
   * KnowledgeArticle createManyAndReturn
   */
  export type KnowledgeArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * The data used to create many KnowledgeArticles.
     */
    data: KnowledgeArticleCreateManyInput | KnowledgeArticleCreateManyInput[]
  }

  /**
   * KnowledgeArticle update
   */
  export type KnowledgeArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * The data needed to update a KnowledgeArticle.
     */
    data: XOR<KnowledgeArticleUpdateInput, KnowledgeArticleUncheckedUpdateInput>
    /**
     * Choose, which KnowledgeArticle to update.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle updateMany
   */
  export type KnowledgeArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update KnowledgeArticles.
     */
    data: XOR<KnowledgeArticleUpdateManyMutationInput, KnowledgeArticleUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeArticles to update
     */
    where?: KnowledgeArticleWhereInput
    /**
     * Limit how many KnowledgeArticles to update.
     */
    limit?: number
  }

  /**
   * KnowledgeArticle updateManyAndReturn
   */
  export type KnowledgeArticleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * The data used to update KnowledgeArticles.
     */
    data: XOR<KnowledgeArticleUpdateManyMutationInput, KnowledgeArticleUncheckedUpdateManyInput>
    /**
     * Filter which KnowledgeArticles to update
     */
    where?: KnowledgeArticleWhereInput
    /**
     * Limit how many KnowledgeArticles to update.
     */
    limit?: number
  }

  /**
   * KnowledgeArticle upsert
   */
  export type KnowledgeArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * The filter to search for the KnowledgeArticle to update in case it exists.
     */
    where: KnowledgeArticleWhereUniqueInput
    /**
     * In case the KnowledgeArticle found by the `where` argument doesn't exist, create a new KnowledgeArticle with this data.
     */
    create: XOR<KnowledgeArticleCreateInput, KnowledgeArticleUncheckedCreateInput>
    /**
     * In case the KnowledgeArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<KnowledgeArticleUpdateInput, KnowledgeArticleUncheckedUpdateInput>
  }

  /**
   * KnowledgeArticle delete
   */
  export type KnowledgeArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
    /**
     * Filter which KnowledgeArticle to delete.
     */
    where: KnowledgeArticleWhereUniqueInput
  }

  /**
   * KnowledgeArticle deleteMany
   */
  export type KnowledgeArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which KnowledgeArticles to delete
     */
    where?: KnowledgeArticleWhereInput
    /**
     * Limit how many KnowledgeArticles to delete.
     */
    limit?: number
  }

  /**
   * KnowledgeArticle without action
   */
  export type KnowledgeArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the KnowledgeArticle
     */
    select?: KnowledgeArticleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the KnowledgeArticle
     */
    omit?: KnowledgeArticleOmit<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
    refundAmount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
    refundAmount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    propertyId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    method: $Enums.PaymentMethod | null
    transactionId: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    refundAmount: number | null
    refundReason: string | null
    refundedAt: Date | null
    payoutId: string | null
    payoutStatus: string | null
    payoutScheduledFor: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    propertyId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    method: $Enums.PaymentMethod | null
    transactionId: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    refundAmount: number | null
    refundReason: string | null
    refundedAt: Date | null
    payoutId: string | null
    payoutStatus: string | null
    payoutScheduledFor: Date | null
    processedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    propertyId: number
    amount: number
    currency: number
    status: number
    method: number
    transactionId: number
    stripePaymentIntentId: number
    stripeChargeId: number
    refundAmount: number
    refundReason: number
    refundedAt: number
    payoutId: number
    payoutStatus: number
    payoutScheduledFor: number
    processedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
    refundAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
    refundAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    propertyId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    transactionId?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    refundAmount?: true
    refundReason?: true
    refundedAt?: true
    payoutId?: true
    payoutStatus?: true
    payoutScheduledFor?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    propertyId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    transactionId?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    refundAmount?: true
    refundReason?: true
    refundedAt?: true
    payoutId?: true
    payoutStatus?: true
    payoutScheduledFor?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    propertyId?: true
    amount?: true
    currency?: true
    status?: true
    method?: true
    transactionId?: true
    stripePaymentIntentId?: true
    stripeChargeId?: true
    refundAmount?: true
    refundReason?: true
    refundedAt?: true
    payoutId?: true
    payoutStatus?: true
    payoutScheduledFor?: true
    processedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: string
    propertyId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId: string | null
    stripePaymentIntentId: string | null
    stripeChargeId: string | null
    refundAmount: number | null
    refundReason: string | null
    refundedAt: Date | null
    payoutId: string | null
    payoutStatus: string | null
    payoutScheduledFor: Date | null
    processedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    propertyId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundedAt?: boolean
    payoutId?: boolean
    payoutStatus?: boolean
    payoutScheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    propertyId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundedAt?: boolean
    payoutId?: boolean
    payoutStatus?: boolean
    payoutScheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    propertyId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundedAt?: boolean
    payoutId?: boolean
    payoutStatus?: boolean
    payoutScheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    propertyId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    method?: boolean
    transactionId?: boolean
    stripePaymentIntentId?: boolean
    stripeChargeId?: boolean
    refundAmount?: boolean
    refundReason?: boolean
    refundedAt?: boolean
    payoutId?: boolean
    payoutStatus?: boolean
    payoutScheduledFor?: boolean
    processedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "propertyId" | "amount" | "currency" | "status" | "method" | "transactionId" | "stripePaymentIntentId" | "stripeChargeId" | "refundAmount" | "refundReason" | "refundedAt" | "payoutId" | "payoutStatus" | "payoutScheduledFor" | "processedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      propertyId: string
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      method: $Enums.PaymentMethod
      transactionId: string | null
      stripePaymentIntentId: string | null
      stripeChargeId: string | null
      refundAmount: number | null
      refundReason: string | null
      refundedAt: Date | null
      payoutId: string | null
      payoutStatus: string | null
      payoutScheduledFor: Date | null
      processedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly propertyId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly method: FieldRef<"Payment", 'PaymentMethod'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly stripePaymentIntentId: FieldRef<"Payment", 'String'>
    readonly stripeChargeId: FieldRef<"Payment", 'String'>
    readonly refundAmount: FieldRef<"Payment", 'Float'>
    readonly refundReason: FieldRef<"Payment", 'String'>
    readonly refundedAt: FieldRef<"Payment", 'DateTime'>
    readonly payoutId: FieldRef<"Payment", 'String'>
    readonly payoutStatus: FieldRef<"Payment", 'String'>
    readonly payoutScheduledFor: FieldRef<"Payment", 'DateTime'>
    readonly processedAt: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    capacity: number | null
    maxAdults: number | null
    maxChildren: number | null
    maxInfants: number | null
    basePrice: number | null
  }

  export type RoomSumAggregateOutputType = {
    capacity: number | null
    maxAdults: number | null
    maxChildren: number | null
    maxInfants: number | null
    basePrice: number | null
  }

  export type RoomMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    nameGr: string | null
    nameEn: string | null
    type: $Enums.RoomType | null
    capacity: number | null
    maxAdults: number | null
    maxChildren: number | null
    maxInfants: number | null
    basePrice: number | null
    isBookable: boolean | null
    descriptionGr: string | null
    descriptionEn: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    nameGr: string | null
    nameEn: string | null
    type: $Enums.RoomType | null
    capacity: number | null
    maxAdults: number | null
    maxChildren: number | null
    maxInfants: number | null
    basePrice: number | null
    isBookable: boolean | null
    descriptionGr: string | null
    descriptionEn: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    propertyId: number
    name: number
    nameGr: number
    nameEn: number
    type: number
    capacity: number
    maxAdults: number
    maxChildren: number
    maxInfants: number
    basePrice: number
    isBookable: number
    amenities: number
    images: number
    descriptionGr: number
    descriptionEn: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    capacity?: true
    maxAdults?: true
    maxChildren?: true
    maxInfants?: true
    basePrice?: true
  }

  export type RoomSumAggregateInputType = {
    capacity?: true
    maxAdults?: true
    maxChildren?: true
    maxInfants?: true
    basePrice?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    nameGr?: true
    nameEn?: true
    type?: true
    capacity?: true
    maxAdults?: true
    maxChildren?: true
    maxInfants?: true
    basePrice?: true
    isBookable?: true
    descriptionGr?: true
    descriptionEn?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    nameGr?: true
    nameEn?: true
    type?: true
    capacity?: true
    maxAdults?: true
    maxChildren?: true
    maxInfants?: true
    basePrice?: true
    isBookable?: true
    descriptionGr?: true
    descriptionEn?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    nameGr?: true
    nameEn?: true
    type?: true
    capacity?: true
    maxAdults?: true
    maxChildren?: true
    maxInfants?: true
    basePrice?: true
    isBookable?: true
    amenities?: true
    images?: true
    descriptionGr?: true
    descriptionEn?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: string
    propertyId: string
    name: string
    nameGr: string | null
    nameEn: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults: number | null
    maxChildren: number | null
    maxInfants: number | null
    basePrice: number
    isBookable: boolean
    amenities: JsonValue | null
    images: JsonValue | null
    descriptionGr: string | null
    descriptionEn: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    type?: boolean
    capacity?: boolean
    maxAdults?: boolean
    maxChildren?: boolean
    maxInfants?: boolean
    basePrice?: boolean
    isBookable?: boolean
    amenities?: boolean
    images?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    roomContent?: boolean | Room$roomContentArgs<ExtArgs>
    availabilityRules?: boolean | Room$availabilityRulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    type?: boolean
    capacity?: boolean
    maxAdults?: boolean
    maxChildren?: boolean
    maxInfants?: boolean
    basePrice?: boolean
    isBookable?: boolean
    amenities?: boolean
    images?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    type?: boolean
    capacity?: boolean
    maxAdults?: boolean
    maxChildren?: boolean
    maxInfants?: boolean
    basePrice?: boolean
    isBookable?: boolean
    amenities?: boolean
    images?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    propertyId?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    type?: boolean
    capacity?: boolean
    maxAdults?: boolean
    maxChildren?: boolean
    maxInfants?: boolean
    basePrice?: boolean
    isBookable?: boolean
    amenities?: boolean
    images?: boolean
    descriptionGr?: boolean
    descriptionEn?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "name" | "nameGr" | "nameEn" | "type" | "capacity" | "maxAdults" | "maxChildren" | "maxInfants" | "basePrice" | "isBookable" | "amenities" | "images" | "descriptionGr" | "descriptionEn" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["room"]>
  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
    roomContent?: boolean | Room$roomContentArgs<ExtArgs>
    availabilityRules?: boolean | Room$availabilityRulesArgs<ExtArgs>
    _count?: boolean | RoomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
      roomContent: Prisma.$RoomContentPayload<ExtArgs> | null
      availabilityRules: Prisma.$RoomAvailabilityRulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      name: string
      nameGr: string | null
      nameEn: string | null
      type: $Enums.RoomType
      capacity: number
      maxAdults: number | null
      maxChildren: number | null
      maxInfants: number | null
      basePrice: number
      isBookable: boolean
      amenities: Prisma.JsonValue | null
      images: Prisma.JsonValue | null
      descriptionGr: string | null
      descriptionEn: string | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms and returns the data updated in the database.
     * @param {RoomUpdateManyAndReturnArgs} args - Arguments to update many Rooms.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roomContent<T extends Room$roomContentArgs<ExtArgs> = {}>(args?: Subset<T, Room$roomContentArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    availabilityRules<T extends Room$availabilityRulesArgs<ExtArgs> = {}>(args?: Subset<T, Room$availabilityRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'String'>
    readonly propertyId: FieldRef<"Room", 'String'>
    readonly name: FieldRef<"Room", 'String'>
    readonly nameGr: FieldRef<"Room", 'String'>
    readonly nameEn: FieldRef<"Room", 'String'>
    readonly type: FieldRef<"Room", 'RoomType'>
    readonly capacity: FieldRef<"Room", 'Int'>
    readonly maxAdults: FieldRef<"Room", 'Int'>
    readonly maxChildren: FieldRef<"Room", 'Int'>
    readonly maxInfants: FieldRef<"Room", 'Int'>
    readonly basePrice: FieldRef<"Room", 'Float'>
    readonly isBookable: FieldRef<"Room", 'Boolean'>
    readonly amenities: FieldRef<"Room", 'Json'>
    readonly images: FieldRef<"Room", 'Json'>
    readonly descriptionGr: FieldRef<"Room", 'String'>
    readonly descriptionEn: FieldRef<"Room", 'String'>
    readonly ownerId: FieldRef<"Room", 'String'>
    readonly createdAt: FieldRef<"Room", 'DateTime'>
    readonly updatedAt: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
  }

  /**
   * Room updateManyAndReturn
   */
  export type RoomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
    /**
     * Limit how many Rooms to delete.
     */
    limit?: number
  }

  /**
   * Room.roomContent
   */
  export type Room$roomContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    where?: RoomContentWhereInput
  }

  /**
   * Room.availabilityRules
   */
  export type Room$availabilityRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    where?: RoomAvailabilityRuleWhereInput
    orderBy?: RoomAvailabilityRuleOrderByWithRelationInput | RoomAvailabilityRuleOrderByWithRelationInput[]
    cursor?: RoomAvailabilityRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomAvailabilityRuleScalarFieldEnum | RoomAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Room
     */
    omit?: RoomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model PropertyGroup
   */

  export type AggregatePropertyGroup = {
    _count: PropertyGroupCountAggregateOutputType | null
    _min: PropertyGroupMinAggregateOutputType | null
    _max: PropertyGroupMaxAggregateOutputType | null
  }

  export type PropertyGroupMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameGr: string | null
    nameEn: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyGroupMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameGr: string | null
    nameEn: string | null
    description: string | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyGroupCountAggregateOutputType = {
    id: number
    name: number
    nameGr: number
    nameEn: number
    description: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyGroupMinAggregateInputType = {
    id?: true
    name?: true
    nameGr?: true
    nameEn?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyGroupMaxAggregateInputType = {
    id?: true
    name?: true
    nameGr?: true
    nameEn?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyGroupCountAggregateInputType = {
    id?: true
    name?: true
    nameGr?: true
    nameEn?: true
    description?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyGroupAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyGroup to aggregate.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyGroups
    **/
    _count?: true | PropertyGroupCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyGroupMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyGroupMaxAggregateInputType
  }

  export type GetPropertyGroupAggregateType<T extends PropertyGroupAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyGroup]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyGroup[P]>
      : GetScalarType<T[P], AggregatePropertyGroup[P]>
  }




  export type PropertyGroupGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyGroupWhereInput
    orderBy?: PropertyGroupOrderByWithAggregationInput | PropertyGroupOrderByWithAggregationInput[]
    by: PropertyGroupScalarFieldEnum[] | PropertyGroupScalarFieldEnum
    having?: PropertyGroupScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyGroupCountAggregateInputType | true
    _min?: PropertyGroupMinAggregateInputType
    _max?: PropertyGroupMaxAggregateInputType
  }

  export type PropertyGroupGroupByOutputType = {
    id: string
    name: string
    nameGr: string | null
    nameEn: string | null
    description: string | null
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: PropertyGroupCountAggregateOutputType | null
    _min: PropertyGroupMinAggregateOutputType | null
    _max: PropertyGroupMaxAggregateOutputType | null
  }

  type GetPropertyGroupGroupByPayload<T extends PropertyGroupGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyGroupGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyGroupGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyGroupGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyGroupGroupByOutputType[P]>
        }
      >
    >


  export type PropertyGroupSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | PropertyGroup$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyGroup"]>

  export type PropertyGroupSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyGroup"]>

  export type PropertyGroupSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyGroup"]>

  export type PropertyGroupSelectScalar = {
    id?: boolean
    name?: boolean
    nameGr?: boolean
    nameEn?: boolean
    description?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyGroupOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameGr" | "nameEn" | "description" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyGroup"]>
  export type PropertyGroupInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    properties?: boolean | PropertyGroup$propertiesArgs<ExtArgs>
    _count?: boolean | PropertyGroupCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PropertyGroupIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PropertyGroupIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PropertyGroupPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyGroup"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      properties: Prisma.$PropertyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      nameGr: string | null
      nameEn: string | null
      description: string | null
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyGroup"]>
    composites: {}
  }

  type PropertyGroupGetPayload<S extends boolean | null | undefined | PropertyGroupDefaultArgs> = $Result.GetResult<Prisma.$PropertyGroupPayload, S>

  type PropertyGroupCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyGroupFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyGroupCountAggregateInputType | true
    }

  export interface PropertyGroupDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyGroup'], meta: { name: 'PropertyGroup' } }
    /**
     * Find zero or one PropertyGroup that matches the filter.
     * @param {PropertyGroupFindUniqueArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyGroupFindUniqueArgs>(args: SelectSubset<T, PropertyGroupFindUniqueArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyGroup that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyGroupFindUniqueOrThrowArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyGroupFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyGroupFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyGroup that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupFindFirstArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyGroupFindFirstArgs>(args?: SelectSubset<T, PropertyGroupFindFirstArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyGroup that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupFindFirstOrThrowArgs} args - Arguments to find a PropertyGroup
     * @example
     * // Get one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyGroupFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyGroupFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyGroups that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyGroups
     * const propertyGroups = await prisma.propertyGroup.findMany()
     * 
     * // Get first 10 PropertyGroups
     * const propertyGroups = await prisma.propertyGroup.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyGroupWithIdOnly = await prisma.propertyGroup.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyGroupFindManyArgs>(args?: SelectSubset<T, PropertyGroupFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyGroup.
     * @param {PropertyGroupCreateArgs} args - Arguments to create a PropertyGroup.
     * @example
     * // Create one PropertyGroup
     * const PropertyGroup = await prisma.propertyGroup.create({
     *   data: {
     *     // ... data to create a PropertyGroup
     *   }
     * })
     * 
     */
    create<T extends PropertyGroupCreateArgs>(args: SelectSubset<T, PropertyGroupCreateArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyGroups.
     * @param {PropertyGroupCreateManyArgs} args - Arguments to create many PropertyGroups.
     * @example
     * // Create many PropertyGroups
     * const propertyGroup = await prisma.propertyGroup.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyGroupCreateManyArgs>(args?: SelectSubset<T, PropertyGroupCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyGroups and returns the data saved in the database.
     * @param {PropertyGroupCreateManyAndReturnArgs} args - Arguments to create many PropertyGroups.
     * @example
     * // Create many PropertyGroups
     * const propertyGroup = await prisma.propertyGroup.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyGroups and only return the `id`
     * const propertyGroupWithIdOnly = await prisma.propertyGroup.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyGroupCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyGroupCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyGroup.
     * @param {PropertyGroupDeleteArgs} args - Arguments to delete one PropertyGroup.
     * @example
     * // Delete one PropertyGroup
     * const PropertyGroup = await prisma.propertyGroup.delete({
     *   where: {
     *     // ... filter to delete one PropertyGroup
     *   }
     * })
     * 
     */
    delete<T extends PropertyGroupDeleteArgs>(args: SelectSubset<T, PropertyGroupDeleteArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyGroup.
     * @param {PropertyGroupUpdateArgs} args - Arguments to update one PropertyGroup.
     * @example
     * // Update one PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyGroupUpdateArgs>(args: SelectSubset<T, PropertyGroupUpdateArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyGroups.
     * @param {PropertyGroupDeleteManyArgs} args - Arguments to filter PropertyGroups to delete.
     * @example
     * // Delete a few PropertyGroups
     * const { count } = await prisma.propertyGroup.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyGroupDeleteManyArgs>(args?: SelectSubset<T, PropertyGroupDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyGroups
     * const propertyGroup = await prisma.propertyGroup.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyGroupUpdateManyArgs>(args: SelectSubset<T, PropertyGroupUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyGroups and returns the data updated in the database.
     * @param {PropertyGroupUpdateManyAndReturnArgs} args - Arguments to update many PropertyGroups.
     * @example
     * // Update many PropertyGroups
     * const propertyGroup = await prisma.propertyGroup.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyGroups and only return the `id`
     * const propertyGroupWithIdOnly = await prisma.propertyGroup.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyGroupUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyGroupUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyGroup.
     * @param {PropertyGroupUpsertArgs} args - Arguments to update or create a PropertyGroup.
     * @example
     * // Update or create a PropertyGroup
     * const propertyGroup = await prisma.propertyGroup.upsert({
     *   create: {
     *     // ... data to create a PropertyGroup
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyGroup we want to update
     *   }
     * })
     */
    upsert<T extends PropertyGroupUpsertArgs>(args: SelectSubset<T, PropertyGroupUpsertArgs<ExtArgs>>): Prisma__PropertyGroupClient<$Result.GetResult<Prisma.$PropertyGroupPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyGroups.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupCountArgs} args - Arguments to filter PropertyGroups to count.
     * @example
     * // Count the number of PropertyGroups
     * const count = await prisma.propertyGroup.count({
     *   where: {
     *     // ... the filter for the PropertyGroups we want to count
     *   }
     * })
    **/
    count<T extends PropertyGroupCountArgs>(
      args?: Subset<T, PropertyGroupCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyGroupCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyGroupAggregateArgs>(args: Subset<T, PropertyGroupAggregateArgs>): Prisma.PrismaPromise<GetPropertyGroupAggregateType<T>>

    /**
     * Group by PropertyGroup.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyGroupGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyGroupGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyGroupGroupByArgs['orderBy'] }
        : { orderBy?: PropertyGroupGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyGroupGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyGroupGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyGroup model
   */
  readonly fields: PropertyGroupFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyGroup.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyGroupClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    properties<T extends PropertyGroup$propertiesArgs<ExtArgs> = {}>(args?: Subset<T, PropertyGroup$propertiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyGroup model
   */
  interface PropertyGroupFieldRefs {
    readonly id: FieldRef<"PropertyGroup", 'String'>
    readonly name: FieldRef<"PropertyGroup", 'String'>
    readonly nameGr: FieldRef<"PropertyGroup", 'String'>
    readonly nameEn: FieldRef<"PropertyGroup", 'String'>
    readonly description: FieldRef<"PropertyGroup", 'String'>
    readonly ownerId: FieldRef<"PropertyGroup", 'String'>
    readonly createdAt: FieldRef<"PropertyGroup", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyGroup", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyGroup findUnique
   */
  export type PropertyGroupFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where: PropertyGroupWhereUniqueInput
  }

  /**
   * PropertyGroup findUniqueOrThrow
   */
  export type PropertyGroupFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where: PropertyGroupWhereUniqueInput
  }

  /**
   * PropertyGroup findFirst
   */
  export type PropertyGroupFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyGroups.
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyGroups.
     */
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }

  /**
   * PropertyGroup findFirstOrThrow
   */
  export type PropertyGroupFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroup to fetch.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyGroups.
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyGroups.
     */
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }

  /**
   * PropertyGroup findMany
   */
  export type PropertyGroupFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter, which PropertyGroups to fetch.
     */
    where?: PropertyGroupWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyGroups to fetch.
     */
    orderBy?: PropertyGroupOrderByWithRelationInput | PropertyGroupOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyGroups.
     */
    cursor?: PropertyGroupWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyGroups from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyGroups.
     */
    skip?: number
    distinct?: PropertyGroupScalarFieldEnum | PropertyGroupScalarFieldEnum[]
  }

  /**
   * PropertyGroup create
   */
  export type PropertyGroupCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyGroup.
     */
    data: XOR<PropertyGroupCreateInput, PropertyGroupUncheckedCreateInput>
  }

  /**
   * PropertyGroup createMany
   */
  export type PropertyGroupCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyGroups.
     */
    data: PropertyGroupCreateManyInput | PropertyGroupCreateManyInput[]
  }

  /**
   * PropertyGroup createManyAndReturn
   */
  export type PropertyGroupCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyGroups.
     */
    data: PropertyGroupCreateManyInput | PropertyGroupCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyGroup update
   */
  export type PropertyGroupUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyGroup.
     */
    data: XOR<PropertyGroupUpdateInput, PropertyGroupUncheckedUpdateInput>
    /**
     * Choose, which PropertyGroup to update.
     */
    where: PropertyGroupWhereUniqueInput
  }

  /**
   * PropertyGroup updateMany
   */
  export type PropertyGroupUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyGroups.
     */
    data: XOR<PropertyGroupUpdateManyMutationInput, PropertyGroupUncheckedUpdateManyInput>
    /**
     * Filter which PropertyGroups to update
     */
    where?: PropertyGroupWhereInput
    /**
     * Limit how many PropertyGroups to update.
     */
    limit?: number
  }

  /**
   * PropertyGroup updateManyAndReturn
   */
  export type PropertyGroupUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * The data used to update PropertyGroups.
     */
    data: XOR<PropertyGroupUpdateManyMutationInput, PropertyGroupUncheckedUpdateManyInput>
    /**
     * Filter which PropertyGroups to update
     */
    where?: PropertyGroupWhereInput
    /**
     * Limit how many PropertyGroups to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyGroup upsert
   */
  export type PropertyGroupUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyGroup to update in case it exists.
     */
    where: PropertyGroupWhereUniqueInput
    /**
     * In case the PropertyGroup found by the `where` argument doesn't exist, create a new PropertyGroup with this data.
     */
    create: XOR<PropertyGroupCreateInput, PropertyGroupUncheckedCreateInput>
    /**
     * In case the PropertyGroup was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyGroupUpdateInput, PropertyGroupUncheckedUpdateInput>
  }

  /**
   * PropertyGroup delete
   */
  export type PropertyGroupDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
    /**
     * Filter which PropertyGroup to delete.
     */
    where: PropertyGroupWhereUniqueInput
  }

  /**
   * PropertyGroup deleteMany
   */
  export type PropertyGroupDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyGroups to delete
     */
    where?: PropertyGroupWhereInput
    /**
     * Limit how many PropertyGroups to delete.
     */
    limit?: number
  }

  /**
   * PropertyGroup.properties
   */
  export type PropertyGroup$propertiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Property
     */
    select?: PropertySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Property
     */
    omit?: PropertyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyInclude<ExtArgs> | null
    where?: PropertyWhereInput
    orderBy?: PropertyOrderByWithRelationInput | PropertyOrderByWithRelationInput[]
    cursor?: PropertyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PropertyScalarFieldEnum | PropertyScalarFieldEnum[]
  }

  /**
   * PropertyGroup without action
   */
  export type PropertyGroupDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyGroup
     */
    select?: PropertyGroupSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyGroup
     */
    omit?: PropertyGroupOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyGroupInclude<ExtArgs> | null
  }


  /**
   * Model CleaningSchedule
   */

  export type AggregateCleaningSchedule = {
    _count: CleaningScheduleCountAggregateOutputType | null
    _min: CleaningScheduleMinAggregateOutputType | null
    _max: CleaningScheduleMaxAggregateOutputType | null
  }

  export type CleaningScheduleMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    frequency: $Enums.CleaningFrequency | null
    lastCleaned: Date | null
    nextCleaning: Date | null
    assignedCleaner: string | null
    ownerId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningScheduleMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    frequency: $Enums.CleaningFrequency | null
    lastCleaned: Date | null
    nextCleaning: Date | null
    assignedCleaner: string | null
    ownerId: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CleaningScheduleCountAggregateOutputType = {
    id: number
    propertyId: number
    frequency: number
    lastCleaned: number
    nextCleaning: number
    assignedCleaner: number
    ownerId: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CleaningScheduleMinAggregateInputType = {
    id?: true
    propertyId?: true
    frequency?: true
    lastCleaned?: true
    nextCleaning?: true
    assignedCleaner?: true
    ownerId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningScheduleMaxAggregateInputType = {
    id?: true
    propertyId?: true
    frequency?: true
    lastCleaned?: true
    nextCleaning?: true
    assignedCleaner?: true
    ownerId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CleaningScheduleCountAggregateInputType = {
    id?: true
    propertyId?: true
    frequency?: true
    lastCleaned?: true
    nextCleaning?: true
    assignedCleaner?: true
    ownerId?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CleaningScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSchedule to aggregate.
     */
    where?: CleaningScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSchedules to fetch.
     */
    orderBy?: CleaningScheduleOrderByWithRelationInput | CleaningScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CleaningScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CleaningSchedules
    **/
    _count?: true | CleaningScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CleaningScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CleaningScheduleMaxAggregateInputType
  }

  export type GetCleaningScheduleAggregateType<T extends CleaningScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateCleaningSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCleaningSchedule[P]>
      : GetScalarType<T[P], AggregateCleaningSchedule[P]>
  }




  export type CleaningScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CleaningScheduleWhereInput
    orderBy?: CleaningScheduleOrderByWithAggregationInput | CleaningScheduleOrderByWithAggregationInput[]
    by: CleaningScheduleScalarFieldEnum[] | CleaningScheduleScalarFieldEnum
    having?: CleaningScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CleaningScheduleCountAggregateInputType | true
    _min?: CleaningScheduleMinAggregateInputType
    _max?: CleaningScheduleMaxAggregateInputType
  }

  export type CleaningScheduleGroupByOutputType = {
    id: string
    propertyId: string
    frequency: $Enums.CleaningFrequency
    lastCleaned: Date | null
    nextCleaning: Date | null
    assignedCleaner: string | null
    ownerId: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: CleaningScheduleCountAggregateOutputType | null
    _min: CleaningScheduleMinAggregateOutputType | null
    _max: CleaningScheduleMaxAggregateOutputType | null
  }

  type GetCleaningScheduleGroupByPayload<T extends CleaningScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CleaningScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CleaningScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CleaningScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], CleaningScheduleGroupByOutputType[P]>
        }
      >
    >


  export type CleaningScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    frequency?: boolean
    lastCleaned?: boolean
    nextCleaning?: boolean
    assignedCleaner?: boolean
    ownerId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSchedule"]>

  export type CleaningScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    frequency?: boolean
    lastCleaned?: boolean
    nextCleaning?: boolean
    assignedCleaner?: boolean
    ownerId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSchedule"]>

  export type CleaningScheduleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    frequency?: boolean
    lastCleaned?: boolean
    nextCleaning?: boolean
    assignedCleaner?: boolean
    ownerId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cleaningSchedule"]>

  export type CleaningScheduleSelectScalar = {
    id?: boolean
    propertyId?: boolean
    frequency?: boolean
    lastCleaned?: boolean
    nextCleaning?: boolean
    assignedCleaner?: boolean
    ownerId?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CleaningScheduleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "frequency" | "lastCleaned" | "nextCleaning" | "assignedCleaner" | "ownerId" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["cleaningSchedule"]>
  export type CleaningScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CleaningScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CleaningScheduleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CleaningSchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CleaningSchedule"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      owner: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      frequency: $Enums.CleaningFrequency
      lastCleaned: Date | null
      nextCleaning: Date | null
      assignedCleaner: string | null
      ownerId: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cleaningSchedule"]>
    composites: {}
  }

  type CleaningScheduleGetPayload<S extends boolean | null | undefined | CleaningScheduleDefaultArgs> = $Result.GetResult<Prisma.$CleaningSchedulePayload, S>

  type CleaningScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CleaningScheduleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CleaningScheduleCountAggregateInputType | true
    }

  export interface CleaningScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CleaningSchedule'], meta: { name: 'CleaningSchedule' } }
    /**
     * Find zero or one CleaningSchedule that matches the filter.
     * @param {CleaningScheduleFindUniqueArgs} args - Arguments to find a CleaningSchedule
     * @example
     * // Get one CleaningSchedule
     * const cleaningSchedule = await prisma.cleaningSchedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CleaningScheduleFindUniqueArgs>(args: SelectSubset<T, CleaningScheduleFindUniqueArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CleaningSchedule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CleaningScheduleFindUniqueOrThrowArgs} args - Arguments to find a CleaningSchedule
     * @example
     * // Get one CleaningSchedule
     * const cleaningSchedule = await prisma.cleaningSchedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CleaningScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, CleaningScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSchedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleFindFirstArgs} args - Arguments to find a CleaningSchedule
     * @example
     * // Get one CleaningSchedule
     * const cleaningSchedule = await prisma.cleaningSchedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CleaningScheduleFindFirstArgs>(args?: SelectSubset<T, CleaningScheduleFindFirstArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CleaningSchedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleFindFirstOrThrowArgs} args - Arguments to find a CleaningSchedule
     * @example
     * // Get one CleaningSchedule
     * const cleaningSchedule = await prisma.cleaningSchedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CleaningScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, CleaningScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CleaningSchedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CleaningSchedules
     * const cleaningSchedules = await prisma.cleaningSchedule.findMany()
     * 
     * // Get first 10 CleaningSchedules
     * const cleaningSchedules = await prisma.cleaningSchedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cleaningScheduleWithIdOnly = await prisma.cleaningSchedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CleaningScheduleFindManyArgs>(args?: SelectSubset<T, CleaningScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CleaningSchedule.
     * @param {CleaningScheduleCreateArgs} args - Arguments to create a CleaningSchedule.
     * @example
     * // Create one CleaningSchedule
     * const CleaningSchedule = await prisma.cleaningSchedule.create({
     *   data: {
     *     // ... data to create a CleaningSchedule
     *   }
     * })
     * 
     */
    create<T extends CleaningScheduleCreateArgs>(args: SelectSubset<T, CleaningScheduleCreateArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CleaningSchedules.
     * @param {CleaningScheduleCreateManyArgs} args - Arguments to create many CleaningSchedules.
     * @example
     * // Create many CleaningSchedules
     * const cleaningSchedule = await prisma.cleaningSchedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CleaningScheduleCreateManyArgs>(args?: SelectSubset<T, CleaningScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CleaningSchedules and returns the data saved in the database.
     * @param {CleaningScheduleCreateManyAndReturnArgs} args - Arguments to create many CleaningSchedules.
     * @example
     * // Create many CleaningSchedules
     * const cleaningSchedule = await prisma.cleaningSchedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CleaningSchedules and only return the `id`
     * const cleaningScheduleWithIdOnly = await prisma.cleaningSchedule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CleaningScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, CleaningScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CleaningSchedule.
     * @param {CleaningScheduleDeleteArgs} args - Arguments to delete one CleaningSchedule.
     * @example
     * // Delete one CleaningSchedule
     * const CleaningSchedule = await prisma.cleaningSchedule.delete({
     *   where: {
     *     // ... filter to delete one CleaningSchedule
     *   }
     * })
     * 
     */
    delete<T extends CleaningScheduleDeleteArgs>(args: SelectSubset<T, CleaningScheduleDeleteArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CleaningSchedule.
     * @param {CleaningScheduleUpdateArgs} args - Arguments to update one CleaningSchedule.
     * @example
     * // Update one CleaningSchedule
     * const cleaningSchedule = await prisma.cleaningSchedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CleaningScheduleUpdateArgs>(args: SelectSubset<T, CleaningScheduleUpdateArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CleaningSchedules.
     * @param {CleaningScheduleDeleteManyArgs} args - Arguments to filter CleaningSchedules to delete.
     * @example
     * // Delete a few CleaningSchedules
     * const { count } = await prisma.cleaningSchedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CleaningScheduleDeleteManyArgs>(args?: SelectSubset<T, CleaningScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CleaningSchedules
     * const cleaningSchedule = await prisma.cleaningSchedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CleaningScheduleUpdateManyArgs>(args: SelectSubset<T, CleaningScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CleaningSchedules and returns the data updated in the database.
     * @param {CleaningScheduleUpdateManyAndReturnArgs} args - Arguments to update many CleaningSchedules.
     * @example
     * // Update many CleaningSchedules
     * const cleaningSchedule = await prisma.cleaningSchedule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CleaningSchedules and only return the `id`
     * const cleaningScheduleWithIdOnly = await prisma.cleaningSchedule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CleaningScheduleUpdateManyAndReturnArgs>(args: SelectSubset<T, CleaningScheduleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CleaningSchedule.
     * @param {CleaningScheduleUpsertArgs} args - Arguments to update or create a CleaningSchedule.
     * @example
     * // Update or create a CleaningSchedule
     * const cleaningSchedule = await prisma.cleaningSchedule.upsert({
     *   create: {
     *     // ... data to create a CleaningSchedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CleaningSchedule we want to update
     *   }
     * })
     */
    upsert<T extends CleaningScheduleUpsertArgs>(args: SelectSubset<T, CleaningScheduleUpsertArgs<ExtArgs>>): Prisma__CleaningScheduleClient<$Result.GetResult<Prisma.$CleaningSchedulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CleaningSchedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleCountArgs} args - Arguments to filter CleaningSchedules to count.
     * @example
     * // Count the number of CleaningSchedules
     * const count = await prisma.cleaningSchedule.count({
     *   where: {
     *     // ... the filter for the CleaningSchedules we want to count
     *   }
     * })
    **/
    count<T extends CleaningScheduleCountArgs>(
      args?: Subset<T, CleaningScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CleaningScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CleaningSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CleaningScheduleAggregateArgs>(args: Subset<T, CleaningScheduleAggregateArgs>): Prisma.PrismaPromise<GetCleaningScheduleAggregateType<T>>

    /**
     * Group by CleaningSchedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CleaningScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CleaningScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CleaningScheduleGroupByArgs['orderBy'] }
        : { orderBy?: CleaningScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CleaningScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCleaningScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CleaningSchedule model
   */
  readonly fields: CleaningScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CleaningSchedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CleaningScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CleaningSchedule model
   */
  interface CleaningScheduleFieldRefs {
    readonly id: FieldRef<"CleaningSchedule", 'String'>
    readonly propertyId: FieldRef<"CleaningSchedule", 'String'>
    readonly frequency: FieldRef<"CleaningSchedule", 'CleaningFrequency'>
    readonly lastCleaned: FieldRef<"CleaningSchedule", 'DateTime'>
    readonly nextCleaning: FieldRef<"CleaningSchedule", 'DateTime'>
    readonly assignedCleaner: FieldRef<"CleaningSchedule", 'String'>
    readonly ownerId: FieldRef<"CleaningSchedule", 'String'>
    readonly notes: FieldRef<"CleaningSchedule", 'String'>
    readonly createdAt: FieldRef<"CleaningSchedule", 'DateTime'>
    readonly updatedAt: FieldRef<"CleaningSchedule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CleaningSchedule findUnique
   */
  export type CleaningScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSchedule to fetch.
     */
    where: CleaningScheduleWhereUniqueInput
  }

  /**
   * CleaningSchedule findUniqueOrThrow
   */
  export type CleaningScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSchedule to fetch.
     */
    where: CleaningScheduleWhereUniqueInput
  }

  /**
   * CleaningSchedule findFirst
   */
  export type CleaningScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSchedule to fetch.
     */
    where?: CleaningScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSchedules to fetch.
     */
    orderBy?: CleaningScheduleOrderByWithRelationInput | CleaningScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSchedules.
     */
    cursor?: CleaningScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSchedules.
     */
    distinct?: CleaningScheduleScalarFieldEnum | CleaningScheduleScalarFieldEnum[]
  }

  /**
   * CleaningSchedule findFirstOrThrow
   */
  export type CleaningScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSchedule to fetch.
     */
    where?: CleaningScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSchedules to fetch.
     */
    orderBy?: CleaningScheduleOrderByWithRelationInput | CleaningScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CleaningSchedules.
     */
    cursor?: CleaningScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSchedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CleaningSchedules.
     */
    distinct?: CleaningScheduleScalarFieldEnum | CleaningScheduleScalarFieldEnum[]
  }

  /**
   * CleaningSchedule findMany
   */
  export type CleaningScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * Filter, which CleaningSchedules to fetch.
     */
    where?: CleaningScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CleaningSchedules to fetch.
     */
    orderBy?: CleaningScheduleOrderByWithRelationInput | CleaningScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CleaningSchedules.
     */
    cursor?: CleaningScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CleaningSchedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CleaningSchedules.
     */
    skip?: number
    distinct?: CleaningScheduleScalarFieldEnum | CleaningScheduleScalarFieldEnum[]
  }

  /**
   * CleaningSchedule create
   */
  export type CleaningScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a CleaningSchedule.
     */
    data: XOR<CleaningScheduleCreateInput, CleaningScheduleUncheckedCreateInput>
  }

  /**
   * CleaningSchedule createMany
   */
  export type CleaningScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CleaningSchedules.
     */
    data: CleaningScheduleCreateManyInput | CleaningScheduleCreateManyInput[]
  }

  /**
   * CleaningSchedule createManyAndReturn
   */
  export type CleaningScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * The data used to create many CleaningSchedules.
     */
    data: CleaningScheduleCreateManyInput | CleaningScheduleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSchedule update
   */
  export type CleaningScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a CleaningSchedule.
     */
    data: XOR<CleaningScheduleUpdateInput, CleaningScheduleUncheckedUpdateInput>
    /**
     * Choose, which CleaningSchedule to update.
     */
    where: CleaningScheduleWhereUniqueInput
  }

  /**
   * CleaningSchedule updateMany
   */
  export type CleaningScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CleaningSchedules.
     */
    data: XOR<CleaningScheduleUpdateManyMutationInput, CleaningScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSchedules to update
     */
    where?: CleaningScheduleWhereInput
    /**
     * Limit how many CleaningSchedules to update.
     */
    limit?: number
  }

  /**
   * CleaningSchedule updateManyAndReturn
   */
  export type CleaningScheduleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * The data used to update CleaningSchedules.
     */
    data: XOR<CleaningScheduleUpdateManyMutationInput, CleaningScheduleUncheckedUpdateManyInput>
    /**
     * Filter which CleaningSchedules to update
     */
    where?: CleaningScheduleWhereInput
    /**
     * Limit how many CleaningSchedules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CleaningSchedule upsert
   */
  export type CleaningScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the CleaningSchedule to update in case it exists.
     */
    where: CleaningScheduleWhereUniqueInput
    /**
     * In case the CleaningSchedule found by the `where` argument doesn't exist, create a new CleaningSchedule with this data.
     */
    create: XOR<CleaningScheduleCreateInput, CleaningScheduleUncheckedCreateInput>
    /**
     * In case the CleaningSchedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CleaningScheduleUpdateInput, CleaningScheduleUncheckedUpdateInput>
  }

  /**
   * CleaningSchedule delete
   */
  export type CleaningScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
    /**
     * Filter which CleaningSchedule to delete.
     */
    where: CleaningScheduleWhereUniqueInput
  }

  /**
   * CleaningSchedule deleteMany
   */
  export type CleaningScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CleaningSchedules to delete
     */
    where?: CleaningScheduleWhereInput
    /**
     * Limit how many CleaningSchedules to delete.
     */
    limit?: number
  }

  /**
   * CleaningSchedule without action
   */
  export type CleaningScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CleaningSchedule
     */
    select?: CleaningScheduleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CleaningSchedule
     */
    omit?: CleaningScheduleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CleaningScheduleInclude<ExtArgs> | null
  }


  /**
   * Model PropertyAnalytics
   */

  export type AggregatePropertyAnalytics = {
    _count: PropertyAnalyticsCountAggregateOutputType | null
    _avg: PropertyAnalyticsAvgAggregateOutputType | null
    _sum: PropertyAnalyticsSumAggregateOutputType | null
    _min: PropertyAnalyticsMinAggregateOutputType | null
    _max: PropertyAnalyticsMaxAggregateOutputType | null
  }

  export type PropertyAnalyticsAvgAggregateOutputType = {
    totalRevenue: number | null
    totalCosts: number | null
    cleaningCosts: number | null
    maintenanceCosts: number | null
    platformFees: number | null
    netProfit: number | null
    profitMargin: number | null
    totalBookings: number | null
    cancelledBookings: number | null
    occupancyRate: number | null
    averageDailyRate: number | null
    revenuePerAvailableRoom: number | null
    averageRating: number | null
    averageCleanlinessRating: number | null
    totalReviews: number | null
  }

  export type PropertyAnalyticsSumAggregateOutputType = {
    totalRevenue: number | null
    totalCosts: number | null
    cleaningCosts: number | null
    maintenanceCosts: number | null
    platformFees: number | null
    netProfit: number | null
    profitMargin: number | null
    totalBookings: number | null
    cancelledBookings: number | null
    occupancyRate: number | null
    averageDailyRate: number | null
    revenuePerAvailableRoom: number | null
    averageRating: number | null
    averageCleanlinessRating: number | null
    totalReviews: number | null
  }

  export type PropertyAnalyticsMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    period: $Enums.AnalyticsPeriod | null
    periodStart: Date | null
    periodEnd: Date | null
    totalRevenue: number | null
    totalCosts: number | null
    cleaningCosts: number | null
    maintenanceCosts: number | null
    platformFees: number | null
    netProfit: number | null
    profitMargin: number | null
    totalBookings: number | null
    cancelledBookings: number | null
    occupancyRate: number | null
    averageDailyRate: number | null
    revenuePerAvailableRoom: number | null
    averageRating: number | null
    averageCleanlinessRating: number | null
    totalReviews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyAnalyticsMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    period: $Enums.AnalyticsPeriod | null
    periodStart: Date | null
    periodEnd: Date | null
    totalRevenue: number | null
    totalCosts: number | null
    cleaningCosts: number | null
    maintenanceCosts: number | null
    platformFees: number | null
    netProfit: number | null
    profitMargin: number | null
    totalBookings: number | null
    cancelledBookings: number | null
    occupancyRate: number | null
    averageDailyRate: number | null
    revenuePerAvailableRoom: number | null
    averageRating: number | null
    averageCleanlinessRating: number | null
    totalReviews: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyAnalyticsCountAggregateOutputType = {
    id: number
    propertyId: number
    period: number
    periodStart: number
    periodEnd: number
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom: number
    averageRating: number
    averageCleanlinessRating: number
    totalReviews: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyAnalyticsAvgAggregateInputType = {
    totalRevenue?: true
    totalCosts?: true
    cleaningCosts?: true
    maintenanceCosts?: true
    platformFees?: true
    netProfit?: true
    profitMargin?: true
    totalBookings?: true
    cancelledBookings?: true
    occupancyRate?: true
    averageDailyRate?: true
    revenuePerAvailableRoom?: true
    averageRating?: true
    averageCleanlinessRating?: true
    totalReviews?: true
  }

  export type PropertyAnalyticsSumAggregateInputType = {
    totalRevenue?: true
    totalCosts?: true
    cleaningCosts?: true
    maintenanceCosts?: true
    platformFees?: true
    netProfit?: true
    profitMargin?: true
    totalBookings?: true
    cancelledBookings?: true
    occupancyRate?: true
    averageDailyRate?: true
    revenuePerAvailableRoom?: true
    averageRating?: true
    averageCleanlinessRating?: true
    totalReviews?: true
  }

  export type PropertyAnalyticsMinAggregateInputType = {
    id?: true
    propertyId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalRevenue?: true
    totalCosts?: true
    cleaningCosts?: true
    maintenanceCosts?: true
    platformFees?: true
    netProfit?: true
    profitMargin?: true
    totalBookings?: true
    cancelledBookings?: true
    occupancyRate?: true
    averageDailyRate?: true
    revenuePerAvailableRoom?: true
    averageRating?: true
    averageCleanlinessRating?: true
    totalReviews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyAnalyticsMaxAggregateInputType = {
    id?: true
    propertyId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalRevenue?: true
    totalCosts?: true
    cleaningCosts?: true
    maintenanceCosts?: true
    platformFees?: true
    netProfit?: true
    profitMargin?: true
    totalBookings?: true
    cancelledBookings?: true
    occupancyRate?: true
    averageDailyRate?: true
    revenuePerAvailableRoom?: true
    averageRating?: true
    averageCleanlinessRating?: true
    totalReviews?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyAnalyticsCountAggregateInputType = {
    id?: true
    propertyId?: true
    period?: true
    periodStart?: true
    periodEnd?: true
    totalRevenue?: true
    totalCosts?: true
    cleaningCosts?: true
    maintenanceCosts?: true
    platformFees?: true
    netProfit?: true
    profitMargin?: true
    totalBookings?: true
    cancelledBookings?: true
    occupancyRate?: true
    averageDailyRate?: true
    revenuePerAvailableRoom?: true
    averageRating?: true
    averageCleanlinessRating?: true
    totalReviews?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyAnalyticsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAnalytics to aggregate.
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAnalytics to fetch.
     */
    orderBy?: PropertyAnalyticsOrderByWithRelationInput | PropertyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyAnalytics
    **/
    _count?: true | PropertyAnalyticsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PropertyAnalyticsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PropertyAnalyticsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyAnalyticsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyAnalyticsMaxAggregateInputType
  }

  export type GetPropertyAnalyticsAggregateType<T extends PropertyAnalyticsAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyAnalytics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyAnalytics[P]>
      : GetScalarType<T[P], AggregatePropertyAnalytics[P]>
  }




  export type PropertyAnalyticsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyAnalyticsWhereInput
    orderBy?: PropertyAnalyticsOrderByWithAggregationInput | PropertyAnalyticsOrderByWithAggregationInput[]
    by: PropertyAnalyticsScalarFieldEnum[] | PropertyAnalyticsScalarFieldEnum
    having?: PropertyAnalyticsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyAnalyticsCountAggregateInputType | true
    _avg?: PropertyAnalyticsAvgAggregateInputType
    _sum?: PropertyAnalyticsSumAggregateInputType
    _min?: PropertyAnalyticsMinAggregateInputType
    _max?: PropertyAnalyticsMaxAggregateInputType
  }

  export type PropertyAnalyticsGroupByOutputType = {
    id: string
    propertyId: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date
    periodEnd: Date
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom: number | null
    averageRating: number | null
    averageCleanlinessRating: number | null
    totalReviews: number
    createdAt: Date
    updatedAt: Date
    _count: PropertyAnalyticsCountAggregateOutputType | null
    _avg: PropertyAnalyticsAvgAggregateOutputType | null
    _sum: PropertyAnalyticsSumAggregateOutputType | null
    _min: PropertyAnalyticsMinAggregateOutputType | null
    _max: PropertyAnalyticsMaxAggregateOutputType | null
  }

  type GetPropertyAnalyticsGroupByPayload<T extends PropertyAnalyticsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyAnalyticsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyAnalyticsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyAnalyticsGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyAnalyticsGroupByOutputType[P]>
        }
      >
    >


  export type PropertyAnalyticsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalRevenue?: boolean
    totalCosts?: boolean
    cleaningCosts?: boolean
    maintenanceCosts?: boolean
    platformFees?: boolean
    netProfit?: boolean
    profitMargin?: boolean
    totalBookings?: boolean
    cancelledBookings?: boolean
    occupancyRate?: boolean
    averageDailyRate?: boolean
    revenuePerAvailableRoom?: boolean
    averageRating?: boolean
    averageCleanlinessRating?: boolean
    totalReviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAnalytics"]>

  export type PropertyAnalyticsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalRevenue?: boolean
    totalCosts?: boolean
    cleaningCosts?: boolean
    maintenanceCosts?: boolean
    platformFees?: boolean
    netProfit?: boolean
    profitMargin?: boolean
    totalBookings?: boolean
    cancelledBookings?: boolean
    occupancyRate?: boolean
    averageDailyRate?: boolean
    revenuePerAvailableRoom?: boolean
    averageRating?: boolean
    averageCleanlinessRating?: boolean
    totalReviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAnalytics"]>

  export type PropertyAnalyticsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalRevenue?: boolean
    totalCosts?: boolean
    cleaningCosts?: boolean
    maintenanceCosts?: boolean
    platformFees?: boolean
    netProfit?: boolean
    profitMargin?: boolean
    totalBookings?: boolean
    cancelledBookings?: boolean
    occupancyRate?: boolean
    averageDailyRate?: boolean
    revenuePerAvailableRoom?: boolean
    averageRating?: boolean
    averageCleanlinessRating?: boolean
    totalReviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyAnalytics"]>

  export type PropertyAnalyticsSelectScalar = {
    id?: boolean
    propertyId?: boolean
    period?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    totalRevenue?: boolean
    totalCosts?: boolean
    cleaningCosts?: boolean
    maintenanceCosts?: boolean
    platformFees?: boolean
    netProfit?: boolean
    profitMargin?: boolean
    totalBookings?: boolean
    cancelledBookings?: boolean
    occupancyRate?: boolean
    averageDailyRate?: boolean
    revenuePerAvailableRoom?: boolean
    averageRating?: boolean
    averageCleanlinessRating?: boolean
    totalReviews?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyAnalyticsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "period" | "periodStart" | "periodEnd" | "totalRevenue" | "totalCosts" | "cleaningCosts" | "maintenanceCosts" | "platformFees" | "netProfit" | "profitMargin" | "totalBookings" | "cancelledBookings" | "occupancyRate" | "averageDailyRate" | "revenuePerAvailableRoom" | "averageRating" | "averageCleanlinessRating" | "totalReviews" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyAnalytics"]>
  export type PropertyAnalyticsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyAnalyticsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyAnalyticsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyAnalyticsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyAnalytics"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      period: $Enums.AnalyticsPeriod
      periodStart: Date
      periodEnd: Date
      totalRevenue: number
      totalCosts: number
      cleaningCosts: number
      maintenanceCosts: number
      platformFees: number
      netProfit: number
      profitMargin: number
      totalBookings: number
      cancelledBookings: number
      occupancyRate: number
      averageDailyRate: number
      revenuePerAvailableRoom: number | null
      averageRating: number | null
      averageCleanlinessRating: number | null
      totalReviews: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyAnalytics"]>
    composites: {}
  }

  type PropertyAnalyticsGetPayload<S extends boolean | null | undefined | PropertyAnalyticsDefaultArgs> = $Result.GetResult<Prisma.$PropertyAnalyticsPayload, S>

  type PropertyAnalyticsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyAnalyticsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyAnalyticsCountAggregateInputType | true
    }

  export interface PropertyAnalyticsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyAnalytics'], meta: { name: 'PropertyAnalytics' } }
    /**
     * Find zero or one PropertyAnalytics that matches the filter.
     * @param {PropertyAnalyticsFindUniqueArgs} args - Arguments to find a PropertyAnalytics
     * @example
     * // Get one PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyAnalyticsFindUniqueArgs>(args: SelectSubset<T, PropertyAnalyticsFindUniqueArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyAnalytics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyAnalyticsFindUniqueOrThrowArgs} args - Arguments to find a PropertyAnalytics
     * @example
     * // Get one PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyAnalyticsFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyAnalyticsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsFindFirstArgs} args - Arguments to find a PropertyAnalytics
     * @example
     * // Get one PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyAnalyticsFindFirstArgs>(args?: SelectSubset<T, PropertyAnalyticsFindFirstArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyAnalytics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsFindFirstOrThrowArgs} args - Arguments to find a PropertyAnalytics
     * @example
     * // Get one PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyAnalyticsFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyAnalyticsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyAnalytics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.findMany()
     * 
     * // Get first 10 PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyAnalyticsWithIdOnly = await prisma.propertyAnalytics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyAnalyticsFindManyArgs>(args?: SelectSubset<T, PropertyAnalyticsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyAnalytics.
     * @param {PropertyAnalyticsCreateArgs} args - Arguments to create a PropertyAnalytics.
     * @example
     * // Create one PropertyAnalytics
     * const PropertyAnalytics = await prisma.propertyAnalytics.create({
     *   data: {
     *     // ... data to create a PropertyAnalytics
     *   }
     * })
     * 
     */
    create<T extends PropertyAnalyticsCreateArgs>(args: SelectSubset<T, PropertyAnalyticsCreateArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyAnalytics.
     * @param {PropertyAnalyticsCreateManyArgs} args - Arguments to create many PropertyAnalytics.
     * @example
     * // Create many PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyAnalyticsCreateManyArgs>(args?: SelectSubset<T, PropertyAnalyticsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyAnalytics and returns the data saved in the database.
     * @param {PropertyAnalyticsCreateManyAndReturnArgs} args - Arguments to create many PropertyAnalytics.
     * @example
     * // Create many PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyAnalytics and only return the `id`
     * const propertyAnalyticsWithIdOnly = await prisma.propertyAnalytics.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyAnalyticsCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyAnalyticsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyAnalytics.
     * @param {PropertyAnalyticsDeleteArgs} args - Arguments to delete one PropertyAnalytics.
     * @example
     * // Delete one PropertyAnalytics
     * const PropertyAnalytics = await prisma.propertyAnalytics.delete({
     *   where: {
     *     // ... filter to delete one PropertyAnalytics
     *   }
     * })
     * 
     */
    delete<T extends PropertyAnalyticsDeleteArgs>(args: SelectSubset<T, PropertyAnalyticsDeleteArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyAnalytics.
     * @param {PropertyAnalyticsUpdateArgs} args - Arguments to update one PropertyAnalytics.
     * @example
     * // Update one PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyAnalyticsUpdateArgs>(args: SelectSubset<T, PropertyAnalyticsUpdateArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyAnalytics.
     * @param {PropertyAnalyticsDeleteManyArgs} args - Arguments to filter PropertyAnalytics to delete.
     * @example
     * // Delete a few PropertyAnalytics
     * const { count } = await prisma.propertyAnalytics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyAnalyticsDeleteManyArgs>(args?: SelectSubset<T, PropertyAnalyticsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyAnalyticsUpdateManyArgs>(args: SelectSubset<T, PropertyAnalyticsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyAnalytics and returns the data updated in the database.
     * @param {PropertyAnalyticsUpdateManyAndReturnArgs} args - Arguments to update many PropertyAnalytics.
     * @example
     * // Update many PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyAnalytics and only return the `id`
     * const propertyAnalyticsWithIdOnly = await prisma.propertyAnalytics.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyAnalyticsUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyAnalyticsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyAnalytics.
     * @param {PropertyAnalyticsUpsertArgs} args - Arguments to update or create a PropertyAnalytics.
     * @example
     * // Update or create a PropertyAnalytics
     * const propertyAnalytics = await prisma.propertyAnalytics.upsert({
     *   create: {
     *     // ... data to create a PropertyAnalytics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyAnalytics we want to update
     *   }
     * })
     */
    upsert<T extends PropertyAnalyticsUpsertArgs>(args: SelectSubset<T, PropertyAnalyticsUpsertArgs<ExtArgs>>): Prisma__PropertyAnalyticsClient<$Result.GetResult<Prisma.$PropertyAnalyticsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsCountArgs} args - Arguments to filter PropertyAnalytics to count.
     * @example
     * // Count the number of PropertyAnalytics
     * const count = await prisma.propertyAnalytics.count({
     *   where: {
     *     // ... the filter for the PropertyAnalytics we want to count
     *   }
     * })
    **/
    count<T extends PropertyAnalyticsCountArgs>(
      args?: Subset<T, PropertyAnalyticsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyAnalyticsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyAnalyticsAggregateArgs>(args: Subset<T, PropertyAnalyticsAggregateArgs>): Prisma.PrismaPromise<GetPropertyAnalyticsAggregateType<T>>

    /**
     * Group by PropertyAnalytics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyAnalyticsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyAnalyticsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyAnalyticsGroupByArgs['orderBy'] }
        : { orderBy?: PropertyAnalyticsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyAnalyticsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyAnalyticsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyAnalytics model
   */
  readonly fields: PropertyAnalyticsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyAnalytics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyAnalyticsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyAnalytics model
   */
  interface PropertyAnalyticsFieldRefs {
    readonly id: FieldRef<"PropertyAnalytics", 'String'>
    readonly propertyId: FieldRef<"PropertyAnalytics", 'String'>
    readonly period: FieldRef<"PropertyAnalytics", 'AnalyticsPeriod'>
    readonly periodStart: FieldRef<"PropertyAnalytics", 'DateTime'>
    readonly periodEnd: FieldRef<"PropertyAnalytics", 'DateTime'>
    readonly totalRevenue: FieldRef<"PropertyAnalytics", 'Float'>
    readonly totalCosts: FieldRef<"PropertyAnalytics", 'Float'>
    readonly cleaningCosts: FieldRef<"PropertyAnalytics", 'Float'>
    readonly maintenanceCosts: FieldRef<"PropertyAnalytics", 'Float'>
    readonly platformFees: FieldRef<"PropertyAnalytics", 'Float'>
    readonly netProfit: FieldRef<"PropertyAnalytics", 'Float'>
    readonly profitMargin: FieldRef<"PropertyAnalytics", 'Float'>
    readonly totalBookings: FieldRef<"PropertyAnalytics", 'Int'>
    readonly cancelledBookings: FieldRef<"PropertyAnalytics", 'Int'>
    readonly occupancyRate: FieldRef<"PropertyAnalytics", 'Float'>
    readonly averageDailyRate: FieldRef<"PropertyAnalytics", 'Float'>
    readonly revenuePerAvailableRoom: FieldRef<"PropertyAnalytics", 'Float'>
    readonly averageRating: FieldRef<"PropertyAnalytics", 'Float'>
    readonly averageCleanlinessRating: FieldRef<"PropertyAnalytics", 'Float'>
    readonly totalReviews: FieldRef<"PropertyAnalytics", 'Int'>
    readonly createdAt: FieldRef<"PropertyAnalytics", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyAnalytics", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyAnalytics findUnique
   */
  export type PropertyAnalyticsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAnalytics to fetch.
     */
    where: PropertyAnalyticsWhereUniqueInput
  }

  /**
   * PropertyAnalytics findUniqueOrThrow
   */
  export type PropertyAnalyticsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAnalytics to fetch.
     */
    where: PropertyAnalyticsWhereUniqueInput
  }

  /**
   * PropertyAnalytics findFirst
   */
  export type PropertyAnalyticsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAnalytics to fetch.
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAnalytics to fetch.
     */
    orderBy?: PropertyAnalyticsOrderByWithRelationInput | PropertyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAnalytics.
     */
    cursor?: PropertyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAnalytics.
     */
    distinct?: PropertyAnalyticsScalarFieldEnum | PropertyAnalyticsScalarFieldEnum[]
  }

  /**
   * PropertyAnalytics findFirstOrThrow
   */
  export type PropertyAnalyticsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAnalytics to fetch.
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAnalytics to fetch.
     */
    orderBy?: PropertyAnalyticsOrderByWithRelationInput | PropertyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyAnalytics.
     */
    cursor?: PropertyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAnalytics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyAnalytics.
     */
    distinct?: PropertyAnalyticsScalarFieldEnum | PropertyAnalyticsScalarFieldEnum[]
  }

  /**
   * PropertyAnalytics findMany
   */
  export type PropertyAnalyticsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * Filter, which PropertyAnalytics to fetch.
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyAnalytics to fetch.
     */
    orderBy?: PropertyAnalyticsOrderByWithRelationInput | PropertyAnalyticsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyAnalytics.
     */
    cursor?: PropertyAnalyticsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyAnalytics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyAnalytics.
     */
    skip?: number
    distinct?: PropertyAnalyticsScalarFieldEnum | PropertyAnalyticsScalarFieldEnum[]
  }

  /**
   * PropertyAnalytics create
   */
  export type PropertyAnalyticsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyAnalytics.
     */
    data: XOR<PropertyAnalyticsCreateInput, PropertyAnalyticsUncheckedCreateInput>
  }

  /**
   * PropertyAnalytics createMany
   */
  export type PropertyAnalyticsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyAnalytics.
     */
    data: PropertyAnalyticsCreateManyInput | PropertyAnalyticsCreateManyInput[]
  }

  /**
   * PropertyAnalytics createManyAndReturn
   */
  export type PropertyAnalyticsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyAnalytics.
     */
    data: PropertyAnalyticsCreateManyInput | PropertyAnalyticsCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAnalytics update
   */
  export type PropertyAnalyticsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyAnalytics.
     */
    data: XOR<PropertyAnalyticsUpdateInput, PropertyAnalyticsUncheckedUpdateInput>
    /**
     * Choose, which PropertyAnalytics to update.
     */
    where: PropertyAnalyticsWhereUniqueInput
  }

  /**
   * PropertyAnalytics updateMany
   */
  export type PropertyAnalyticsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyAnalytics.
     */
    data: XOR<PropertyAnalyticsUpdateManyMutationInput, PropertyAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAnalytics to update
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * Limit how many PropertyAnalytics to update.
     */
    limit?: number
  }

  /**
   * PropertyAnalytics updateManyAndReturn
   */
  export type PropertyAnalyticsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * The data used to update PropertyAnalytics.
     */
    data: XOR<PropertyAnalyticsUpdateManyMutationInput, PropertyAnalyticsUncheckedUpdateManyInput>
    /**
     * Filter which PropertyAnalytics to update
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * Limit how many PropertyAnalytics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyAnalytics upsert
   */
  export type PropertyAnalyticsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyAnalytics to update in case it exists.
     */
    where: PropertyAnalyticsWhereUniqueInput
    /**
     * In case the PropertyAnalytics found by the `where` argument doesn't exist, create a new PropertyAnalytics with this data.
     */
    create: XOR<PropertyAnalyticsCreateInput, PropertyAnalyticsUncheckedCreateInput>
    /**
     * In case the PropertyAnalytics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyAnalyticsUpdateInput, PropertyAnalyticsUncheckedUpdateInput>
  }

  /**
   * PropertyAnalytics delete
   */
  export type PropertyAnalyticsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
    /**
     * Filter which PropertyAnalytics to delete.
     */
    where: PropertyAnalyticsWhereUniqueInput
  }

  /**
   * PropertyAnalytics deleteMany
   */
  export type PropertyAnalyticsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyAnalytics to delete
     */
    where?: PropertyAnalyticsWhereInput
    /**
     * Limit how many PropertyAnalytics to delete.
     */
    limit?: number
  }

  /**
   * PropertyAnalytics without action
   */
  export type PropertyAnalyticsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyAnalytics
     */
    select?: PropertyAnalyticsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyAnalytics
     */
    omit?: PropertyAnalyticsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyAnalyticsInclude<ExtArgs> | null
  }


  /**
   * Model PropertyNote
   */

  export type AggregatePropertyNote = {
    _count: PropertyNoteCountAggregateOutputType | null
    _min: PropertyNoteMinAggregateOutputType | null
    _max: PropertyNoteMaxAggregateOutputType | null
  }

  export type PropertyNoteMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    type: $Enums.NoteType | null
    title: string | null
    content: string | null
    isPrivate: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyNoteMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    type: $Enums.NoteType | null
    title: string | null
    content: string | null
    isPrivate: boolean | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PropertyNoteCountAggregateOutputType = {
    id: number
    propertyId: number
    type: number
    title: number
    content: number
    isPrivate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PropertyNoteMinAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    title?: true
    content?: true
    isPrivate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyNoteMaxAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    title?: true
    content?: true
    isPrivate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PropertyNoteCountAggregateInputType = {
    id?: true
    propertyId?: true
    type?: true
    title?: true
    content?: true
    isPrivate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PropertyNoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyNote to aggregate.
     */
    where?: PropertyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyNotes to fetch.
     */
    orderBy?: PropertyNoteOrderByWithRelationInput | PropertyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PropertyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PropertyNotes
    **/
    _count?: true | PropertyNoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PropertyNoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PropertyNoteMaxAggregateInputType
  }

  export type GetPropertyNoteAggregateType<T extends PropertyNoteAggregateArgs> = {
        [P in keyof T & keyof AggregatePropertyNote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePropertyNote[P]>
      : GetScalarType<T[P], AggregatePropertyNote[P]>
  }




  export type PropertyNoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PropertyNoteWhereInput
    orderBy?: PropertyNoteOrderByWithAggregationInput | PropertyNoteOrderByWithAggregationInput[]
    by: PropertyNoteScalarFieldEnum[] | PropertyNoteScalarFieldEnum
    having?: PropertyNoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PropertyNoteCountAggregateInputType | true
    _min?: PropertyNoteMinAggregateInputType
    _max?: PropertyNoteMaxAggregateInputType
  }

  export type PropertyNoteGroupByOutputType = {
    id: string
    propertyId: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate: boolean
    createdBy: string
    createdAt: Date
    updatedAt: Date
    _count: PropertyNoteCountAggregateOutputType | null
    _min: PropertyNoteMinAggregateOutputType | null
    _max: PropertyNoteMaxAggregateOutputType | null
  }

  type GetPropertyNoteGroupByPayload<T extends PropertyNoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PropertyNoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PropertyNoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PropertyNoteGroupByOutputType[P]>
            : GetScalarType<T[P], PropertyNoteGroupByOutputType[P]>
        }
      >
    >


  export type PropertyNoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyNote"]>

  export type PropertyNoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyNote"]>

  export type PropertyNoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["propertyNote"]>

  export type PropertyNoteSelectScalar = {
    id?: boolean
    propertyId?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    isPrivate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PropertyNoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "type" | "title" | "content" | "isPrivate" | "createdBy" | "createdAt" | "updatedAt", ExtArgs["result"]["propertyNote"]>
  export type PropertyNoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyNoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }
  export type PropertyNoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
  }

  export type $PropertyNotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PropertyNote"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      type: $Enums.NoteType
      title: string
      content: string
      isPrivate: boolean
      createdBy: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["propertyNote"]>
    composites: {}
  }

  type PropertyNoteGetPayload<S extends boolean | null | undefined | PropertyNoteDefaultArgs> = $Result.GetResult<Prisma.$PropertyNotePayload, S>

  type PropertyNoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PropertyNoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PropertyNoteCountAggregateInputType | true
    }

  export interface PropertyNoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PropertyNote'], meta: { name: 'PropertyNote' } }
    /**
     * Find zero or one PropertyNote that matches the filter.
     * @param {PropertyNoteFindUniqueArgs} args - Arguments to find a PropertyNote
     * @example
     * // Get one PropertyNote
     * const propertyNote = await prisma.propertyNote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PropertyNoteFindUniqueArgs>(args: SelectSubset<T, PropertyNoteFindUniqueArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PropertyNote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PropertyNoteFindUniqueOrThrowArgs} args - Arguments to find a PropertyNote
     * @example
     * // Get one PropertyNote
     * const propertyNote = await prisma.propertyNote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PropertyNoteFindUniqueOrThrowArgs>(args: SelectSubset<T, PropertyNoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyNote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteFindFirstArgs} args - Arguments to find a PropertyNote
     * @example
     * // Get one PropertyNote
     * const propertyNote = await prisma.propertyNote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PropertyNoteFindFirstArgs>(args?: SelectSubset<T, PropertyNoteFindFirstArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PropertyNote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteFindFirstOrThrowArgs} args - Arguments to find a PropertyNote
     * @example
     * // Get one PropertyNote
     * const propertyNote = await prisma.propertyNote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PropertyNoteFindFirstOrThrowArgs>(args?: SelectSubset<T, PropertyNoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PropertyNotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PropertyNotes
     * const propertyNotes = await prisma.propertyNote.findMany()
     * 
     * // Get first 10 PropertyNotes
     * const propertyNotes = await prisma.propertyNote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const propertyNoteWithIdOnly = await prisma.propertyNote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PropertyNoteFindManyArgs>(args?: SelectSubset<T, PropertyNoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PropertyNote.
     * @param {PropertyNoteCreateArgs} args - Arguments to create a PropertyNote.
     * @example
     * // Create one PropertyNote
     * const PropertyNote = await prisma.propertyNote.create({
     *   data: {
     *     // ... data to create a PropertyNote
     *   }
     * })
     * 
     */
    create<T extends PropertyNoteCreateArgs>(args: SelectSubset<T, PropertyNoteCreateArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PropertyNotes.
     * @param {PropertyNoteCreateManyArgs} args - Arguments to create many PropertyNotes.
     * @example
     * // Create many PropertyNotes
     * const propertyNote = await prisma.propertyNote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PropertyNoteCreateManyArgs>(args?: SelectSubset<T, PropertyNoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PropertyNotes and returns the data saved in the database.
     * @param {PropertyNoteCreateManyAndReturnArgs} args - Arguments to create many PropertyNotes.
     * @example
     * // Create many PropertyNotes
     * const propertyNote = await prisma.propertyNote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PropertyNotes and only return the `id`
     * const propertyNoteWithIdOnly = await prisma.propertyNote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PropertyNoteCreateManyAndReturnArgs>(args?: SelectSubset<T, PropertyNoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PropertyNote.
     * @param {PropertyNoteDeleteArgs} args - Arguments to delete one PropertyNote.
     * @example
     * // Delete one PropertyNote
     * const PropertyNote = await prisma.propertyNote.delete({
     *   where: {
     *     // ... filter to delete one PropertyNote
     *   }
     * })
     * 
     */
    delete<T extends PropertyNoteDeleteArgs>(args: SelectSubset<T, PropertyNoteDeleteArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PropertyNote.
     * @param {PropertyNoteUpdateArgs} args - Arguments to update one PropertyNote.
     * @example
     * // Update one PropertyNote
     * const propertyNote = await prisma.propertyNote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PropertyNoteUpdateArgs>(args: SelectSubset<T, PropertyNoteUpdateArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PropertyNotes.
     * @param {PropertyNoteDeleteManyArgs} args - Arguments to filter PropertyNotes to delete.
     * @example
     * // Delete a few PropertyNotes
     * const { count } = await prisma.propertyNote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PropertyNoteDeleteManyArgs>(args?: SelectSubset<T, PropertyNoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PropertyNotes
     * const propertyNote = await prisma.propertyNote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PropertyNoteUpdateManyArgs>(args: SelectSubset<T, PropertyNoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PropertyNotes and returns the data updated in the database.
     * @param {PropertyNoteUpdateManyAndReturnArgs} args - Arguments to update many PropertyNotes.
     * @example
     * // Update many PropertyNotes
     * const propertyNote = await prisma.propertyNote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PropertyNotes and only return the `id`
     * const propertyNoteWithIdOnly = await prisma.propertyNote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PropertyNoteUpdateManyAndReturnArgs>(args: SelectSubset<T, PropertyNoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PropertyNote.
     * @param {PropertyNoteUpsertArgs} args - Arguments to update or create a PropertyNote.
     * @example
     * // Update or create a PropertyNote
     * const propertyNote = await prisma.propertyNote.upsert({
     *   create: {
     *     // ... data to create a PropertyNote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PropertyNote we want to update
     *   }
     * })
     */
    upsert<T extends PropertyNoteUpsertArgs>(args: SelectSubset<T, PropertyNoteUpsertArgs<ExtArgs>>): Prisma__PropertyNoteClient<$Result.GetResult<Prisma.$PropertyNotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PropertyNotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteCountArgs} args - Arguments to filter PropertyNotes to count.
     * @example
     * // Count the number of PropertyNotes
     * const count = await prisma.propertyNote.count({
     *   where: {
     *     // ... the filter for the PropertyNotes we want to count
     *   }
     * })
    **/
    count<T extends PropertyNoteCountArgs>(
      args?: Subset<T, PropertyNoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PropertyNoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PropertyNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PropertyNoteAggregateArgs>(args: Subset<T, PropertyNoteAggregateArgs>): Prisma.PrismaPromise<GetPropertyNoteAggregateType<T>>

    /**
     * Group by PropertyNote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PropertyNoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PropertyNoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PropertyNoteGroupByArgs['orderBy'] }
        : { orderBy?: PropertyNoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PropertyNoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPropertyNoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PropertyNote model
   */
  readonly fields: PropertyNoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PropertyNote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PropertyNoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PropertyNote model
   */
  interface PropertyNoteFieldRefs {
    readonly id: FieldRef<"PropertyNote", 'String'>
    readonly propertyId: FieldRef<"PropertyNote", 'String'>
    readonly type: FieldRef<"PropertyNote", 'NoteType'>
    readonly title: FieldRef<"PropertyNote", 'String'>
    readonly content: FieldRef<"PropertyNote", 'String'>
    readonly isPrivate: FieldRef<"PropertyNote", 'Boolean'>
    readonly createdBy: FieldRef<"PropertyNote", 'String'>
    readonly createdAt: FieldRef<"PropertyNote", 'DateTime'>
    readonly updatedAt: FieldRef<"PropertyNote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PropertyNote findUnique
   */
  export type PropertyNoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyNote to fetch.
     */
    where: PropertyNoteWhereUniqueInput
  }

  /**
   * PropertyNote findUniqueOrThrow
   */
  export type PropertyNoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyNote to fetch.
     */
    where: PropertyNoteWhereUniqueInput
  }

  /**
   * PropertyNote findFirst
   */
  export type PropertyNoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyNote to fetch.
     */
    where?: PropertyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyNotes to fetch.
     */
    orderBy?: PropertyNoteOrderByWithRelationInput | PropertyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyNotes.
     */
    cursor?: PropertyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyNotes.
     */
    distinct?: PropertyNoteScalarFieldEnum | PropertyNoteScalarFieldEnum[]
  }

  /**
   * PropertyNote findFirstOrThrow
   */
  export type PropertyNoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyNote to fetch.
     */
    where?: PropertyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyNotes to fetch.
     */
    orderBy?: PropertyNoteOrderByWithRelationInput | PropertyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PropertyNotes.
     */
    cursor?: PropertyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyNotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PropertyNotes.
     */
    distinct?: PropertyNoteScalarFieldEnum | PropertyNoteScalarFieldEnum[]
  }

  /**
   * PropertyNote findMany
   */
  export type PropertyNoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * Filter, which PropertyNotes to fetch.
     */
    where?: PropertyNoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PropertyNotes to fetch.
     */
    orderBy?: PropertyNoteOrderByWithRelationInput | PropertyNoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PropertyNotes.
     */
    cursor?: PropertyNoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PropertyNotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PropertyNotes.
     */
    skip?: number
    distinct?: PropertyNoteScalarFieldEnum | PropertyNoteScalarFieldEnum[]
  }

  /**
   * PropertyNote create
   */
  export type PropertyNoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * The data needed to create a PropertyNote.
     */
    data: XOR<PropertyNoteCreateInput, PropertyNoteUncheckedCreateInput>
  }

  /**
   * PropertyNote createMany
   */
  export type PropertyNoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PropertyNotes.
     */
    data: PropertyNoteCreateManyInput | PropertyNoteCreateManyInput[]
  }

  /**
   * PropertyNote createManyAndReturn
   */
  export type PropertyNoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * The data used to create many PropertyNotes.
     */
    data: PropertyNoteCreateManyInput | PropertyNoteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyNote update
   */
  export type PropertyNoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * The data needed to update a PropertyNote.
     */
    data: XOR<PropertyNoteUpdateInput, PropertyNoteUncheckedUpdateInput>
    /**
     * Choose, which PropertyNote to update.
     */
    where: PropertyNoteWhereUniqueInput
  }

  /**
   * PropertyNote updateMany
   */
  export type PropertyNoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PropertyNotes.
     */
    data: XOR<PropertyNoteUpdateManyMutationInput, PropertyNoteUncheckedUpdateManyInput>
    /**
     * Filter which PropertyNotes to update
     */
    where?: PropertyNoteWhereInput
    /**
     * Limit how many PropertyNotes to update.
     */
    limit?: number
  }

  /**
   * PropertyNote updateManyAndReturn
   */
  export type PropertyNoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * The data used to update PropertyNotes.
     */
    data: XOR<PropertyNoteUpdateManyMutationInput, PropertyNoteUncheckedUpdateManyInput>
    /**
     * Filter which PropertyNotes to update
     */
    where?: PropertyNoteWhereInput
    /**
     * Limit how many PropertyNotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PropertyNote upsert
   */
  export type PropertyNoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * The filter to search for the PropertyNote to update in case it exists.
     */
    where: PropertyNoteWhereUniqueInput
    /**
     * In case the PropertyNote found by the `where` argument doesn't exist, create a new PropertyNote with this data.
     */
    create: XOR<PropertyNoteCreateInput, PropertyNoteUncheckedCreateInput>
    /**
     * In case the PropertyNote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PropertyNoteUpdateInput, PropertyNoteUncheckedUpdateInput>
  }

  /**
   * PropertyNote delete
   */
  export type PropertyNoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
    /**
     * Filter which PropertyNote to delete.
     */
    where: PropertyNoteWhereUniqueInput
  }

  /**
   * PropertyNote deleteMany
   */
  export type PropertyNoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PropertyNotes to delete
     */
    where?: PropertyNoteWhereInput
    /**
     * Limit how many PropertyNotes to delete.
     */
    limit?: number
  }

  /**
   * PropertyNote without action
   */
  export type PropertyNoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PropertyNote
     */
    select?: PropertyNoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PropertyNote
     */
    omit?: PropertyNoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PropertyNoteInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    changes: number
    ipAddress: number
    userAgent: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    changes?: true
    ipAddress?: true
    userAgent?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string
    action: string
    entityType: string
    entityId: string | null
    changes: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    metadata: JsonValue | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    changes?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type AuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "action" | "entityType" | "entityId" | "changes" | "ipAddress" | "userAgent" | "metadata" | "createdAt", ExtArgs["result"]["auditLog"]>
  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      action: string
      entityType: string
      entityId: string | null
      changes: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs and returns the data updated in the database.
     * @param {AuditLogUpdateManyAndReturnArgs} args - Arguments to update many AuditLogs.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly changes: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly metadata: FieldRef<"AuditLog", 'Json'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
  }

  /**
   * AuditLog updateManyAndReturn
   */
  export type AuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
    /**
     * Limit how many AuditLogs to delete.
     */
    limit?: number
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AuditLog
     */
    omit?: AuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model Content
   */

  export type AggregateContent = {
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  export type ContentAvgAggregateOutputType = {
    order: number | null
  }

  export type ContentSumAggregateOutputType = {
    order: number | null
  }

  export type ContentMinAggregateOutputType = {
    id: string | null
    page: string | null
    section: string | null
    key: string | null
    contentGr: string | null
    contentEn: string | null
    type: $Enums.ContentType | null
    order: number | null
    active: boolean | null
    metaTitleGr: string | null
    metaTitleEn: string | null
    metaDescriptionGr: string | null
    metaDescriptionEn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentMaxAggregateOutputType = {
    id: string | null
    page: string | null
    section: string | null
    key: string | null
    contentGr: string | null
    contentEn: string | null
    type: $Enums.ContentType | null
    order: number | null
    active: boolean | null
    metaTitleGr: string | null
    metaTitleEn: string | null
    metaDescriptionGr: string | null
    metaDescriptionEn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContentCountAggregateOutputType = {
    id: number
    page: number
    section: number
    key: number
    contentGr: number
    contentEn: number
    type: number
    order: number
    active: number
    metadata: number
    metaTitleGr: number
    metaTitleEn: number
    metaDescriptionGr: number
    metaDescriptionEn: number
    keywords: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContentAvgAggregateInputType = {
    order?: true
  }

  export type ContentSumAggregateInputType = {
    order?: true
  }

  export type ContentMinAggregateInputType = {
    id?: true
    page?: true
    section?: true
    key?: true
    contentGr?: true
    contentEn?: true
    type?: true
    order?: true
    active?: true
    metaTitleGr?: true
    metaTitleEn?: true
    metaDescriptionGr?: true
    metaDescriptionEn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentMaxAggregateInputType = {
    id?: true
    page?: true
    section?: true
    key?: true
    contentGr?: true
    contentEn?: true
    type?: true
    order?: true
    active?: true
    metaTitleGr?: true
    metaTitleEn?: true
    metaDescriptionGr?: true
    metaDescriptionEn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContentCountAggregateInputType = {
    id?: true
    page?: true
    section?: true
    key?: true
    contentGr?: true
    contentEn?: true
    type?: true
    order?: true
    active?: true
    metadata?: true
    metaTitleGr?: true
    metaTitleEn?: true
    metaDescriptionGr?: true
    metaDescriptionEn?: true
    keywords?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Content to aggregate.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contents
    **/
    _count?: true | ContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMaxAggregateInputType
  }

  export type GetContentAggregateType<T extends ContentAggregateArgs> = {
        [P in keyof T & keyof AggregateContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContent[P]>
      : GetScalarType<T[P], AggregateContent[P]>
  }




  export type ContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentWhereInput
    orderBy?: ContentOrderByWithAggregationInput | ContentOrderByWithAggregationInput[]
    by: ContentScalarFieldEnum[] | ContentScalarFieldEnum
    having?: ContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentCountAggregateInputType | true
    _avg?: ContentAvgAggregateInputType
    _sum?: ContentSumAggregateInputType
    _min?: ContentMinAggregateInputType
    _max?: ContentMaxAggregateInputType
  }

  export type ContentGroupByOutputType = {
    id: string
    page: string
    section: string
    key: string
    contentGr: string | null
    contentEn: string | null
    type: $Enums.ContentType
    order: number
    active: boolean
    metadata: JsonValue | null
    metaTitleGr: string | null
    metaTitleEn: string | null
    metaDescriptionGr: string | null
    metaDescriptionEn: string | null
    keywords: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: ContentCountAggregateOutputType | null
    _avg: ContentAvgAggregateOutputType | null
    _sum: ContentSumAggregateOutputType | null
    _min: ContentMinAggregateOutputType | null
    _max: ContentMaxAggregateOutputType | null
  }

  type GetContentGroupByPayload<T extends ContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentGroupByOutputType[P]>
            : GetScalarType<T[P], ContentGroupByOutputType[P]>
        }
      >
    >


  export type ContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    page?: boolean
    section?: boolean
    key?: boolean
    contentGr?: boolean
    contentEn?: boolean
    type?: boolean
    order?: boolean
    active?: boolean
    metadata?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    media?: boolean | Content$mediaArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["content"]>

  export type ContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    page?: boolean
    section?: boolean
    key?: boolean
    contentGr?: boolean
    contentEn?: boolean
    type?: boolean
    order?: boolean
    active?: boolean
    metadata?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["content"]>

  export type ContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    page?: boolean
    section?: boolean
    key?: boolean
    contentGr?: boolean
    contentEn?: boolean
    type?: boolean
    order?: boolean
    active?: boolean
    metadata?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["content"]>

  export type ContentSelectScalar = {
    id?: boolean
    page?: boolean
    section?: boolean
    key?: boolean
    contentGr?: boolean
    contentEn?: boolean
    type?: boolean
    order?: boolean
    active?: boolean
    metadata?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    keywords?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "page" | "section" | "key" | "contentGr" | "contentEn" | "type" | "order" | "active" | "metadata" | "metaTitleGr" | "metaTitleEn" | "metaDescriptionGr" | "metaDescriptionEn" | "keywords" | "createdAt" | "updatedAt", ExtArgs["result"]["content"]>
  export type ContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    media?: boolean | Content$mediaArgs<ExtArgs>
    _count?: boolean | ContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Content"
    objects: {
      media: Prisma.$ContentMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      page: string
      section: string
      key: string
      contentGr: string | null
      contentEn: string | null
      type: $Enums.ContentType
      order: number
      active: boolean
      metadata: Prisma.JsonValue | null
      metaTitleGr: string | null
      metaTitleEn: string | null
      metaDescriptionGr: string | null
      metaDescriptionEn: string | null
      keywords: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["content"]>
    composites: {}
  }

  type ContentGetPayload<S extends boolean | null | undefined | ContentDefaultArgs> = $Result.GetResult<Prisma.$ContentPayload, S>

  type ContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentCountAggregateInputType | true
    }

  export interface ContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Content'], meta: { name: 'Content' } }
    /**
     * Find zero or one Content that matches the filter.
     * @param {ContentFindUniqueArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentFindUniqueArgs>(args: SelectSubset<T, ContentFindUniqueArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Content that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentFindUniqueOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentFindFirstArgs>(args?: SelectSubset<T, ContentFindFirstArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Content that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindFirstOrThrowArgs} args - Arguments to find a Content
     * @example
     * // Get one Content
     * const content = await prisma.content.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contents
     * const contents = await prisma.content.findMany()
     * 
     * // Get first 10 Contents
     * const contents = await prisma.content.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentWithIdOnly = await prisma.content.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentFindManyArgs>(args?: SelectSubset<T, ContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Content.
     * @param {ContentCreateArgs} args - Arguments to create a Content.
     * @example
     * // Create one Content
     * const Content = await prisma.content.create({
     *   data: {
     *     // ... data to create a Content
     *   }
     * })
     * 
     */
    create<T extends ContentCreateArgs>(args: SelectSubset<T, ContentCreateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contents.
     * @param {ContentCreateManyArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentCreateManyArgs>(args?: SelectSubset<T, ContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contents and returns the data saved in the database.
     * @param {ContentCreateManyAndReturnArgs} args - Arguments to create many Contents.
     * @example
     * // Create many Contents
     * const content = await prisma.content.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Content.
     * @param {ContentDeleteArgs} args - Arguments to delete one Content.
     * @example
     * // Delete one Content
     * const Content = await prisma.content.delete({
     *   where: {
     *     // ... filter to delete one Content
     *   }
     * })
     * 
     */
    delete<T extends ContentDeleteArgs>(args: SelectSubset<T, ContentDeleteArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Content.
     * @param {ContentUpdateArgs} args - Arguments to update one Content.
     * @example
     * // Update one Content
     * const content = await prisma.content.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentUpdateArgs>(args: SelectSubset<T, ContentUpdateArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contents.
     * @param {ContentDeleteManyArgs} args - Arguments to filter Contents to delete.
     * @example
     * // Delete a few Contents
     * const { count } = await prisma.content.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentDeleteManyArgs>(args?: SelectSubset<T, ContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentUpdateManyArgs>(args: SelectSubset<T, ContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contents and returns the data updated in the database.
     * @param {ContentUpdateManyAndReturnArgs} args - Arguments to update many Contents.
     * @example
     * // Update many Contents
     * const content = await prisma.content.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contents and only return the `id`
     * const contentWithIdOnly = await prisma.content.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Content.
     * @param {ContentUpsertArgs} args - Arguments to update or create a Content.
     * @example
     * // Update or create a Content
     * const content = await prisma.content.upsert({
     *   create: {
     *     // ... data to create a Content
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Content we want to update
     *   }
     * })
     */
    upsert<T extends ContentUpsertArgs>(args: SelectSubset<T, ContentUpsertArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentCountArgs} args - Arguments to filter Contents to count.
     * @example
     * // Count the number of Contents
     * const count = await prisma.content.count({
     *   where: {
     *     // ... the filter for the Contents we want to count
     *   }
     * })
    **/
    count<T extends ContentCountArgs>(
      args?: Subset<T, ContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentAggregateArgs>(args: Subset<T, ContentAggregateArgs>): Prisma.PrismaPromise<GetContentAggregateType<T>>

    /**
     * Group by Content.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentGroupByArgs['orderBy'] }
        : { orderBy?: ContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Content model
   */
  readonly fields: ContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Content.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    media<T extends Content$mediaArgs<ExtArgs> = {}>(args?: Subset<T, Content$mediaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Content model
   */
  interface ContentFieldRefs {
    readonly id: FieldRef<"Content", 'String'>
    readonly page: FieldRef<"Content", 'String'>
    readonly section: FieldRef<"Content", 'String'>
    readonly key: FieldRef<"Content", 'String'>
    readonly contentGr: FieldRef<"Content", 'String'>
    readonly contentEn: FieldRef<"Content", 'String'>
    readonly type: FieldRef<"Content", 'ContentType'>
    readonly order: FieldRef<"Content", 'Int'>
    readonly active: FieldRef<"Content", 'Boolean'>
    readonly metadata: FieldRef<"Content", 'Json'>
    readonly metaTitleGr: FieldRef<"Content", 'String'>
    readonly metaTitleEn: FieldRef<"Content", 'String'>
    readonly metaDescriptionGr: FieldRef<"Content", 'String'>
    readonly metaDescriptionEn: FieldRef<"Content", 'String'>
    readonly keywords: FieldRef<"Content", 'Json'>
    readonly createdAt: FieldRef<"Content", 'DateTime'>
    readonly updatedAt: FieldRef<"Content", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Content findUnique
   */
  export type ContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findUniqueOrThrow
   */
  export type ContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content findFirst
   */
  export type ContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findFirstOrThrow
   */
  export type ContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Content to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contents.
     */
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content findMany
   */
  export type ContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter, which Contents to fetch.
     */
    where?: ContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contents to fetch.
     */
    orderBy?: ContentOrderByWithRelationInput | ContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contents.
     */
    cursor?: ContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contents.
     */
    skip?: number
    distinct?: ContentScalarFieldEnum | ContentScalarFieldEnum[]
  }

  /**
   * Content create
   */
  export type ContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to create a Content.
     */
    data: XOR<ContentCreateInput, ContentUncheckedCreateInput>
  }

  /**
   * Content createMany
   */
  export type ContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
  }

  /**
   * Content createManyAndReturn
   */
  export type ContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to create many Contents.
     */
    data: ContentCreateManyInput | ContentCreateManyInput[]
  }

  /**
   * Content update
   */
  export type ContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The data needed to update a Content.
     */
    data: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
    /**
     * Choose, which Content to update.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content updateMany
   */
  export type ContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content updateManyAndReturn
   */
  export type ContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * The data used to update Contents.
     */
    data: XOR<ContentUpdateManyMutationInput, ContentUncheckedUpdateManyInput>
    /**
     * Filter which Contents to update
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to update.
     */
    limit?: number
  }

  /**
   * Content upsert
   */
  export type ContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * The filter to search for the Content to update in case it exists.
     */
    where: ContentWhereUniqueInput
    /**
     * In case the Content found by the `where` argument doesn't exist, create a new Content with this data.
     */
    create: XOR<ContentCreateInput, ContentUncheckedCreateInput>
    /**
     * In case the Content was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentUpdateInput, ContentUncheckedUpdateInput>
  }

  /**
   * Content delete
   */
  export type ContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
    /**
     * Filter which Content to delete.
     */
    where: ContentWhereUniqueInput
  }

  /**
   * Content deleteMany
   */
  export type ContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contents to delete
     */
    where?: ContentWhereInput
    /**
     * Limit how many Contents to delete.
     */
    limit?: number
  }

  /**
   * Content.media
   */
  export type Content$mediaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    where?: ContentMediaWhereInput
    orderBy?: ContentMediaOrderByWithRelationInput | ContentMediaOrderByWithRelationInput[]
    cursor?: ContentMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentMediaScalarFieldEnum | ContentMediaScalarFieldEnum[]
  }

  /**
   * Content without action
   */
  export type ContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Content
     */
    select?: ContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Content
     */
    omit?: ContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentInclude<ExtArgs> | null
  }


  /**
   * Model ContentMedia
   */

  export type AggregateContentMedia = {
    _count: ContentMediaCountAggregateOutputType | null
    _avg: ContentMediaAvgAggregateOutputType | null
    _sum: ContentMediaSumAggregateOutputType | null
    _min: ContentMediaMinAggregateOutputType | null
    _max: ContentMediaMaxAggregateOutputType | null
  }

  export type ContentMediaAvgAggregateOutputType = {
    order: number | null
  }

  export type ContentMediaSumAggregateOutputType = {
    order: number | null
  }

  export type ContentMediaMinAggregateOutputType = {
    id: string | null
    contentId: string | null
    mediaId: string | null
    order: number | null
  }

  export type ContentMediaMaxAggregateOutputType = {
    id: string | null
    contentId: string | null
    mediaId: string | null
    order: number | null
  }

  export type ContentMediaCountAggregateOutputType = {
    id: number
    contentId: number
    mediaId: number
    order: number
    _all: number
  }


  export type ContentMediaAvgAggregateInputType = {
    order?: true
  }

  export type ContentMediaSumAggregateInputType = {
    order?: true
  }

  export type ContentMediaMinAggregateInputType = {
    id?: true
    contentId?: true
    mediaId?: true
    order?: true
  }

  export type ContentMediaMaxAggregateInputType = {
    id?: true
    contentId?: true
    mediaId?: true
    order?: true
  }

  export type ContentMediaCountAggregateInputType = {
    id?: true
    contentId?: true
    mediaId?: true
    order?: true
    _all?: true
  }

  export type ContentMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentMedia to aggregate.
     */
    where?: ContentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentMedias to fetch.
     */
    orderBy?: ContentMediaOrderByWithRelationInput | ContentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContentMedias
    **/
    _count?: true | ContentMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContentMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContentMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContentMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContentMediaMaxAggregateInputType
  }

  export type GetContentMediaAggregateType<T extends ContentMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateContentMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContentMedia[P]>
      : GetScalarType<T[P], AggregateContentMedia[P]>
  }




  export type ContentMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContentMediaWhereInput
    orderBy?: ContentMediaOrderByWithAggregationInput | ContentMediaOrderByWithAggregationInput[]
    by: ContentMediaScalarFieldEnum[] | ContentMediaScalarFieldEnum
    having?: ContentMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContentMediaCountAggregateInputType | true
    _avg?: ContentMediaAvgAggregateInputType
    _sum?: ContentMediaSumAggregateInputType
    _min?: ContentMediaMinAggregateInputType
    _max?: ContentMediaMaxAggregateInputType
  }

  export type ContentMediaGroupByOutputType = {
    id: string
    contentId: string
    mediaId: string
    order: number
    _count: ContentMediaCountAggregateOutputType | null
    _avg: ContentMediaAvgAggregateOutputType | null
    _sum: ContentMediaSumAggregateOutputType | null
    _min: ContentMediaMinAggregateOutputType | null
    _max: ContentMediaMaxAggregateOutputType | null
  }

  type GetContentMediaGroupByPayload<T extends ContentMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContentMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContentMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContentMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ContentMediaGroupByOutputType[P]>
        }
      >
    >


  export type ContentMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    mediaId?: boolean
    order?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentMedia"]>

  export type ContentMediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    mediaId?: boolean
    order?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentMedia"]>

  export type ContentMediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contentId?: boolean
    mediaId?: boolean
    order?: boolean
    content?: boolean | ContentDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contentMedia"]>

  export type ContentMediaSelectScalar = {
    id?: boolean
    contentId?: boolean
    mediaId?: boolean
    order?: boolean
  }

  export type ContentMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contentId" | "mediaId" | "order", ExtArgs["result"]["contentMedia"]>
  export type ContentMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ContentMediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }
  export type ContentMediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | ContentDefaultArgs<ExtArgs>
    media?: boolean | MediaDefaultArgs<ExtArgs>
  }

  export type $ContentMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContentMedia"
    objects: {
      content: Prisma.$ContentPayload<ExtArgs>
      media: Prisma.$MediaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contentId: string
      mediaId: string
      order: number
    }, ExtArgs["result"]["contentMedia"]>
    composites: {}
  }

  type ContentMediaGetPayload<S extends boolean | null | undefined | ContentMediaDefaultArgs> = $Result.GetResult<Prisma.$ContentMediaPayload, S>

  type ContentMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContentMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContentMediaCountAggregateInputType | true
    }

  export interface ContentMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContentMedia'], meta: { name: 'ContentMedia' } }
    /**
     * Find zero or one ContentMedia that matches the filter.
     * @param {ContentMediaFindUniqueArgs} args - Arguments to find a ContentMedia
     * @example
     * // Get one ContentMedia
     * const contentMedia = await prisma.contentMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContentMediaFindUniqueArgs>(args: SelectSubset<T, ContentMediaFindUniqueArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContentMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContentMediaFindUniqueOrThrowArgs} args - Arguments to find a ContentMedia
     * @example
     * // Get one ContentMedia
     * const contentMedia = await prisma.contentMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContentMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ContentMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaFindFirstArgs} args - Arguments to find a ContentMedia
     * @example
     * // Get one ContentMedia
     * const contentMedia = await prisma.contentMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContentMediaFindFirstArgs>(args?: SelectSubset<T, ContentMediaFindFirstArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContentMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaFindFirstOrThrowArgs} args - Arguments to find a ContentMedia
     * @example
     * // Get one ContentMedia
     * const contentMedia = await prisma.contentMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContentMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ContentMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContentMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContentMedias
     * const contentMedias = await prisma.contentMedia.findMany()
     * 
     * // Get first 10 ContentMedias
     * const contentMedias = await prisma.contentMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contentMediaWithIdOnly = await prisma.contentMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContentMediaFindManyArgs>(args?: SelectSubset<T, ContentMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContentMedia.
     * @param {ContentMediaCreateArgs} args - Arguments to create a ContentMedia.
     * @example
     * // Create one ContentMedia
     * const ContentMedia = await prisma.contentMedia.create({
     *   data: {
     *     // ... data to create a ContentMedia
     *   }
     * })
     * 
     */
    create<T extends ContentMediaCreateArgs>(args: SelectSubset<T, ContentMediaCreateArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContentMedias.
     * @param {ContentMediaCreateManyArgs} args - Arguments to create many ContentMedias.
     * @example
     * // Create many ContentMedias
     * const contentMedia = await prisma.contentMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContentMediaCreateManyArgs>(args?: SelectSubset<T, ContentMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContentMedias and returns the data saved in the database.
     * @param {ContentMediaCreateManyAndReturnArgs} args - Arguments to create many ContentMedias.
     * @example
     * // Create many ContentMedias
     * const contentMedia = await prisma.contentMedia.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContentMedias and only return the `id`
     * const contentMediaWithIdOnly = await prisma.contentMedia.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContentMediaCreateManyAndReturnArgs>(args?: SelectSubset<T, ContentMediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContentMedia.
     * @param {ContentMediaDeleteArgs} args - Arguments to delete one ContentMedia.
     * @example
     * // Delete one ContentMedia
     * const ContentMedia = await prisma.contentMedia.delete({
     *   where: {
     *     // ... filter to delete one ContentMedia
     *   }
     * })
     * 
     */
    delete<T extends ContentMediaDeleteArgs>(args: SelectSubset<T, ContentMediaDeleteArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContentMedia.
     * @param {ContentMediaUpdateArgs} args - Arguments to update one ContentMedia.
     * @example
     * // Update one ContentMedia
     * const contentMedia = await prisma.contentMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContentMediaUpdateArgs>(args: SelectSubset<T, ContentMediaUpdateArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContentMedias.
     * @param {ContentMediaDeleteManyArgs} args - Arguments to filter ContentMedias to delete.
     * @example
     * // Delete a few ContentMedias
     * const { count } = await prisma.contentMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContentMediaDeleteManyArgs>(args?: SelectSubset<T, ContentMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContentMedias
     * const contentMedia = await prisma.contentMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContentMediaUpdateManyArgs>(args: SelectSubset<T, ContentMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContentMedias and returns the data updated in the database.
     * @param {ContentMediaUpdateManyAndReturnArgs} args - Arguments to update many ContentMedias.
     * @example
     * // Update many ContentMedias
     * const contentMedia = await prisma.contentMedia.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContentMedias and only return the `id`
     * const contentMediaWithIdOnly = await prisma.contentMedia.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContentMediaUpdateManyAndReturnArgs>(args: SelectSubset<T, ContentMediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContentMedia.
     * @param {ContentMediaUpsertArgs} args - Arguments to update or create a ContentMedia.
     * @example
     * // Update or create a ContentMedia
     * const contentMedia = await prisma.contentMedia.upsert({
     *   create: {
     *     // ... data to create a ContentMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContentMedia we want to update
     *   }
     * })
     */
    upsert<T extends ContentMediaUpsertArgs>(args: SelectSubset<T, ContentMediaUpsertArgs<ExtArgs>>): Prisma__ContentMediaClient<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContentMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaCountArgs} args - Arguments to filter ContentMedias to count.
     * @example
     * // Count the number of ContentMedias
     * const count = await prisma.contentMedia.count({
     *   where: {
     *     // ... the filter for the ContentMedias we want to count
     *   }
     * })
    **/
    count<T extends ContentMediaCountArgs>(
      args?: Subset<T, ContentMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContentMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContentMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContentMediaAggregateArgs>(args: Subset<T, ContentMediaAggregateArgs>): Prisma.PrismaPromise<GetContentMediaAggregateType<T>>

    /**
     * Group by ContentMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContentMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContentMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContentMediaGroupByArgs['orderBy'] }
        : { orderBy?: ContentMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContentMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContentMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContentMedia model
   */
  readonly fields: ContentMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContentMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContentMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends ContentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContentDefaultArgs<ExtArgs>>): Prisma__ContentClient<$Result.GetResult<Prisma.$ContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    media<T extends MediaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MediaDefaultArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContentMedia model
   */
  interface ContentMediaFieldRefs {
    readonly id: FieldRef<"ContentMedia", 'String'>
    readonly contentId: FieldRef<"ContentMedia", 'String'>
    readonly mediaId: FieldRef<"ContentMedia", 'String'>
    readonly order: FieldRef<"ContentMedia", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ContentMedia findUnique
   */
  export type ContentMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentMedia to fetch.
     */
    where: ContentMediaWhereUniqueInput
  }

  /**
   * ContentMedia findUniqueOrThrow
   */
  export type ContentMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentMedia to fetch.
     */
    where: ContentMediaWhereUniqueInput
  }

  /**
   * ContentMedia findFirst
   */
  export type ContentMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentMedia to fetch.
     */
    where?: ContentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentMedias to fetch.
     */
    orderBy?: ContentMediaOrderByWithRelationInput | ContentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentMedias.
     */
    cursor?: ContentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentMedias.
     */
    distinct?: ContentMediaScalarFieldEnum | ContentMediaScalarFieldEnum[]
  }

  /**
   * ContentMedia findFirstOrThrow
   */
  export type ContentMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentMedia to fetch.
     */
    where?: ContentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentMedias to fetch.
     */
    orderBy?: ContentMediaOrderByWithRelationInput | ContentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContentMedias.
     */
    cursor?: ContentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContentMedias.
     */
    distinct?: ContentMediaScalarFieldEnum | ContentMediaScalarFieldEnum[]
  }

  /**
   * ContentMedia findMany
   */
  export type ContentMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * Filter, which ContentMedias to fetch.
     */
    where?: ContentMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContentMedias to fetch.
     */
    orderBy?: ContentMediaOrderByWithRelationInput | ContentMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContentMedias.
     */
    cursor?: ContentMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContentMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContentMedias.
     */
    skip?: number
    distinct?: ContentMediaScalarFieldEnum | ContentMediaScalarFieldEnum[]
  }

  /**
   * ContentMedia create
   */
  export type ContentMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ContentMedia.
     */
    data: XOR<ContentMediaCreateInput, ContentMediaUncheckedCreateInput>
  }

  /**
   * ContentMedia createMany
   */
  export type ContentMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContentMedias.
     */
    data: ContentMediaCreateManyInput | ContentMediaCreateManyInput[]
  }

  /**
   * ContentMedia createManyAndReturn
   */
  export type ContentMediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * The data used to create many ContentMedias.
     */
    data: ContentMediaCreateManyInput | ContentMediaCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentMedia update
   */
  export type ContentMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ContentMedia.
     */
    data: XOR<ContentMediaUpdateInput, ContentMediaUncheckedUpdateInput>
    /**
     * Choose, which ContentMedia to update.
     */
    where: ContentMediaWhereUniqueInput
  }

  /**
   * ContentMedia updateMany
   */
  export type ContentMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContentMedias.
     */
    data: XOR<ContentMediaUpdateManyMutationInput, ContentMediaUncheckedUpdateManyInput>
    /**
     * Filter which ContentMedias to update
     */
    where?: ContentMediaWhereInput
    /**
     * Limit how many ContentMedias to update.
     */
    limit?: number
  }

  /**
   * ContentMedia updateManyAndReturn
   */
  export type ContentMediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * The data used to update ContentMedias.
     */
    data: XOR<ContentMediaUpdateManyMutationInput, ContentMediaUncheckedUpdateManyInput>
    /**
     * Filter which ContentMedias to update
     */
    where?: ContentMediaWhereInput
    /**
     * Limit how many ContentMedias to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContentMedia upsert
   */
  export type ContentMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ContentMedia to update in case it exists.
     */
    where: ContentMediaWhereUniqueInput
    /**
     * In case the ContentMedia found by the `where` argument doesn't exist, create a new ContentMedia with this data.
     */
    create: XOR<ContentMediaCreateInput, ContentMediaUncheckedCreateInput>
    /**
     * In case the ContentMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContentMediaUpdateInput, ContentMediaUncheckedUpdateInput>
  }

  /**
   * ContentMedia delete
   */
  export type ContentMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    /**
     * Filter which ContentMedia to delete.
     */
    where: ContentMediaWhereUniqueInput
  }

  /**
   * ContentMedia deleteMany
   */
  export type ContentMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContentMedias to delete
     */
    where?: ContentMediaWhereInput
    /**
     * Limit how many ContentMedias to delete.
     */
    limit?: number
  }

  /**
   * ContentMedia without action
   */
  export type ContentMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
  }


  /**
   * Model Media
   */

  export type AggregateMedia = {
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  export type MediaAvgAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type MediaSumAggregateOutputType = {
    size: number | null
    width: number | null
    height: number | null
  }

  export type MediaMinAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    url: string | null
    thumbnailUrl: string | null
    category: $Enums.MediaCategory | null
    altTextGr: string | null
    altTextEn: string | null
    mimeType: string | null
    size: number | null
    width: number | null
    height: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaMaxAggregateOutputType = {
    id: string | null
    filename: string | null
    originalName: string | null
    url: string | null
    thumbnailUrl: string | null
    category: $Enums.MediaCategory | null
    altTextGr: string | null
    altTextEn: string | null
    mimeType: string | null
    size: number | null
    width: number | null
    height: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MediaCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    url: number
    thumbnailUrl: number
    category: number
    altTextGr: number
    altTextEn: number
    mimeType: number
    size: number
    width: number
    height: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MediaAvgAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type MediaSumAggregateInputType = {
    size?: true
    width?: true
    height?: true
  }

  export type MediaMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    url?: true
    thumbnailUrl?: true
    category?: true
    altTextGr?: true
    altTextEn?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    url?: true
    thumbnailUrl?: true
    category?: true
    altTextGr?: true
    altTextEn?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MediaCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    url?: true
    thumbnailUrl?: true
    category?: true
    altTextGr?: true
    altTextEn?: true
    mimeType?: true
    size?: true
    width?: true
    height?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to aggregate.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Media
    **/
    _count?: true | MediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaMaxAggregateInputType
  }

  export type GetMediaAggregateType<T extends MediaAggregateArgs> = {
        [P in keyof T & keyof AggregateMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedia[P]>
      : GetScalarType<T[P], AggregateMedia[P]>
  }




  export type MediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaWhereInput
    orderBy?: MediaOrderByWithAggregationInput | MediaOrderByWithAggregationInput[]
    by: MediaScalarFieldEnum[] | MediaScalarFieldEnum
    having?: MediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaCountAggregateInputType | true
    _avg?: MediaAvgAggregateInputType
    _sum?: MediaSumAggregateInputType
    _min?: MediaMinAggregateInputType
    _max?: MediaMaxAggregateInputType
  }

  export type MediaGroupByOutputType = {
    id: string
    filename: string
    originalName: string
    url: string
    thumbnailUrl: string | null
    category: $Enums.MediaCategory
    altTextGr: string | null
    altTextEn: string | null
    mimeType: string
    size: number
    width: number | null
    height: number | null
    createdAt: Date
    updatedAt: Date
    _count: MediaCountAggregateOutputType | null
    _avg: MediaAvgAggregateOutputType | null
    _sum: MediaSumAggregateOutputType | null
    _min: MediaMinAggregateOutputType | null
    _max: MediaMaxAggregateOutputType | null
  }

  type GetMediaGroupByPayload<T extends MediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaGroupByOutputType[P]>
            : GetScalarType<T[P], MediaGroupByOutputType[P]>
        }
      >
    >


  export type MediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    category?: boolean
    altTextGr?: boolean
    altTextEn?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    content?: boolean | Media$contentArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["media"]>

  export type MediaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    category?: boolean
    altTextGr?: boolean
    altTextEn?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    category?: boolean
    altTextGr?: boolean
    altTextEn?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["media"]>

  export type MediaSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    url?: boolean
    thumbnailUrl?: boolean
    category?: boolean
    altTextGr?: boolean
    altTextEn?: boolean
    mimeType?: boolean
    size?: boolean
    width?: boolean
    height?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "url" | "thumbnailUrl" | "category" | "altTextGr" | "altTextEn" | "mimeType" | "size" | "width" | "height" | "createdAt" | "updatedAt", ExtArgs["result"]["media"]>
  export type MediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    content?: boolean | Media$contentArgs<ExtArgs>
    _count?: boolean | MediaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MediaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type MediaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Media"
    objects: {
      content: Prisma.$ContentMediaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      filename: string
      originalName: string
      url: string
      thumbnailUrl: string | null
      category: $Enums.MediaCategory
      altTextGr: string | null
      altTextEn: string | null
      mimeType: string
      size: number
      width: number | null
      height: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["media"]>
    composites: {}
  }

  type MediaGetPayload<S extends boolean | null | undefined | MediaDefaultArgs> = $Result.GetResult<Prisma.$MediaPayload, S>

  type MediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaCountAggregateInputType | true
    }

  export interface MediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Media'], meta: { name: 'Media' } }
    /**
     * Find zero or one Media that matches the filter.
     * @param {MediaFindUniqueArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFindUniqueArgs>(args: SelectSubset<T, MediaFindUniqueArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Media that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFindUniqueOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFindFirstArgs>(args?: SelectSubset<T, MediaFindFirstArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Media that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindFirstOrThrowArgs} args - Arguments to find a Media
     * @example
     * // Get one Media
     * const media = await prisma.media.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Media that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Media
     * const media = await prisma.media.findMany()
     * 
     * // Get first 10 Media
     * const media = await prisma.media.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaWithIdOnly = await prisma.media.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFindManyArgs>(args?: SelectSubset<T, MediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Media.
     * @param {MediaCreateArgs} args - Arguments to create a Media.
     * @example
     * // Create one Media
     * const Media = await prisma.media.create({
     *   data: {
     *     // ... data to create a Media
     *   }
     * })
     * 
     */
    create<T extends MediaCreateArgs>(args: SelectSubset<T, MediaCreateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Media.
     * @param {MediaCreateManyArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaCreateManyArgs>(args?: SelectSubset<T, MediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Media and returns the data saved in the database.
     * @param {MediaCreateManyAndReturnArgs} args - Arguments to create many Media.
     * @example
     * // Create many Media
     * const media = await prisma.media.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Media.
     * @param {MediaDeleteArgs} args - Arguments to delete one Media.
     * @example
     * // Delete one Media
     * const Media = await prisma.media.delete({
     *   where: {
     *     // ... filter to delete one Media
     *   }
     * })
     * 
     */
    delete<T extends MediaDeleteArgs>(args: SelectSubset<T, MediaDeleteArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Media.
     * @param {MediaUpdateArgs} args - Arguments to update one Media.
     * @example
     * // Update one Media
     * const media = await prisma.media.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaUpdateArgs>(args: SelectSubset<T, MediaUpdateArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Media.
     * @param {MediaDeleteManyArgs} args - Arguments to filter Media to delete.
     * @example
     * // Delete a few Media
     * const { count } = await prisma.media.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaDeleteManyArgs>(args?: SelectSubset<T, MediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaUpdateManyArgs>(args: SelectSubset<T, MediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Media and returns the data updated in the database.
     * @param {MediaUpdateManyAndReturnArgs} args - Arguments to update many Media.
     * @example
     * // Update many Media
     * const media = await prisma.media.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Media and only return the `id`
     * const mediaWithIdOnly = await prisma.media.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Media.
     * @param {MediaUpsertArgs} args - Arguments to update or create a Media.
     * @example
     * // Update or create a Media
     * const media = await prisma.media.upsert({
     *   create: {
     *     // ... data to create a Media
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Media we want to update
     *   }
     * })
     */
    upsert<T extends MediaUpsertArgs>(args: SelectSubset<T, MediaUpsertArgs<ExtArgs>>): Prisma__MediaClient<$Result.GetResult<Prisma.$MediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaCountArgs} args - Arguments to filter Media to count.
     * @example
     * // Count the number of Media
     * const count = await prisma.media.count({
     *   where: {
     *     // ... the filter for the Media we want to count
     *   }
     * })
    **/
    count<T extends MediaCountArgs>(
      args?: Subset<T, MediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaAggregateArgs>(args: Subset<T, MediaAggregateArgs>): Prisma.PrismaPromise<GetMediaAggregateType<T>>

    /**
     * Group by Media.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaGroupByArgs['orderBy'] }
        : { orderBy?: MediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Media model
   */
  readonly fields: MediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Media.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    content<T extends Media$contentArgs<ExtArgs> = {}>(args?: Subset<T, Media$contentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContentMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Media model
   */
  interface MediaFieldRefs {
    readonly id: FieldRef<"Media", 'String'>
    readonly filename: FieldRef<"Media", 'String'>
    readonly originalName: FieldRef<"Media", 'String'>
    readonly url: FieldRef<"Media", 'String'>
    readonly thumbnailUrl: FieldRef<"Media", 'String'>
    readonly category: FieldRef<"Media", 'MediaCategory'>
    readonly altTextGr: FieldRef<"Media", 'String'>
    readonly altTextEn: FieldRef<"Media", 'String'>
    readonly mimeType: FieldRef<"Media", 'String'>
    readonly size: FieldRef<"Media", 'Int'>
    readonly width: FieldRef<"Media", 'Int'>
    readonly height: FieldRef<"Media", 'Int'>
    readonly createdAt: FieldRef<"Media", 'DateTime'>
    readonly updatedAt: FieldRef<"Media", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Media findUnique
   */
  export type MediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findUniqueOrThrow
   */
  export type MediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media findFirst
   */
  export type MediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findFirstOrThrow
   */
  export type MediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Media.
     */
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media findMany
   */
  export type MediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter, which Media to fetch.
     */
    where?: MediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Media to fetch.
     */
    orderBy?: MediaOrderByWithRelationInput | MediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Media.
     */
    cursor?: MediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Media from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Media.
     */
    skip?: number
    distinct?: MediaScalarFieldEnum | MediaScalarFieldEnum[]
  }

  /**
   * Media create
   */
  export type MediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to create a Media.
     */
    data: XOR<MediaCreateInput, MediaUncheckedCreateInput>
  }

  /**
   * Media createMany
   */
  export type MediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
  }

  /**
   * Media createManyAndReturn
   */
  export type MediaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to create many Media.
     */
    data: MediaCreateManyInput | MediaCreateManyInput[]
  }

  /**
   * Media update
   */
  export type MediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The data needed to update a Media.
     */
    data: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
    /**
     * Choose, which Media to update.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media updateMany
   */
  export type MediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media updateManyAndReturn
   */
  export type MediaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * The data used to update Media.
     */
    data: XOR<MediaUpdateManyMutationInput, MediaUncheckedUpdateManyInput>
    /**
     * Filter which Media to update
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to update.
     */
    limit?: number
  }

  /**
   * Media upsert
   */
  export type MediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * The filter to search for the Media to update in case it exists.
     */
    where: MediaWhereUniqueInput
    /**
     * In case the Media found by the `where` argument doesn't exist, create a new Media with this data.
     */
    create: XOR<MediaCreateInput, MediaUncheckedCreateInput>
    /**
     * In case the Media was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaUpdateInput, MediaUncheckedUpdateInput>
  }

  /**
   * Media delete
   */
  export type MediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
    /**
     * Filter which Media to delete.
     */
    where: MediaWhereUniqueInput
  }

  /**
   * Media deleteMany
   */
  export type MediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Media to delete
     */
    where?: MediaWhereInput
    /**
     * Limit how many Media to delete.
     */
    limit?: number
  }

  /**
   * Media.content
   */
  export type Media$contentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContentMedia
     */
    select?: ContentMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContentMedia
     */
    omit?: ContentMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContentMediaInclude<ExtArgs> | null
    where?: ContentMediaWhereInput
    orderBy?: ContentMediaOrderByWithRelationInput | ContentMediaOrderByWithRelationInput[]
    cursor?: ContentMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContentMediaScalarFieldEnum | ContentMediaScalarFieldEnum[]
  }

  /**
   * Media without action
   */
  export type MediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Media
     */
    select?: MediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Media
     */
    omit?: MediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: $Enums.SettingType | null
    group: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    type: $Enums.SettingType | null
    group: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    type: number
    group: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    group?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    group?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    type?: true
    group?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: string
    type: $Enums.SettingType
    group: string
    description: string | null
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    group?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    group?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    group?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    type?: boolean
    group?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SettingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "type" | "group" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["setting"]>

  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      type: $Enums.SettingType
      group: string
      description: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings and returns the data updated in the database.
     * @param {SettingUpdateManyAndReturnArgs} args - Arguments to update many Settings.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SettingUpdateManyAndReturnArgs>(args: SelectSubset<T, SettingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly type: FieldRef<"Setting", 'SettingType'>
    readonly group: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting updateManyAndReturn
   */
  export type SettingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to update.
     */
    limit?: number
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
    /**
     * Limit how many Settings to delete.
     */
    limit?: number
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Setting
     */
    omit?: SettingOmit<ExtArgs> | null
  }


  /**
   * Model RoomContent
   */

  export type AggregateRoomContent = {
    _count: RoomContentCountAggregateOutputType | null
    _min: RoomContentMinAggregateOutputType | null
    _max: RoomContentMaxAggregateOutputType | null
  }

  export type RoomContentMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    highlightsGr: string | null
    highlightsEn: string | null
    virtualTourUrl: string | null
    floorPlanUrl: string | null
    metaTitleGr: string | null
    metaTitleEn: string | null
    metaDescriptionGr: string | null
    metaDescriptionEn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomContentMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    highlightsGr: string | null
    highlightsEn: string | null
    virtualTourUrl: string | null
    floorPlanUrl: string | null
    metaTitleGr: string | null
    metaTitleEn: string | null
    metaDescriptionGr: string | null
    metaDescriptionEn: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomContentCountAggregateOutputType = {
    id: number
    roomId: number
    highlightsGr: number
    highlightsEn: number
    featuresGr: number
    featuresEn: number
    virtualTourUrl: number
    floorPlanUrl: number
    metaTitleGr: number
    metaTitleEn: number
    metaDescriptionGr: number
    metaDescriptionEn: number
    amenitiesDetails: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomContentMinAggregateInputType = {
    id?: true
    roomId?: true
    highlightsGr?: true
    highlightsEn?: true
    virtualTourUrl?: true
    floorPlanUrl?: true
    metaTitleGr?: true
    metaTitleEn?: true
    metaDescriptionGr?: true
    metaDescriptionEn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomContentMaxAggregateInputType = {
    id?: true
    roomId?: true
    highlightsGr?: true
    highlightsEn?: true
    virtualTourUrl?: true
    floorPlanUrl?: true
    metaTitleGr?: true
    metaTitleEn?: true
    metaDescriptionGr?: true
    metaDescriptionEn?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomContentCountAggregateInputType = {
    id?: true
    roomId?: true
    highlightsGr?: true
    highlightsEn?: true
    featuresGr?: true
    featuresEn?: true
    virtualTourUrl?: true
    floorPlanUrl?: true
    metaTitleGr?: true
    metaTitleEn?: true
    metaDescriptionGr?: true
    metaDescriptionEn?: true
    amenitiesDetails?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomContent to aggregate.
     */
    where?: RoomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomContents to fetch.
     */
    orderBy?: RoomContentOrderByWithRelationInput | RoomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomContents
    **/
    _count?: true | RoomContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomContentMaxAggregateInputType
  }

  export type GetRoomContentAggregateType<T extends RoomContentAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomContent[P]>
      : GetScalarType<T[P], AggregateRoomContent[P]>
  }




  export type RoomContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomContentWhereInput
    orderBy?: RoomContentOrderByWithAggregationInput | RoomContentOrderByWithAggregationInput[]
    by: RoomContentScalarFieldEnum[] | RoomContentScalarFieldEnum
    having?: RoomContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomContentCountAggregateInputType | true
    _min?: RoomContentMinAggregateInputType
    _max?: RoomContentMaxAggregateInputType
  }

  export type RoomContentGroupByOutputType = {
    id: string
    roomId: string
    highlightsGr: string | null
    highlightsEn: string | null
    featuresGr: JsonValue | null
    featuresEn: JsonValue | null
    virtualTourUrl: string | null
    floorPlanUrl: string | null
    metaTitleGr: string | null
    metaTitleEn: string | null
    metaDescriptionGr: string | null
    metaDescriptionEn: string | null
    amenitiesDetails: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: RoomContentCountAggregateOutputType | null
    _min: RoomContentMinAggregateOutputType | null
    _max: RoomContentMaxAggregateOutputType | null
  }

  type GetRoomContentGroupByPayload<T extends RoomContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomContentGroupByOutputType[P]>
            : GetScalarType<T[P], RoomContentGroupByOutputType[P]>
        }
      >
    >


  export type RoomContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    highlightsGr?: boolean
    highlightsEn?: boolean
    featuresGr?: boolean
    featuresEn?: boolean
    virtualTourUrl?: boolean
    floorPlanUrl?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    amenitiesDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomContent"]>

  export type RoomContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    highlightsGr?: boolean
    highlightsEn?: boolean
    featuresGr?: boolean
    featuresEn?: boolean
    virtualTourUrl?: boolean
    floorPlanUrl?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    amenitiesDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomContent"]>

  export type RoomContentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    highlightsGr?: boolean
    highlightsEn?: boolean
    featuresGr?: boolean
    featuresEn?: boolean
    virtualTourUrl?: boolean
    floorPlanUrl?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    amenitiesDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomContent"]>

  export type RoomContentSelectScalar = {
    id?: boolean
    roomId?: boolean
    highlightsGr?: boolean
    highlightsEn?: boolean
    featuresGr?: boolean
    featuresEn?: boolean
    virtualTourUrl?: boolean
    floorPlanUrl?: boolean
    metaTitleGr?: boolean
    metaTitleEn?: boolean
    metaDescriptionGr?: boolean
    metaDescriptionEn?: boolean
    amenitiesDetails?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomContentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "highlightsGr" | "highlightsEn" | "featuresGr" | "featuresEn" | "virtualTourUrl" | "floorPlanUrl" | "metaTitleGr" | "metaTitleEn" | "metaDescriptionGr" | "metaDescriptionEn" | "amenitiesDetails" | "createdAt" | "updatedAt", ExtArgs["result"]["roomContent"]>
  export type RoomContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type RoomContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type RoomContentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $RoomContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomContent"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      highlightsGr: string | null
      highlightsEn: string | null
      featuresGr: Prisma.JsonValue | null
      featuresEn: Prisma.JsonValue | null
      virtualTourUrl: string | null
      floorPlanUrl: string | null
      metaTitleGr: string | null
      metaTitleEn: string | null
      metaDescriptionGr: string | null
      metaDescriptionEn: string | null
      amenitiesDetails: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomContent"]>
    composites: {}
  }

  type RoomContentGetPayload<S extends boolean | null | undefined | RoomContentDefaultArgs> = $Result.GetResult<Prisma.$RoomContentPayload, S>

  type RoomContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomContentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomContentCountAggregateInputType | true
    }

  export interface RoomContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomContent'], meta: { name: 'RoomContent' } }
    /**
     * Find zero or one RoomContent that matches the filter.
     * @param {RoomContentFindUniqueArgs} args - Arguments to find a RoomContent
     * @example
     * // Get one RoomContent
     * const roomContent = await prisma.roomContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomContentFindUniqueArgs>(args: SelectSubset<T, RoomContentFindUniqueArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomContent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomContentFindUniqueOrThrowArgs} args - Arguments to find a RoomContent
     * @example
     * // Get one RoomContent
     * const roomContent = await prisma.roomContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomContentFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentFindFirstArgs} args - Arguments to find a RoomContent
     * @example
     * // Get one RoomContent
     * const roomContent = await prisma.roomContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomContentFindFirstArgs>(args?: SelectSubset<T, RoomContentFindFirstArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentFindFirstOrThrowArgs} args - Arguments to find a RoomContent
     * @example
     * // Get one RoomContent
     * const roomContent = await prisma.roomContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomContentFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomContents
     * const roomContents = await prisma.roomContent.findMany()
     * 
     * // Get first 10 RoomContents
     * const roomContents = await prisma.roomContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomContentWithIdOnly = await prisma.roomContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomContentFindManyArgs>(args?: SelectSubset<T, RoomContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomContent.
     * @param {RoomContentCreateArgs} args - Arguments to create a RoomContent.
     * @example
     * // Create one RoomContent
     * const RoomContent = await prisma.roomContent.create({
     *   data: {
     *     // ... data to create a RoomContent
     *   }
     * })
     * 
     */
    create<T extends RoomContentCreateArgs>(args: SelectSubset<T, RoomContentCreateArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomContents.
     * @param {RoomContentCreateManyArgs} args - Arguments to create many RoomContents.
     * @example
     * // Create many RoomContents
     * const roomContent = await prisma.roomContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomContentCreateManyArgs>(args?: SelectSubset<T, RoomContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomContents and returns the data saved in the database.
     * @param {RoomContentCreateManyAndReturnArgs} args - Arguments to create many RoomContents.
     * @example
     * // Create many RoomContents
     * const roomContent = await prisma.roomContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomContents and only return the `id`
     * const roomContentWithIdOnly = await prisma.roomContent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomContentCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomContent.
     * @param {RoomContentDeleteArgs} args - Arguments to delete one RoomContent.
     * @example
     * // Delete one RoomContent
     * const RoomContent = await prisma.roomContent.delete({
     *   where: {
     *     // ... filter to delete one RoomContent
     *   }
     * })
     * 
     */
    delete<T extends RoomContentDeleteArgs>(args: SelectSubset<T, RoomContentDeleteArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomContent.
     * @param {RoomContentUpdateArgs} args - Arguments to update one RoomContent.
     * @example
     * // Update one RoomContent
     * const roomContent = await prisma.roomContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomContentUpdateArgs>(args: SelectSubset<T, RoomContentUpdateArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomContents.
     * @param {RoomContentDeleteManyArgs} args - Arguments to filter RoomContents to delete.
     * @example
     * // Delete a few RoomContents
     * const { count } = await prisma.roomContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomContentDeleteManyArgs>(args?: SelectSubset<T, RoomContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomContents
     * const roomContent = await prisma.roomContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomContentUpdateManyArgs>(args: SelectSubset<T, RoomContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomContents and returns the data updated in the database.
     * @param {RoomContentUpdateManyAndReturnArgs} args - Arguments to update many RoomContents.
     * @example
     * // Update many RoomContents
     * const roomContent = await prisma.roomContent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomContents and only return the `id`
     * const roomContentWithIdOnly = await prisma.roomContent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomContentUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomContentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomContent.
     * @param {RoomContentUpsertArgs} args - Arguments to update or create a RoomContent.
     * @example
     * // Update or create a RoomContent
     * const roomContent = await prisma.roomContent.upsert({
     *   create: {
     *     // ... data to create a RoomContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomContent we want to update
     *   }
     * })
     */
    upsert<T extends RoomContentUpsertArgs>(args: SelectSubset<T, RoomContentUpsertArgs<ExtArgs>>): Prisma__RoomContentClient<$Result.GetResult<Prisma.$RoomContentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentCountArgs} args - Arguments to filter RoomContents to count.
     * @example
     * // Count the number of RoomContents
     * const count = await prisma.roomContent.count({
     *   where: {
     *     // ... the filter for the RoomContents we want to count
     *   }
     * })
    **/
    count<T extends RoomContentCountArgs>(
      args?: Subset<T, RoomContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomContentAggregateArgs>(args: Subset<T, RoomContentAggregateArgs>): Prisma.PrismaPromise<GetRoomContentAggregateType<T>>

    /**
     * Group by RoomContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomContentGroupByArgs['orderBy'] }
        : { orderBy?: RoomContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomContent model
   */
  readonly fields: RoomContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomContent model
   */
  interface RoomContentFieldRefs {
    readonly id: FieldRef<"RoomContent", 'String'>
    readonly roomId: FieldRef<"RoomContent", 'String'>
    readonly highlightsGr: FieldRef<"RoomContent", 'String'>
    readonly highlightsEn: FieldRef<"RoomContent", 'String'>
    readonly featuresGr: FieldRef<"RoomContent", 'Json'>
    readonly featuresEn: FieldRef<"RoomContent", 'Json'>
    readonly virtualTourUrl: FieldRef<"RoomContent", 'String'>
    readonly floorPlanUrl: FieldRef<"RoomContent", 'String'>
    readonly metaTitleGr: FieldRef<"RoomContent", 'String'>
    readonly metaTitleEn: FieldRef<"RoomContent", 'String'>
    readonly metaDescriptionGr: FieldRef<"RoomContent", 'String'>
    readonly metaDescriptionEn: FieldRef<"RoomContent", 'String'>
    readonly amenitiesDetails: FieldRef<"RoomContent", 'Json'>
    readonly createdAt: FieldRef<"RoomContent", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomContent findUnique
   */
  export type RoomContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * Filter, which RoomContent to fetch.
     */
    where: RoomContentWhereUniqueInput
  }

  /**
   * RoomContent findUniqueOrThrow
   */
  export type RoomContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * Filter, which RoomContent to fetch.
     */
    where: RoomContentWhereUniqueInput
  }

  /**
   * RoomContent findFirst
   */
  export type RoomContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * Filter, which RoomContent to fetch.
     */
    where?: RoomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomContents to fetch.
     */
    orderBy?: RoomContentOrderByWithRelationInput | RoomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomContents.
     */
    cursor?: RoomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomContents.
     */
    distinct?: RoomContentScalarFieldEnum | RoomContentScalarFieldEnum[]
  }

  /**
   * RoomContent findFirstOrThrow
   */
  export type RoomContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * Filter, which RoomContent to fetch.
     */
    where?: RoomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomContents to fetch.
     */
    orderBy?: RoomContentOrderByWithRelationInput | RoomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomContents.
     */
    cursor?: RoomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomContents.
     */
    distinct?: RoomContentScalarFieldEnum | RoomContentScalarFieldEnum[]
  }

  /**
   * RoomContent findMany
   */
  export type RoomContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * Filter, which RoomContents to fetch.
     */
    where?: RoomContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomContents to fetch.
     */
    orderBy?: RoomContentOrderByWithRelationInput | RoomContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomContents.
     */
    cursor?: RoomContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomContents.
     */
    skip?: number
    distinct?: RoomContentScalarFieldEnum | RoomContentScalarFieldEnum[]
  }

  /**
   * RoomContent create
   */
  export type RoomContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomContent.
     */
    data: XOR<RoomContentCreateInput, RoomContentUncheckedCreateInput>
  }

  /**
   * RoomContent createMany
   */
  export type RoomContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomContents.
     */
    data: RoomContentCreateManyInput | RoomContentCreateManyInput[]
  }

  /**
   * RoomContent createManyAndReturn
   */
  export type RoomContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * The data used to create many RoomContents.
     */
    data: RoomContentCreateManyInput | RoomContentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomContent update
   */
  export type RoomContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomContent.
     */
    data: XOR<RoomContentUpdateInput, RoomContentUncheckedUpdateInput>
    /**
     * Choose, which RoomContent to update.
     */
    where: RoomContentWhereUniqueInput
  }

  /**
   * RoomContent updateMany
   */
  export type RoomContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomContents.
     */
    data: XOR<RoomContentUpdateManyMutationInput, RoomContentUncheckedUpdateManyInput>
    /**
     * Filter which RoomContents to update
     */
    where?: RoomContentWhereInput
    /**
     * Limit how many RoomContents to update.
     */
    limit?: number
  }

  /**
   * RoomContent updateManyAndReturn
   */
  export type RoomContentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * The data used to update RoomContents.
     */
    data: XOR<RoomContentUpdateManyMutationInput, RoomContentUncheckedUpdateManyInput>
    /**
     * Filter which RoomContents to update
     */
    where?: RoomContentWhereInput
    /**
     * Limit how many RoomContents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomContent upsert
   */
  export type RoomContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomContent to update in case it exists.
     */
    where: RoomContentWhereUniqueInput
    /**
     * In case the RoomContent found by the `where` argument doesn't exist, create a new RoomContent with this data.
     */
    create: XOR<RoomContentCreateInput, RoomContentUncheckedCreateInput>
    /**
     * In case the RoomContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomContentUpdateInput, RoomContentUncheckedUpdateInput>
  }

  /**
   * RoomContent delete
   */
  export type RoomContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
    /**
     * Filter which RoomContent to delete.
     */
    where: RoomContentWhereUniqueInput
  }

  /**
   * RoomContent deleteMany
   */
  export type RoomContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomContents to delete
     */
    where?: RoomContentWhereInput
    /**
     * Limit how many RoomContents to delete.
     */
    limit?: number
  }

  /**
   * RoomContent without action
   */
  export type RoomContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomContent
     */
    select?: RoomContentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomContent
     */
    omit?: RoomContentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomContentInclude<ExtArgs> | null
  }


  /**
   * Model RoomAvailabilityRule
   */

  export type AggregateRoomAvailabilityRule = {
    _count: RoomAvailabilityRuleCountAggregateOutputType | null
    _avg: RoomAvailabilityRuleAvgAggregateOutputType | null
    _sum: RoomAvailabilityRuleSumAggregateOutputType | null
    _min: RoomAvailabilityRuleMinAggregateOutputType | null
    _max: RoomAvailabilityRuleMaxAggregateOutputType | null
  }

  export type RoomAvailabilityRuleAvgAggregateOutputType = {
    priceOverride: number | null
    minStayOverride: number | null
  }

  export type RoomAvailabilityRuleSumAggregateOutputType = {
    priceOverride: number | null
    minStayOverride: number | null
  }

  export type RoomAvailabilityRuleMinAggregateOutputType = {
    id: string | null
    roomId: string | null
    startDate: Date | null
    endDate: Date | null
    isAvailable: boolean | null
    reason: string | null
    priceOverride: number | null
    minStayOverride: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomAvailabilityRuleMaxAggregateOutputType = {
    id: string | null
    roomId: string | null
    startDate: Date | null
    endDate: Date | null
    isAvailable: boolean | null
    reason: string | null
    priceOverride: number | null
    minStayOverride: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoomAvailabilityRuleCountAggregateOutputType = {
    id: number
    roomId: number
    startDate: number
    endDate: number
    isAvailable: number
    reason: number
    priceOverride: number
    minStayOverride: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoomAvailabilityRuleAvgAggregateInputType = {
    priceOverride?: true
    minStayOverride?: true
  }

  export type RoomAvailabilityRuleSumAggregateInputType = {
    priceOverride?: true
    minStayOverride?: true
  }

  export type RoomAvailabilityRuleMinAggregateInputType = {
    id?: true
    roomId?: true
    startDate?: true
    endDate?: true
    isAvailable?: true
    reason?: true
    priceOverride?: true
    minStayOverride?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomAvailabilityRuleMaxAggregateInputType = {
    id?: true
    roomId?: true
    startDate?: true
    endDate?: true
    isAvailable?: true
    reason?: true
    priceOverride?: true
    minStayOverride?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoomAvailabilityRuleCountAggregateInputType = {
    id?: true
    roomId?: true
    startDate?: true
    endDate?: true
    isAvailable?: true
    reason?: true
    priceOverride?: true
    minStayOverride?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoomAvailabilityRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAvailabilityRule to aggregate.
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAvailabilityRules to fetch.
     */
    orderBy?: RoomAvailabilityRuleOrderByWithRelationInput | RoomAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAvailabilityRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoomAvailabilityRules
    **/
    _count?: true | RoomAvailabilityRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvailabilityRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomAvailabilityRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomAvailabilityRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomAvailabilityRuleMaxAggregateInputType
  }

  export type GetRoomAvailabilityRuleAggregateType<T extends RoomAvailabilityRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateRoomAvailabilityRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoomAvailabilityRule[P]>
      : GetScalarType<T[P], AggregateRoomAvailabilityRule[P]>
  }




  export type RoomAvailabilityRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomAvailabilityRuleWhereInput
    orderBy?: RoomAvailabilityRuleOrderByWithAggregationInput | RoomAvailabilityRuleOrderByWithAggregationInput[]
    by: RoomAvailabilityRuleScalarFieldEnum[] | RoomAvailabilityRuleScalarFieldEnum
    having?: RoomAvailabilityRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomAvailabilityRuleCountAggregateInputType | true
    _avg?: RoomAvailabilityRuleAvgAggregateInputType
    _sum?: RoomAvailabilityRuleSumAggregateInputType
    _min?: RoomAvailabilityRuleMinAggregateInputType
    _max?: RoomAvailabilityRuleMaxAggregateInputType
  }

  export type RoomAvailabilityRuleGroupByOutputType = {
    id: string
    roomId: string
    startDate: Date
    endDate: Date
    isAvailable: boolean
    reason: string | null
    priceOverride: number | null
    minStayOverride: number | null
    createdAt: Date
    updatedAt: Date
    _count: RoomAvailabilityRuleCountAggregateOutputType | null
    _avg: RoomAvailabilityRuleAvgAggregateOutputType | null
    _sum: RoomAvailabilityRuleSumAggregateOutputType | null
    _min: RoomAvailabilityRuleMinAggregateOutputType | null
    _max: RoomAvailabilityRuleMaxAggregateOutputType | null
  }

  type GetRoomAvailabilityRuleGroupByPayload<T extends RoomAvailabilityRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomAvailabilityRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomAvailabilityRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomAvailabilityRuleGroupByOutputType[P]>
            : GetScalarType<T[P], RoomAvailabilityRuleGroupByOutputType[P]>
        }
      >
    >


  export type RoomAvailabilityRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    startDate?: boolean
    endDate?: boolean
    isAvailable?: boolean
    reason?: boolean
    priceOverride?: boolean
    minStayOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAvailabilityRule"]>

  export type RoomAvailabilityRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    startDate?: boolean
    endDate?: boolean
    isAvailable?: boolean
    reason?: boolean
    priceOverride?: boolean
    minStayOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAvailabilityRule"]>

  export type RoomAvailabilityRuleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roomId?: boolean
    startDate?: boolean
    endDate?: boolean
    isAvailable?: boolean
    reason?: boolean
    priceOverride?: boolean
    minStayOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roomAvailabilityRule"]>

  export type RoomAvailabilityRuleSelectScalar = {
    id?: boolean
    roomId?: boolean
    startDate?: boolean
    endDate?: boolean
    isAvailable?: boolean
    reason?: boolean
    priceOverride?: boolean
    minStayOverride?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoomAvailabilityRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "roomId" | "startDate" | "endDate" | "isAvailable" | "reason" | "priceOverride" | "minStayOverride" | "createdAt" | "updatedAt", ExtArgs["result"]["roomAvailabilityRule"]>
  export type RoomAvailabilityRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type RoomAvailabilityRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }
  export type RoomAvailabilityRuleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    room?: boolean | RoomDefaultArgs<ExtArgs>
  }

  export type $RoomAvailabilityRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoomAvailabilityRule"
    objects: {
      room: Prisma.$RoomPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roomId: string
      startDate: Date
      endDate: Date
      isAvailable: boolean
      reason: string | null
      priceOverride: number | null
      minStayOverride: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["roomAvailabilityRule"]>
    composites: {}
  }

  type RoomAvailabilityRuleGetPayload<S extends boolean | null | undefined | RoomAvailabilityRuleDefaultArgs> = $Result.GetResult<Prisma.$RoomAvailabilityRulePayload, S>

  type RoomAvailabilityRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RoomAvailabilityRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RoomAvailabilityRuleCountAggregateInputType | true
    }

  export interface RoomAvailabilityRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoomAvailabilityRule'], meta: { name: 'RoomAvailabilityRule' } }
    /**
     * Find zero or one RoomAvailabilityRule that matches the filter.
     * @param {RoomAvailabilityRuleFindUniqueArgs} args - Arguments to find a RoomAvailabilityRule
     * @example
     * // Get one RoomAvailabilityRule
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomAvailabilityRuleFindUniqueArgs>(args: SelectSubset<T, RoomAvailabilityRuleFindUniqueArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RoomAvailabilityRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RoomAvailabilityRuleFindUniqueOrThrowArgs} args - Arguments to find a RoomAvailabilityRule
     * @example
     * // Get one RoomAvailabilityRule
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomAvailabilityRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomAvailabilityRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAvailabilityRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleFindFirstArgs} args - Arguments to find a RoomAvailabilityRule
     * @example
     * // Get one RoomAvailabilityRule
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomAvailabilityRuleFindFirstArgs>(args?: SelectSubset<T, RoomAvailabilityRuleFindFirstArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RoomAvailabilityRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleFindFirstOrThrowArgs} args - Arguments to find a RoomAvailabilityRule
     * @example
     * // Get one RoomAvailabilityRule
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomAvailabilityRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomAvailabilityRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RoomAvailabilityRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoomAvailabilityRules
     * const roomAvailabilityRules = await prisma.roomAvailabilityRule.findMany()
     * 
     * // Get first 10 RoomAvailabilityRules
     * const roomAvailabilityRules = await prisma.roomAvailabilityRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomAvailabilityRuleWithIdOnly = await prisma.roomAvailabilityRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomAvailabilityRuleFindManyArgs>(args?: SelectSubset<T, RoomAvailabilityRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RoomAvailabilityRule.
     * @param {RoomAvailabilityRuleCreateArgs} args - Arguments to create a RoomAvailabilityRule.
     * @example
     * // Create one RoomAvailabilityRule
     * const RoomAvailabilityRule = await prisma.roomAvailabilityRule.create({
     *   data: {
     *     // ... data to create a RoomAvailabilityRule
     *   }
     * })
     * 
     */
    create<T extends RoomAvailabilityRuleCreateArgs>(args: SelectSubset<T, RoomAvailabilityRuleCreateArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RoomAvailabilityRules.
     * @param {RoomAvailabilityRuleCreateManyArgs} args - Arguments to create many RoomAvailabilityRules.
     * @example
     * // Create many RoomAvailabilityRules
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomAvailabilityRuleCreateManyArgs>(args?: SelectSubset<T, RoomAvailabilityRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoomAvailabilityRules and returns the data saved in the database.
     * @param {RoomAvailabilityRuleCreateManyAndReturnArgs} args - Arguments to create many RoomAvailabilityRules.
     * @example
     * // Create many RoomAvailabilityRules
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoomAvailabilityRules and only return the `id`
     * const roomAvailabilityRuleWithIdOnly = await prisma.roomAvailabilityRule.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomAvailabilityRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomAvailabilityRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RoomAvailabilityRule.
     * @param {RoomAvailabilityRuleDeleteArgs} args - Arguments to delete one RoomAvailabilityRule.
     * @example
     * // Delete one RoomAvailabilityRule
     * const RoomAvailabilityRule = await prisma.roomAvailabilityRule.delete({
     *   where: {
     *     // ... filter to delete one RoomAvailabilityRule
     *   }
     * })
     * 
     */
    delete<T extends RoomAvailabilityRuleDeleteArgs>(args: SelectSubset<T, RoomAvailabilityRuleDeleteArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RoomAvailabilityRule.
     * @param {RoomAvailabilityRuleUpdateArgs} args - Arguments to update one RoomAvailabilityRule.
     * @example
     * // Update one RoomAvailabilityRule
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomAvailabilityRuleUpdateArgs>(args: SelectSubset<T, RoomAvailabilityRuleUpdateArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RoomAvailabilityRules.
     * @param {RoomAvailabilityRuleDeleteManyArgs} args - Arguments to filter RoomAvailabilityRules to delete.
     * @example
     * // Delete a few RoomAvailabilityRules
     * const { count } = await prisma.roomAvailabilityRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomAvailabilityRuleDeleteManyArgs>(args?: SelectSubset<T, RoomAvailabilityRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAvailabilityRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoomAvailabilityRules
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomAvailabilityRuleUpdateManyArgs>(args: SelectSubset<T, RoomAvailabilityRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoomAvailabilityRules and returns the data updated in the database.
     * @param {RoomAvailabilityRuleUpdateManyAndReturnArgs} args - Arguments to update many RoomAvailabilityRules.
     * @example
     * // Update many RoomAvailabilityRules
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RoomAvailabilityRules and only return the `id`
     * const roomAvailabilityRuleWithIdOnly = await prisma.roomAvailabilityRule.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RoomAvailabilityRuleUpdateManyAndReturnArgs>(args: SelectSubset<T, RoomAvailabilityRuleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RoomAvailabilityRule.
     * @param {RoomAvailabilityRuleUpsertArgs} args - Arguments to update or create a RoomAvailabilityRule.
     * @example
     * // Update or create a RoomAvailabilityRule
     * const roomAvailabilityRule = await prisma.roomAvailabilityRule.upsert({
     *   create: {
     *     // ... data to create a RoomAvailabilityRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoomAvailabilityRule we want to update
     *   }
     * })
     */
    upsert<T extends RoomAvailabilityRuleUpsertArgs>(args: SelectSubset<T, RoomAvailabilityRuleUpsertArgs<ExtArgs>>): Prisma__RoomAvailabilityRuleClient<$Result.GetResult<Prisma.$RoomAvailabilityRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RoomAvailabilityRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleCountArgs} args - Arguments to filter RoomAvailabilityRules to count.
     * @example
     * // Count the number of RoomAvailabilityRules
     * const count = await prisma.roomAvailabilityRule.count({
     *   where: {
     *     // ... the filter for the RoomAvailabilityRules we want to count
     *   }
     * })
    **/
    count<T extends RoomAvailabilityRuleCountArgs>(
      args?: Subset<T, RoomAvailabilityRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomAvailabilityRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoomAvailabilityRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAvailabilityRuleAggregateArgs>(args: Subset<T, RoomAvailabilityRuleAggregateArgs>): Prisma.PrismaPromise<GetRoomAvailabilityRuleAggregateType<T>>

    /**
     * Group by RoomAvailabilityRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAvailabilityRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomAvailabilityRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomAvailabilityRuleGroupByArgs['orderBy'] }
        : { orderBy?: RoomAvailabilityRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomAvailabilityRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomAvailabilityRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoomAvailabilityRule model
   */
  readonly fields: RoomAvailabilityRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoomAvailabilityRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomAvailabilityRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    room<T extends RoomDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoomDefaultArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoomAvailabilityRule model
   */
  interface RoomAvailabilityRuleFieldRefs {
    readonly id: FieldRef<"RoomAvailabilityRule", 'String'>
    readonly roomId: FieldRef<"RoomAvailabilityRule", 'String'>
    readonly startDate: FieldRef<"RoomAvailabilityRule", 'DateTime'>
    readonly endDate: FieldRef<"RoomAvailabilityRule", 'DateTime'>
    readonly isAvailable: FieldRef<"RoomAvailabilityRule", 'Boolean'>
    readonly reason: FieldRef<"RoomAvailabilityRule", 'String'>
    readonly priceOverride: FieldRef<"RoomAvailabilityRule", 'Float'>
    readonly minStayOverride: FieldRef<"RoomAvailabilityRule", 'Int'>
    readonly createdAt: FieldRef<"RoomAvailabilityRule", 'DateTime'>
    readonly updatedAt: FieldRef<"RoomAvailabilityRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoomAvailabilityRule findUnique
   */
  export type RoomAvailabilityRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoomAvailabilityRule to fetch.
     */
    where: RoomAvailabilityRuleWhereUniqueInput
  }

  /**
   * RoomAvailabilityRule findUniqueOrThrow
   */
  export type RoomAvailabilityRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoomAvailabilityRule to fetch.
     */
    where: RoomAvailabilityRuleWhereUniqueInput
  }

  /**
   * RoomAvailabilityRule findFirst
   */
  export type RoomAvailabilityRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoomAvailabilityRule to fetch.
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAvailabilityRules to fetch.
     */
    orderBy?: RoomAvailabilityRuleOrderByWithRelationInput | RoomAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAvailabilityRules.
     */
    cursor?: RoomAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAvailabilityRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAvailabilityRules.
     */
    distinct?: RoomAvailabilityRuleScalarFieldEnum | RoomAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * RoomAvailabilityRule findFirstOrThrow
   */
  export type RoomAvailabilityRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoomAvailabilityRule to fetch.
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAvailabilityRules to fetch.
     */
    orderBy?: RoomAvailabilityRuleOrderByWithRelationInput | RoomAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoomAvailabilityRules.
     */
    cursor?: RoomAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAvailabilityRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoomAvailabilityRules.
     */
    distinct?: RoomAvailabilityRuleScalarFieldEnum | RoomAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * RoomAvailabilityRule findMany
   */
  export type RoomAvailabilityRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoomAvailabilityRules to fetch.
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoomAvailabilityRules to fetch.
     */
    orderBy?: RoomAvailabilityRuleOrderByWithRelationInput | RoomAvailabilityRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoomAvailabilityRules.
     */
    cursor?: RoomAvailabilityRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoomAvailabilityRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoomAvailabilityRules.
     */
    skip?: number
    distinct?: RoomAvailabilityRuleScalarFieldEnum | RoomAvailabilityRuleScalarFieldEnum[]
  }

  /**
   * RoomAvailabilityRule create
   */
  export type RoomAvailabilityRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a RoomAvailabilityRule.
     */
    data: XOR<RoomAvailabilityRuleCreateInput, RoomAvailabilityRuleUncheckedCreateInput>
  }

  /**
   * RoomAvailabilityRule createMany
   */
  export type RoomAvailabilityRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoomAvailabilityRules.
     */
    data: RoomAvailabilityRuleCreateManyInput | RoomAvailabilityRuleCreateManyInput[]
  }

  /**
   * RoomAvailabilityRule createManyAndReturn
   */
  export type RoomAvailabilityRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * The data used to create many RoomAvailabilityRules.
     */
    data: RoomAvailabilityRuleCreateManyInput | RoomAvailabilityRuleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomAvailabilityRule update
   */
  export type RoomAvailabilityRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a RoomAvailabilityRule.
     */
    data: XOR<RoomAvailabilityRuleUpdateInput, RoomAvailabilityRuleUncheckedUpdateInput>
    /**
     * Choose, which RoomAvailabilityRule to update.
     */
    where: RoomAvailabilityRuleWhereUniqueInput
  }

  /**
   * RoomAvailabilityRule updateMany
   */
  export type RoomAvailabilityRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoomAvailabilityRules.
     */
    data: XOR<RoomAvailabilityRuleUpdateManyMutationInput, RoomAvailabilityRuleUncheckedUpdateManyInput>
    /**
     * Filter which RoomAvailabilityRules to update
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * Limit how many RoomAvailabilityRules to update.
     */
    limit?: number
  }

  /**
   * RoomAvailabilityRule updateManyAndReturn
   */
  export type RoomAvailabilityRuleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * The data used to update RoomAvailabilityRules.
     */
    data: XOR<RoomAvailabilityRuleUpdateManyMutationInput, RoomAvailabilityRuleUncheckedUpdateManyInput>
    /**
     * Filter which RoomAvailabilityRules to update
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * Limit how many RoomAvailabilityRules to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoomAvailabilityRule upsert
   */
  export type RoomAvailabilityRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the RoomAvailabilityRule to update in case it exists.
     */
    where: RoomAvailabilityRuleWhereUniqueInput
    /**
     * In case the RoomAvailabilityRule found by the `where` argument doesn't exist, create a new RoomAvailabilityRule with this data.
     */
    create: XOR<RoomAvailabilityRuleCreateInput, RoomAvailabilityRuleUncheckedCreateInput>
    /**
     * In case the RoomAvailabilityRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomAvailabilityRuleUpdateInput, RoomAvailabilityRuleUncheckedUpdateInput>
  }

  /**
   * RoomAvailabilityRule delete
   */
  export type RoomAvailabilityRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
    /**
     * Filter which RoomAvailabilityRule to delete.
     */
    where: RoomAvailabilityRuleWhereUniqueInput
  }

  /**
   * RoomAvailabilityRule deleteMany
   */
  export type RoomAvailabilityRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoomAvailabilityRules to delete
     */
    where?: RoomAvailabilityRuleWhereInput
    /**
     * Limit how many RoomAvailabilityRules to delete.
     */
    limit?: number
  }

  /**
   * RoomAvailabilityRule without action
   */
  export type RoomAvailabilityRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoomAvailabilityRule
     */
    select?: RoomAvailabilityRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RoomAvailabilityRule
     */
    omit?: RoomAvailabilityRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomAvailabilityRuleInclude<ExtArgs> | null
  }


  /**
   * Model Inquiry
   */

  export type AggregateInquiry = {
    _count: InquiryCountAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  export type InquiryMinAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    email: string | null
    phone: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    priority: $Enums.InquiryPriority | null
    respondedAt: Date | null
    respondedBy: string | null
    response: string | null
    adminNotes: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InquiryMaxAggregateOutputType = {
    id: string | null
    propertyId: string | null
    name: string | null
    email: string | null
    phone: string | null
    message: string | null
    status: $Enums.InquiryStatus | null
    priority: $Enums.InquiryPriority | null
    respondedAt: Date | null
    respondedBy: string | null
    response: string | null
    adminNotes: string | null
    assignedTo: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InquiryCountAggregateOutputType = {
    id: number
    propertyId: number
    name: number
    email: number
    phone: number
    message: number
    status: number
    priority: number
    respondedAt: number
    respondedBy: number
    response: number
    adminNotes: number
    assignedTo: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InquiryMinAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    email?: true
    phone?: true
    message?: true
    status?: true
    priority?: true
    respondedAt?: true
    respondedBy?: true
    response?: true
    adminNotes?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InquiryMaxAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    email?: true
    phone?: true
    message?: true
    status?: true
    priority?: true
    respondedAt?: true
    respondedBy?: true
    response?: true
    adminNotes?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InquiryCountAggregateInputType = {
    id?: true
    propertyId?: true
    name?: true
    email?: true
    phone?: true
    message?: true
    status?: true
    priority?: true
    respondedAt?: true
    respondedBy?: true
    response?: true
    adminNotes?: true
    assignedTo?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InquiryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiry to aggregate.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Inquiries
    **/
    _count?: true | InquiryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InquiryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InquiryMaxAggregateInputType
  }

  export type GetInquiryAggregateType<T extends InquiryAggregateArgs> = {
        [P in keyof T & keyof AggregateInquiry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInquiry[P]>
      : GetScalarType<T[P], AggregateInquiry[P]>
  }




  export type InquiryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InquiryWhereInput
    orderBy?: InquiryOrderByWithAggregationInput | InquiryOrderByWithAggregationInput[]
    by: InquiryScalarFieldEnum[] | InquiryScalarFieldEnum
    having?: InquiryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InquiryCountAggregateInputType | true
    _min?: InquiryMinAggregateInputType
    _max?: InquiryMaxAggregateInputType
  }

  export type InquiryGroupByOutputType = {
    id: string
    propertyId: string
    name: string
    email: string
    phone: string | null
    message: string
    status: $Enums.InquiryStatus
    priority: $Enums.InquiryPriority
    respondedAt: Date | null
    respondedBy: string | null
    response: string | null
    adminNotes: string | null
    assignedTo: string | null
    createdAt: Date
    updatedAt: Date
    _count: InquiryCountAggregateOutputType | null
    _min: InquiryMinAggregateOutputType | null
    _max: InquiryMaxAggregateOutputType | null
  }

  type GetInquiryGroupByPayload<T extends InquiryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InquiryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InquiryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InquiryGroupByOutputType[P]>
            : GetScalarType<T[P], InquiryGroupByOutputType[P]>
        }
      >
    >


  export type InquirySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    response?: boolean
    adminNotes?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    assignee?: boolean | Inquiry$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    response?: boolean
    adminNotes?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    assignee?: boolean | Inquiry$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    propertyId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    response?: boolean
    adminNotes?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    assignee?: boolean | Inquiry$assigneeArgs<ExtArgs>
  }, ExtArgs["result"]["inquiry"]>

  export type InquirySelectScalar = {
    id?: boolean
    propertyId?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    message?: boolean
    status?: boolean
    priority?: boolean
    respondedAt?: boolean
    respondedBy?: boolean
    response?: boolean
    adminNotes?: boolean
    assignedTo?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InquiryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "propertyId" | "name" | "email" | "phone" | "message" | "status" | "priority" | "respondedAt" | "respondedBy" | "response" | "adminNotes" | "assignedTo" | "createdAt" | "updatedAt", ExtArgs["result"]["inquiry"]>
  export type InquiryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    assignee?: boolean | Inquiry$assigneeArgs<ExtArgs>
  }
  export type InquiryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    assignee?: boolean | Inquiry$assigneeArgs<ExtArgs>
  }
  export type InquiryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    property?: boolean | PropertyDefaultArgs<ExtArgs>
    assignee?: boolean | Inquiry$assigneeArgs<ExtArgs>
  }

  export type $InquiryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Inquiry"
    objects: {
      property: Prisma.$PropertyPayload<ExtArgs>
      assignee: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      propertyId: string
      name: string
      email: string
      phone: string | null
      message: string
      status: $Enums.InquiryStatus
      priority: $Enums.InquiryPriority
      respondedAt: Date | null
      respondedBy: string | null
      response: string | null
      adminNotes: string | null
      assignedTo: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inquiry"]>
    composites: {}
  }

  type InquiryGetPayload<S extends boolean | null | undefined | InquiryDefaultArgs> = $Result.GetResult<Prisma.$InquiryPayload, S>

  type InquiryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InquiryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InquiryCountAggregateInputType | true
    }

  export interface InquiryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Inquiry'], meta: { name: 'Inquiry' } }
    /**
     * Find zero or one Inquiry that matches the filter.
     * @param {InquiryFindUniqueArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InquiryFindUniqueArgs>(args: SelectSubset<T, InquiryFindUniqueArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Inquiry that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InquiryFindUniqueOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InquiryFindUniqueOrThrowArgs>(args: SelectSubset<T, InquiryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InquiryFindFirstArgs>(args?: SelectSubset<T, InquiryFindFirstArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Inquiry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindFirstOrThrowArgs} args - Arguments to find a Inquiry
     * @example
     * // Get one Inquiry
     * const inquiry = await prisma.inquiry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InquiryFindFirstOrThrowArgs>(args?: SelectSubset<T, InquiryFindFirstOrThrowArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Inquiries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Inquiries
     * const inquiries = await prisma.inquiry.findMany()
     * 
     * // Get first 10 Inquiries
     * const inquiries = await prisma.inquiry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InquiryFindManyArgs>(args?: SelectSubset<T, InquiryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Inquiry.
     * @param {InquiryCreateArgs} args - Arguments to create a Inquiry.
     * @example
     * // Create one Inquiry
     * const Inquiry = await prisma.inquiry.create({
     *   data: {
     *     // ... data to create a Inquiry
     *   }
     * })
     * 
     */
    create<T extends InquiryCreateArgs>(args: SelectSubset<T, InquiryCreateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Inquiries.
     * @param {InquiryCreateManyArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InquiryCreateManyArgs>(args?: SelectSubset<T, InquiryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Inquiries and returns the data saved in the database.
     * @param {InquiryCreateManyAndReturnArgs} args - Arguments to create many Inquiries.
     * @example
     * // Create many Inquiries
     * const inquiry = await prisma.inquiry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InquiryCreateManyAndReturnArgs>(args?: SelectSubset<T, InquiryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Inquiry.
     * @param {InquiryDeleteArgs} args - Arguments to delete one Inquiry.
     * @example
     * // Delete one Inquiry
     * const Inquiry = await prisma.inquiry.delete({
     *   where: {
     *     // ... filter to delete one Inquiry
     *   }
     * })
     * 
     */
    delete<T extends InquiryDeleteArgs>(args: SelectSubset<T, InquiryDeleteArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Inquiry.
     * @param {InquiryUpdateArgs} args - Arguments to update one Inquiry.
     * @example
     * // Update one Inquiry
     * const inquiry = await prisma.inquiry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InquiryUpdateArgs>(args: SelectSubset<T, InquiryUpdateArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Inquiries.
     * @param {InquiryDeleteManyArgs} args - Arguments to filter Inquiries to delete.
     * @example
     * // Delete a few Inquiries
     * const { count } = await prisma.inquiry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InquiryDeleteManyArgs>(args?: SelectSubset<T, InquiryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InquiryUpdateManyArgs>(args: SelectSubset<T, InquiryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Inquiries and returns the data updated in the database.
     * @param {InquiryUpdateManyAndReturnArgs} args - Arguments to update many Inquiries.
     * @example
     * // Update many Inquiries
     * const inquiry = await prisma.inquiry.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Inquiries and only return the `id`
     * const inquiryWithIdOnly = await prisma.inquiry.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InquiryUpdateManyAndReturnArgs>(args: SelectSubset<T, InquiryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Inquiry.
     * @param {InquiryUpsertArgs} args - Arguments to update or create a Inquiry.
     * @example
     * // Update or create a Inquiry
     * const inquiry = await prisma.inquiry.upsert({
     *   create: {
     *     // ... data to create a Inquiry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Inquiry we want to update
     *   }
     * })
     */
    upsert<T extends InquiryUpsertArgs>(args: SelectSubset<T, InquiryUpsertArgs<ExtArgs>>): Prisma__InquiryClient<$Result.GetResult<Prisma.$InquiryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Inquiries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryCountArgs} args - Arguments to filter Inquiries to count.
     * @example
     * // Count the number of Inquiries
     * const count = await prisma.inquiry.count({
     *   where: {
     *     // ... the filter for the Inquiries we want to count
     *   }
     * })
    **/
    count<T extends InquiryCountArgs>(
      args?: Subset<T, InquiryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InquiryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InquiryAggregateArgs>(args: Subset<T, InquiryAggregateArgs>): Prisma.PrismaPromise<GetInquiryAggregateType<T>>

    /**
     * Group by Inquiry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InquiryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InquiryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InquiryGroupByArgs['orderBy'] }
        : { orderBy?: InquiryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InquiryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInquiryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Inquiry model
   */
  readonly fields: InquiryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Inquiry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InquiryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    property<T extends PropertyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PropertyDefaultArgs<ExtArgs>>): Prisma__PropertyClient<$Result.GetResult<Prisma.$PropertyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    assignee<T extends Inquiry$assigneeArgs<ExtArgs> = {}>(args?: Subset<T, Inquiry$assigneeArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Inquiry model
   */
  interface InquiryFieldRefs {
    readonly id: FieldRef<"Inquiry", 'String'>
    readonly propertyId: FieldRef<"Inquiry", 'String'>
    readonly name: FieldRef<"Inquiry", 'String'>
    readonly email: FieldRef<"Inquiry", 'String'>
    readonly phone: FieldRef<"Inquiry", 'String'>
    readonly message: FieldRef<"Inquiry", 'String'>
    readonly status: FieldRef<"Inquiry", 'InquiryStatus'>
    readonly priority: FieldRef<"Inquiry", 'InquiryPriority'>
    readonly respondedAt: FieldRef<"Inquiry", 'DateTime'>
    readonly respondedBy: FieldRef<"Inquiry", 'String'>
    readonly response: FieldRef<"Inquiry", 'String'>
    readonly adminNotes: FieldRef<"Inquiry", 'String'>
    readonly assignedTo: FieldRef<"Inquiry", 'String'>
    readonly createdAt: FieldRef<"Inquiry", 'DateTime'>
    readonly updatedAt: FieldRef<"Inquiry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Inquiry findUnique
   */
  export type InquiryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findUniqueOrThrow
   */
  export type InquiryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry findFirst
   */
  export type InquiryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findFirstOrThrow
   */
  export type InquiryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiry to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Inquiries.
     */
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry findMany
   */
  export type InquiryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter, which Inquiries to fetch.
     */
    where?: InquiryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Inquiries to fetch.
     */
    orderBy?: InquiryOrderByWithRelationInput | InquiryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Inquiries.
     */
    cursor?: InquiryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Inquiries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Inquiries.
     */
    skip?: number
    distinct?: InquiryScalarFieldEnum | InquiryScalarFieldEnum[]
  }

  /**
   * Inquiry create
   */
  export type InquiryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to create a Inquiry.
     */
    data: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
  }

  /**
   * Inquiry createMany
   */
  export type InquiryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
  }

  /**
   * Inquiry createManyAndReturn
   */
  export type InquiryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * The data used to create many Inquiries.
     */
    data: InquiryCreateManyInput | InquiryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inquiry update
   */
  export type InquiryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The data needed to update a Inquiry.
     */
    data: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
    /**
     * Choose, which Inquiry to update.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry updateMany
   */
  export type InquiryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to update.
     */
    limit?: number
  }

  /**
   * Inquiry updateManyAndReturn
   */
  export type InquiryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * The data used to update Inquiries.
     */
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyInput>
    /**
     * Filter which Inquiries to update
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Inquiry upsert
   */
  export type InquiryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * The filter to search for the Inquiry to update in case it exists.
     */
    where: InquiryWhereUniqueInput
    /**
     * In case the Inquiry found by the `where` argument doesn't exist, create a new Inquiry with this data.
     */
    create: XOR<InquiryCreateInput, InquiryUncheckedCreateInput>
    /**
     * In case the Inquiry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InquiryUpdateInput, InquiryUncheckedUpdateInput>
  }

  /**
   * Inquiry delete
   */
  export type InquiryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
    /**
     * Filter which Inquiry to delete.
     */
    where: InquiryWhereUniqueInput
  }

  /**
   * Inquiry deleteMany
   */
  export type InquiryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Inquiries to delete
     */
    where?: InquiryWhereInput
    /**
     * Limit how many Inquiries to delete.
     */
    limit?: number
  }

  /**
   * Inquiry.assignee
   */
  export type Inquiry$assigneeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Inquiry without action
   */
  export type InquiryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Inquiry
     */
    select?: InquirySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Inquiry
     */
    omit?: InquiryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InquiryInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    name: 'name',
    phone: 'phone',
    password: 'password',
    role: 'role',
    avatar: 'avatar',
    isActive: 'isActive',
    mfaEnabled: 'mfaEnabled',
    mfaSecret: 'mfaSecret',
    mfaBackupCodes: 'mfaBackupCodes',
    emailVerified: 'emailVerified',
    phoneVerified: 'phoneVerified',
    stripeAccountId: 'stripeAccountId',
    stripeAccountStatus: 'stripeAccountStatus',
    preferredCurrency: 'preferredCurrency',
    preferredLanguage: 'preferredLanguage',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PropertyScalarFieldEnum: {
    id: 'id',
    titleGr: 'titleGr',
    titleEn: 'titleEn',
    descriptionGr: 'descriptionGr',
    descriptionEn: 'descriptionEn',
    type: 'type',
    status: 'status',
    address: 'address',
    city: 'city',
    country: 'country',
    latitude: 'latitude',
    longitude: 'longitude',
    postalCode: 'postalCode',
    maxGuests: 'maxGuests',
    bedrooms: 'bedrooms',
    bathrooms: 'bathrooms',
    area: 'area',
    basePrice: 'basePrice',
    currency: 'currency',
    cleaningFee: 'cleaningFee',
    serviceFeePercentage: 'serviceFeePercentage',
    taxes: 'taxes',
    taxRate: 'taxRate',
    minStay: 'minStay',
    maxStay: 'maxStay',
    advanceBooking: 'advanceBooking',
    checkInTime: 'checkInTime',
    checkOutTime: 'checkOutTime',
    cancellationPolicy: 'cancellationPolicy',
    houseRules: 'houseRules',
    petFriendly: 'petFriendly',
    smokingAllowed: 'smokingAllowed',
    partyAllowed: 'partyAllowed',
    hasDynamicRooms: 'hasDynamicRooms',
    averageCleanlinessRating: 'averageCleanlinessRating',
    lastCleaningDate: 'lastCleaningDate',
    propertyGroupId: 'propertyGroupId',
    images: 'images',
    videos: 'videos',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyScalarFieldEnum = (typeof PropertyScalarFieldEnum)[keyof typeof PropertyScalarFieldEnum]


  export const AmenityScalarFieldEnum: {
    id: 'id',
    nameGr: 'nameGr',
    nameEn: 'nameEn',
    icon: 'icon',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type AmenityScalarFieldEnum = (typeof AmenityScalarFieldEnum)[keyof typeof AmenityScalarFieldEnum]


  export const PropertyAmenityScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    amenityId: 'amenityId'
  };

  export type PropertyAmenityScalarFieldEnum = (typeof PropertyAmenityScalarFieldEnum)[keyof typeof PropertyAmenityScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    guestId: 'guestId',
    status: 'status',
    paymentStatus: 'paymentStatus',
    checkIn: 'checkIn',
    checkOut: 'checkOut',
    guests: 'guests',
    totalPrice: 'totalPrice',
    basePrice: 'basePrice',
    cleaningFee: 'cleaningFee',
    serviceFee: 'serviceFee',
    taxes: 'taxes',
    currency: 'currency',
    ownerRevenue: 'ownerRevenue',
    platformFee: 'platformFee',
    source: 'source',
    externalId: 'externalId',
    externalPlatform: 'externalPlatform',
    externalData: 'externalData',
    commissionRate: 'commissionRate',
    commissionAmount: 'commissionAmount',
    netRevenue: 'netRevenue',
    externalGuestId: 'externalGuestId',
    iCalUid: 'iCalUid',
    lastSyncedAt: 'lastSyncedAt',
    roomId: 'roomId',
    roomName: 'roomName',
    guestName: 'guestName',
    guestEmail: 'guestEmail',
    guestPhone: 'guestPhone',
    specialRequests: 'specialRequests',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PropertyAvailabilityScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    date: 'date',
    available: 'available',
    price: 'price',
    minStay: 'minStay',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyAvailabilityScalarFieldEnum = (typeof PropertyAvailabilityScalarFieldEnum)[keyof typeof PropertyAvailabilityScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    bookingId: 'bookingId',
    guestId: 'guestId',
    rating: 'rating',
    cleanlinessRating: 'cleanlinessRating',
    accuracyRating: 'accuracyRating',
    communicationRating: 'communicationRating',
    locationRating: 'locationRating',
    valueRating: 'valueRating',
    title: 'title',
    comment: 'comment',
    response: 'response',
    isPublic: 'isPublic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const MaintenanceRequestScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    bookingId: 'bookingId',
    title: 'title',
    description: 'description',
    priority: 'priority',
    status: 'status',
    assignedTo: 'assignedTo',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MaintenanceRequestScalarFieldEnum = (typeof MaintenanceRequestScalarFieldEnum)[keyof typeof MaintenanceRequestScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    senderId: 'senderId',
    content: 'content',
    type: 'type',
    isRead: 'isRead',
    createdAt: 'createdAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const EditionScalarFieldEnum: {
    id: 'id',
    category: 'category',
    titleGr: 'titleGr',
    titleEn: 'titleEn',
    descriptionGr: 'descriptionGr',
    descriptionEn: 'descriptionEn',
    contentGr: 'contentGr',
    contentEn: 'contentEn',
    status: 'status',
    featured: 'featured',
    order: 'order',
    icon: 'icon',
    color: 'color',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EditionScalarFieldEnum = (typeof EditionScalarFieldEnum)[keyof typeof EditionScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    titleGr: 'titleGr',
    titleEn: 'titleEn',
    descriptionGr: 'descriptionGr',
    descriptionEn: 'descriptionEn',
    icon: 'icon',
    features: 'features',
    pricingGr: 'pricingGr',
    pricingEn: 'pricingEn',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const KnowledgeArticleScalarFieldEnum: {
    id: 'id',
    titleGr: 'titleGr',
    titleEn: 'titleEn',
    contentGr: 'contentGr',
    contentEn: 'contentEn',
    category: 'category',
    tags: 'tags',
    author: 'author',
    readTime: 'readTime',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type KnowledgeArticleScalarFieldEnum = (typeof KnowledgeArticleScalarFieldEnum)[keyof typeof KnowledgeArticleScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    propertyId: 'propertyId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    method: 'method',
    transactionId: 'transactionId',
    stripePaymentIntentId: 'stripePaymentIntentId',
    stripeChargeId: 'stripeChargeId',
    refundAmount: 'refundAmount',
    refundReason: 'refundReason',
    refundedAt: 'refundedAt',
    payoutId: 'payoutId',
    payoutStatus: 'payoutStatus',
    payoutScheduledFor: 'payoutScheduledFor',
    processedAt: 'processedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    name: 'name',
    nameGr: 'nameGr',
    nameEn: 'nameEn',
    type: 'type',
    capacity: 'capacity',
    maxAdults: 'maxAdults',
    maxChildren: 'maxChildren',
    maxInfants: 'maxInfants',
    basePrice: 'basePrice',
    isBookable: 'isBookable',
    amenities: 'amenities',
    images: 'images',
    descriptionGr: 'descriptionGr',
    descriptionEn: 'descriptionEn',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const PropertyGroupScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameGr: 'nameGr',
    nameEn: 'nameEn',
    description: 'description',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyGroupScalarFieldEnum = (typeof PropertyGroupScalarFieldEnum)[keyof typeof PropertyGroupScalarFieldEnum]


  export const CleaningScheduleScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    frequency: 'frequency',
    lastCleaned: 'lastCleaned',
    nextCleaning: 'nextCleaning',
    assignedCleaner: 'assignedCleaner',
    ownerId: 'ownerId',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CleaningScheduleScalarFieldEnum = (typeof CleaningScheduleScalarFieldEnum)[keyof typeof CleaningScheduleScalarFieldEnum]


  export const PropertyAnalyticsScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    period: 'period',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    totalRevenue: 'totalRevenue',
    totalCosts: 'totalCosts',
    cleaningCosts: 'cleaningCosts',
    maintenanceCosts: 'maintenanceCosts',
    platformFees: 'platformFees',
    netProfit: 'netProfit',
    profitMargin: 'profitMargin',
    totalBookings: 'totalBookings',
    cancelledBookings: 'cancelledBookings',
    occupancyRate: 'occupancyRate',
    averageDailyRate: 'averageDailyRate',
    revenuePerAvailableRoom: 'revenuePerAvailableRoom',
    averageRating: 'averageRating',
    averageCleanlinessRating: 'averageCleanlinessRating',
    totalReviews: 'totalReviews',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyAnalyticsScalarFieldEnum = (typeof PropertyAnalyticsScalarFieldEnum)[keyof typeof PropertyAnalyticsScalarFieldEnum]


  export const PropertyNoteScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    type: 'type',
    title: 'title',
    content: 'content',
    isPrivate: 'isPrivate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PropertyNoteScalarFieldEnum = (typeof PropertyNoteScalarFieldEnum)[keyof typeof PropertyNoteScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    changes: 'changes',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const ContentScalarFieldEnum: {
    id: 'id',
    page: 'page',
    section: 'section',
    key: 'key',
    contentGr: 'contentGr',
    contentEn: 'contentEn',
    type: 'type',
    order: 'order',
    active: 'active',
    metadata: 'metadata',
    metaTitleGr: 'metaTitleGr',
    metaTitleEn: 'metaTitleEn',
    metaDescriptionGr: 'metaDescriptionGr',
    metaDescriptionEn: 'metaDescriptionEn',
    keywords: 'keywords',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContentScalarFieldEnum = (typeof ContentScalarFieldEnum)[keyof typeof ContentScalarFieldEnum]


  export const ContentMediaScalarFieldEnum: {
    id: 'id',
    contentId: 'contentId',
    mediaId: 'mediaId',
    order: 'order'
  };

  export type ContentMediaScalarFieldEnum = (typeof ContentMediaScalarFieldEnum)[keyof typeof ContentMediaScalarFieldEnum]


  export const MediaScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    url: 'url',
    thumbnailUrl: 'thumbnailUrl',
    category: 'category',
    altTextGr: 'altTextGr',
    altTextEn: 'altTextEn',
    mimeType: 'mimeType',
    size: 'size',
    width: 'width',
    height: 'height',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MediaScalarFieldEnum = (typeof MediaScalarFieldEnum)[keyof typeof MediaScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    type: 'type',
    group: 'group',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const RoomContentScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    highlightsGr: 'highlightsGr',
    highlightsEn: 'highlightsEn',
    featuresGr: 'featuresGr',
    featuresEn: 'featuresEn',
    virtualTourUrl: 'virtualTourUrl',
    floorPlanUrl: 'floorPlanUrl',
    metaTitleGr: 'metaTitleGr',
    metaTitleEn: 'metaTitleEn',
    metaDescriptionGr: 'metaDescriptionGr',
    metaDescriptionEn: 'metaDescriptionEn',
    amenitiesDetails: 'amenitiesDetails',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomContentScalarFieldEnum = (typeof RoomContentScalarFieldEnum)[keyof typeof RoomContentScalarFieldEnum]


  export const RoomAvailabilityRuleScalarFieldEnum: {
    id: 'id',
    roomId: 'roomId',
    startDate: 'startDate',
    endDate: 'endDate',
    isAvailable: 'isAvailable',
    reason: 'reason',
    priceOverride: 'priceOverride',
    minStayOverride: 'minStayOverride',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoomAvailabilityRuleScalarFieldEnum = (typeof RoomAvailabilityRuleScalarFieldEnum)[keyof typeof RoomAvailabilityRuleScalarFieldEnum]


  export const InquiryScalarFieldEnum: {
    id: 'id',
    propertyId: 'propertyId',
    name: 'name',
    email: 'email',
    phone: 'phone',
    message: 'message',
    status: 'status',
    priority: 'priority',
    respondedAt: 'respondedAt',
    respondedBy: 'respondedBy',
    response: 'response',
    adminNotes: 'adminNotes',
    assignedTo: 'assignedTo',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InquiryScalarFieldEnum = (typeof InquiryScalarFieldEnum)[keyof typeof InquiryScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'PropertyType'
   */
  export type EnumPropertyTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyType'>
    


  /**
   * Reference to a field of type 'PropertyStatus'
   */
  export type EnumPropertyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PropertyStatus'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'CancellationPolicy'
   */
  export type EnumCancellationPolicyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CancellationPolicy'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'BookingSource'
   */
  export type EnumBookingSourceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingSource'>
    


  /**
   * Reference to a field of type 'MaintenancePriority'
   */
  export type EnumMaintenancePriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenancePriority'>
    


  /**
   * Reference to a field of type 'MaintenanceStatus'
   */
  export type EnumMaintenanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MaintenanceStatus'>
    


  /**
   * Reference to a field of type 'MessageType'
   */
  export type EnumMessageTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MessageType'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'ContentStatus'
   */
  export type EnumContentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentStatus'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'RoomType'
   */
  export type EnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType'>
    


  /**
   * Reference to a field of type 'CleaningFrequency'
   */
  export type EnumCleaningFrequencyFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CleaningFrequency'>
    


  /**
   * Reference to a field of type 'AnalyticsPeriod'
   */
  export type EnumAnalyticsPeriodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AnalyticsPeriod'>
    


  /**
   * Reference to a field of type 'NoteType'
   */
  export type EnumNoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NoteType'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'MediaCategory'
   */
  export type EnumMediaCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MediaCategory'>
    


  /**
   * Reference to a field of type 'SettingType'
   */
  export type EnumSettingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SettingType'>
    


  /**
   * Reference to a field of type 'InquiryStatus'
   */
  export type EnumInquiryStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryStatus'>
    


  /**
   * Reference to a field of type 'InquiryPriority'
   */
  export type EnumInquiryPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InquiryPriority'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    avatar?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaBackupCodes?: JsonNullableFilter<"User">
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    stripeAccountId?: StringNullableFilter<"User"> | string | null
    stripeAccountStatus?: StringNullableFilter<"User"> | string | null
    preferredCurrency?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    properties?: PropertyListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    messages?: MessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    propertyGroups?: PropertyGroupListRelationFilter
    rooms?: RoomListRelationFilter
    cleaningSchedules?: CleaningScheduleListRelationFilter
    inquiries?: InquiryListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodes?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeAccountStatus?: SortOrderInput | SortOrder
    preferredCurrency?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    properties?: PropertyOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    auditLogs?: AuditLogOrderByRelationAggregateInput
    propertyGroups?: PropertyGroupOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    cleaningSchedules?: CleaningScheduleOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    avatar?: StringNullableFilter<"User"> | string | null
    isActive?: BoolFilter<"User"> | boolean
    mfaEnabled?: BoolFilter<"User"> | boolean
    mfaSecret?: StringNullableFilter<"User"> | string | null
    mfaBackupCodes?: JsonNullableFilter<"User">
    emailVerified?: BoolFilter<"User"> | boolean
    phoneVerified?: BoolFilter<"User"> | boolean
    stripeAccountId?: StringNullableFilter<"User"> | string | null
    stripeAccountStatus?: StringNullableFilter<"User"> | string | null
    preferredCurrency?: StringNullableFilter<"User"> | string | null
    preferredLanguage?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    properties?: PropertyListRelationFilter
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    notifications?: NotificationListRelationFilter
    messages?: MessageListRelationFilter
    auditLogs?: AuditLogListRelationFilter
    propertyGroups?: PropertyGroupListRelationFilter
    rooms?: RoomListRelationFilter
    cleaningSchedules?: CleaningScheduleListRelationFilter
    inquiries?: InquiryListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    avatar?: SortOrderInput | SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaBackupCodes?: SortOrderInput | SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    stripeAccountId?: SortOrderInput | SortOrder
    stripeAccountStatus?: SortOrderInput | SortOrder
    preferredCurrency?: SortOrderInput | SortOrder
    preferredLanguage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    avatar?: StringNullableWithAggregatesFilter<"User"> | string | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    mfaEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    mfaSecret?: StringNullableWithAggregatesFilter<"User"> | string | null
    mfaBackupCodes?: JsonNullableWithAggregatesFilter<"User">
    emailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    phoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    stripeAccountId?: StringNullableWithAggregatesFilter<"User"> | string | null
    stripeAccountStatus?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredCurrency?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredLanguage?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PropertyWhereInput = {
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    id?: StringFilter<"Property"> | string
    titleGr?: StringFilter<"Property"> | string
    titleEn?: StringFilter<"Property"> | string
    descriptionGr?: StringNullableFilter<"Property"> | string | null
    descriptionEn?: StringNullableFilter<"Property"> | string | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    country?: StringFilter<"Property"> | string
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    postalCode?: StringNullableFilter<"Property"> | string | null
    maxGuests?: IntFilter<"Property"> | number
    bedrooms?: IntFilter<"Property"> | number
    bathrooms?: IntFilter<"Property"> | number
    area?: FloatNullableFilter<"Property"> | number | null
    basePrice?: FloatFilter<"Property"> | number
    currency?: StringFilter<"Property"> | string
    cleaningFee?: FloatNullableFilter<"Property"> | number | null
    serviceFeePercentage?: FloatNullableFilter<"Property"> | number | null
    taxes?: FloatNullableFilter<"Property"> | number | null
    taxRate?: FloatNullableFilter<"Property"> | number | null
    minStay?: IntFilter<"Property"> | number
    maxStay?: IntNullableFilter<"Property"> | number | null
    advanceBooking?: IntFilter<"Property"> | number
    checkInTime?: StringNullableFilter<"Property"> | string | null
    checkOutTime?: StringNullableFilter<"Property"> | string | null
    cancellationPolicy?: EnumCancellationPolicyFilter<"Property"> | $Enums.CancellationPolicy
    houseRules?: StringNullableFilter<"Property"> | string | null
    petFriendly?: BoolFilter<"Property"> | boolean
    smokingAllowed?: BoolFilter<"Property"> | boolean
    partyAllowed?: BoolFilter<"Property"> | boolean
    hasDynamicRooms?: BoolFilter<"Property"> | boolean
    averageCleanlinessRating?: FloatNullableFilter<"Property"> | number | null
    lastCleaningDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    propertyGroupId?: StringNullableFilter<"Property"> | string | null
    images?: JsonNullableFilter<"Property">
    videos?: JsonNullableFilter<"Property">
    ownerId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    amenities?: PropertyAmenityListRelationFilter
    availability?: PropertyAvailabilityListRelationFilter
    maintenance?: MaintenanceRequestListRelationFilter
    rooms?: RoomListRelationFilter
    notes?: PropertyNoteListRelationFilter
    analytics?: PropertyAnalyticsListRelationFilter
    cleaningSchedules?: CleaningScheduleListRelationFilter
    propertyGroup?: XOR<PropertyGroupNullableScalarRelationFilter, PropertyGroupWhereInput> | null
    payments?: PaymentListRelationFilter
    inquiries?: InquiryListRelationFilter
  }

  export type PropertyOrderByWithRelationInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFeePercentage?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    minStay?: SortOrder
    maxStay?: SortOrderInput | SortOrder
    advanceBooking?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrderInput | SortOrder
    petFriendly?: SortOrder
    smokingAllowed?: SortOrder
    partyAllowed?: SortOrder
    hasDynamicRooms?: SortOrder
    averageCleanlinessRating?: SortOrderInput | SortOrder
    lastCleaningDate?: SortOrderInput | SortOrder
    propertyGroupId?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    videos?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    amenities?: PropertyAmenityOrderByRelationAggregateInput
    availability?: PropertyAvailabilityOrderByRelationAggregateInput
    maintenance?: MaintenanceRequestOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    notes?: PropertyNoteOrderByRelationAggregateInput
    analytics?: PropertyAnalyticsOrderByRelationAggregateInput
    cleaningSchedules?: CleaningScheduleOrderByRelationAggregateInput
    propertyGroup?: PropertyGroupOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    inquiries?: InquiryOrderByRelationAggregateInput
  }

  export type PropertyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyWhereInput | PropertyWhereInput[]
    OR?: PropertyWhereInput[]
    NOT?: PropertyWhereInput | PropertyWhereInput[]
    titleGr?: StringFilter<"Property"> | string
    titleEn?: StringFilter<"Property"> | string
    descriptionGr?: StringNullableFilter<"Property"> | string | null
    descriptionEn?: StringNullableFilter<"Property"> | string | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    country?: StringFilter<"Property"> | string
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    postalCode?: StringNullableFilter<"Property"> | string | null
    maxGuests?: IntFilter<"Property"> | number
    bedrooms?: IntFilter<"Property"> | number
    bathrooms?: IntFilter<"Property"> | number
    area?: FloatNullableFilter<"Property"> | number | null
    basePrice?: FloatFilter<"Property"> | number
    currency?: StringFilter<"Property"> | string
    cleaningFee?: FloatNullableFilter<"Property"> | number | null
    serviceFeePercentage?: FloatNullableFilter<"Property"> | number | null
    taxes?: FloatNullableFilter<"Property"> | number | null
    taxRate?: FloatNullableFilter<"Property"> | number | null
    minStay?: IntFilter<"Property"> | number
    maxStay?: IntNullableFilter<"Property"> | number | null
    advanceBooking?: IntFilter<"Property"> | number
    checkInTime?: StringNullableFilter<"Property"> | string | null
    checkOutTime?: StringNullableFilter<"Property"> | string | null
    cancellationPolicy?: EnumCancellationPolicyFilter<"Property"> | $Enums.CancellationPolicy
    houseRules?: StringNullableFilter<"Property"> | string | null
    petFriendly?: BoolFilter<"Property"> | boolean
    smokingAllowed?: BoolFilter<"Property"> | boolean
    partyAllowed?: BoolFilter<"Property"> | boolean
    hasDynamicRooms?: BoolFilter<"Property"> | boolean
    averageCleanlinessRating?: FloatNullableFilter<"Property"> | number | null
    lastCleaningDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    propertyGroupId?: StringNullableFilter<"Property"> | string | null
    images?: JsonNullableFilter<"Property">
    videos?: JsonNullableFilter<"Property">
    ownerId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    bookings?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    amenities?: PropertyAmenityListRelationFilter
    availability?: PropertyAvailabilityListRelationFilter
    maintenance?: MaintenanceRequestListRelationFilter
    rooms?: RoomListRelationFilter
    notes?: PropertyNoteListRelationFilter
    analytics?: PropertyAnalyticsListRelationFilter
    cleaningSchedules?: CleaningScheduleListRelationFilter
    propertyGroup?: XOR<PropertyGroupNullableScalarRelationFilter, PropertyGroupWhereInput> | null
    payments?: PaymentListRelationFilter
    inquiries?: InquiryListRelationFilter
  }, "id">

  export type PropertyOrderByWithAggregationInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFeePercentage?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    taxRate?: SortOrderInput | SortOrder
    minStay?: SortOrder
    maxStay?: SortOrderInput | SortOrder
    advanceBooking?: SortOrder
    checkInTime?: SortOrderInput | SortOrder
    checkOutTime?: SortOrderInput | SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrderInput | SortOrder
    petFriendly?: SortOrder
    smokingAllowed?: SortOrder
    partyAllowed?: SortOrder
    hasDynamicRooms?: SortOrder
    averageCleanlinessRating?: SortOrderInput | SortOrder
    lastCleaningDate?: SortOrderInput | SortOrder
    propertyGroupId?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    videos?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyCountOrderByAggregateInput
    _avg?: PropertyAvgOrderByAggregateInput
    _max?: PropertyMaxOrderByAggregateInput
    _min?: PropertyMinOrderByAggregateInput
    _sum?: PropertySumOrderByAggregateInput
  }

  export type PropertyScalarWhereWithAggregatesInput = {
    AND?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    OR?: PropertyScalarWhereWithAggregatesInput[]
    NOT?: PropertyScalarWhereWithAggregatesInput | PropertyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Property"> | string
    titleGr?: StringWithAggregatesFilter<"Property"> | string
    titleEn?: StringWithAggregatesFilter<"Property"> | string
    descriptionGr?: StringNullableWithAggregatesFilter<"Property"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"Property"> | string | null
    type?: EnumPropertyTypeWithAggregatesFilter<"Property"> | $Enums.PropertyType
    status?: EnumPropertyStatusWithAggregatesFilter<"Property"> | $Enums.PropertyStatus
    address?: StringWithAggregatesFilter<"Property"> | string
    city?: StringWithAggregatesFilter<"Property"> | string
    country?: StringWithAggregatesFilter<"Property"> | string
    latitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    postalCode?: StringNullableWithAggregatesFilter<"Property"> | string | null
    maxGuests?: IntWithAggregatesFilter<"Property"> | number
    bedrooms?: IntWithAggregatesFilter<"Property"> | number
    bathrooms?: IntWithAggregatesFilter<"Property"> | number
    area?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    basePrice?: FloatWithAggregatesFilter<"Property"> | number
    currency?: StringWithAggregatesFilter<"Property"> | string
    cleaningFee?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    serviceFeePercentage?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    taxes?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    taxRate?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    minStay?: IntWithAggregatesFilter<"Property"> | number
    maxStay?: IntNullableWithAggregatesFilter<"Property"> | number | null
    advanceBooking?: IntWithAggregatesFilter<"Property"> | number
    checkInTime?: StringNullableWithAggregatesFilter<"Property"> | string | null
    checkOutTime?: StringNullableWithAggregatesFilter<"Property"> | string | null
    cancellationPolicy?: EnumCancellationPolicyWithAggregatesFilter<"Property"> | $Enums.CancellationPolicy
    houseRules?: StringNullableWithAggregatesFilter<"Property"> | string | null
    petFriendly?: BoolWithAggregatesFilter<"Property"> | boolean
    smokingAllowed?: BoolWithAggregatesFilter<"Property"> | boolean
    partyAllowed?: BoolWithAggregatesFilter<"Property"> | boolean
    hasDynamicRooms?: BoolWithAggregatesFilter<"Property"> | boolean
    averageCleanlinessRating?: FloatNullableWithAggregatesFilter<"Property"> | number | null
    lastCleaningDate?: DateTimeNullableWithAggregatesFilter<"Property"> | Date | string | null
    propertyGroupId?: StringNullableWithAggregatesFilter<"Property"> | string | null
    images?: JsonNullableWithAggregatesFilter<"Property">
    videos?: JsonNullableWithAggregatesFilter<"Property">
    ownerId?: StringWithAggregatesFilter<"Property"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Property"> | Date | string
  }

  export type AmenityWhereInput = {
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    id?: StringFilter<"Amenity"> | string
    nameGr?: StringFilter<"Amenity"> | string
    nameEn?: StringFilter<"Amenity"> | string
    icon?: StringNullableFilter<"Amenity"> | string | null
    category?: StringFilter<"Amenity"> | string
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    properties?: PropertyAmenityListRelationFilter
  }

  export type AmenityOrderByWithRelationInput = {
    id?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    properties?: PropertyAmenityOrderByRelationAggregateInput
  }

  export type AmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AmenityWhereInput | AmenityWhereInput[]
    OR?: AmenityWhereInput[]
    NOT?: AmenityWhereInput | AmenityWhereInput[]
    nameGr?: StringFilter<"Amenity"> | string
    nameEn?: StringFilter<"Amenity"> | string
    icon?: StringNullableFilter<"Amenity"> | string | null
    category?: StringFilter<"Amenity"> | string
    createdAt?: DateTimeFilter<"Amenity"> | Date | string
    properties?: PropertyAmenityListRelationFilter
  }, "id">

  export type AmenityOrderByWithAggregationInput = {
    id?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    icon?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    _count?: AmenityCountOrderByAggregateInput
    _max?: AmenityMaxOrderByAggregateInput
    _min?: AmenityMinOrderByAggregateInput
  }

  export type AmenityScalarWhereWithAggregatesInput = {
    AND?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    OR?: AmenityScalarWhereWithAggregatesInput[]
    NOT?: AmenityScalarWhereWithAggregatesInput | AmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amenity"> | string
    nameGr?: StringWithAggregatesFilter<"Amenity"> | string
    nameEn?: StringWithAggregatesFilter<"Amenity"> | string
    icon?: StringNullableWithAggregatesFilter<"Amenity"> | string | null
    category?: StringWithAggregatesFilter<"Amenity"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Amenity"> | Date | string
  }

  export type PropertyAmenityWhereInput = {
    AND?: PropertyAmenityWhereInput | PropertyAmenityWhereInput[]
    OR?: PropertyAmenityWhereInput[]
    NOT?: PropertyAmenityWhereInput | PropertyAmenityWhereInput[]
    id?: StringFilter<"PropertyAmenity"> | string
    propertyId?: StringFilter<"PropertyAmenity"> | string
    amenityId?: StringFilter<"PropertyAmenity"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }

  export type PropertyAmenityOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amenityId?: SortOrder
    property?: PropertyOrderByWithRelationInput
    amenity?: AmenityOrderByWithRelationInput
  }

  export type PropertyAmenityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_amenityId?: PropertyAmenityPropertyIdAmenityIdCompoundUniqueInput
    AND?: PropertyAmenityWhereInput | PropertyAmenityWhereInput[]
    OR?: PropertyAmenityWhereInput[]
    NOT?: PropertyAmenityWhereInput | PropertyAmenityWhereInput[]
    propertyId?: StringFilter<"PropertyAmenity"> | string
    amenityId?: StringFilter<"PropertyAmenity"> | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    amenity?: XOR<AmenityScalarRelationFilter, AmenityWhereInput>
  }, "id" | "propertyId_amenityId">

  export type PropertyAmenityOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amenityId?: SortOrder
    _count?: PropertyAmenityCountOrderByAggregateInput
    _max?: PropertyAmenityMaxOrderByAggregateInput
    _min?: PropertyAmenityMinOrderByAggregateInput
  }

  export type PropertyAmenityScalarWhereWithAggregatesInput = {
    AND?: PropertyAmenityScalarWhereWithAggregatesInput | PropertyAmenityScalarWhereWithAggregatesInput[]
    OR?: PropertyAmenityScalarWhereWithAggregatesInput[]
    NOT?: PropertyAmenityScalarWhereWithAggregatesInput | PropertyAmenityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAmenity"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyAmenity"> | string
    amenityId?: StringWithAggregatesFilter<"PropertyAmenity"> | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    propertyId?: StringFilter<"Booking"> | string
    guestId?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    checkIn?: DateTimeFilter<"Booking"> | Date | string
    checkOut?: DateTimeFilter<"Booking"> | Date | string
    guests?: IntFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    basePrice?: FloatFilter<"Booking"> | number
    cleaningFee?: FloatNullableFilter<"Booking"> | number | null
    serviceFee?: FloatNullableFilter<"Booking"> | number | null
    taxes?: FloatNullableFilter<"Booking"> | number | null
    currency?: StringFilter<"Booking"> | string
    ownerRevenue?: FloatNullableFilter<"Booking"> | number | null
    platformFee?: FloatNullableFilter<"Booking"> | number | null
    source?: EnumBookingSourceFilter<"Booking"> | $Enums.BookingSource
    externalId?: StringNullableFilter<"Booking"> | string | null
    externalPlatform?: StringNullableFilter<"Booking"> | string | null
    externalData?: JsonNullableFilter<"Booking">
    commissionRate?: FloatNullableFilter<"Booking"> | number | null
    commissionAmount?: FloatNullableFilter<"Booking"> | number | null
    netRevenue?: FloatNullableFilter<"Booking"> | number | null
    externalGuestId?: StringNullableFilter<"Booking"> | string | null
    iCalUid?: StringNullableFilter<"Booking"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    roomId?: StringNullableFilter<"Booking"> | string | null
    roomName?: StringNullableFilter<"Booking"> | string | null
    guestName?: StringFilter<"Booking"> | string
    guestEmail?: StringFilter<"Booking"> | string
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    guest?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
    maintenance?: MaintenanceRequestListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    currency?: SortOrder
    ownerRevenue?: SortOrderInput | SortOrder
    platformFee?: SortOrderInput | SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalPlatform?: SortOrderInput | SortOrder
    externalData?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    commissionAmount?: SortOrderInput | SortOrder
    netRevenue?: SortOrderInput | SortOrder
    externalGuestId?: SortOrderInput | SortOrder
    iCalUid?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    roomName?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    guest?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    maintenance?: MaintenanceRequestOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    source_externalId?: BookingSourceExternalIdCompoundUniqueInput
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    propertyId?: StringFilter<"Booking"> | string
    guestId?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    checkIn?: DateTimeFilter<"Booking"> | Date | string
    checkOut?: DateTimeFilter<"Booking"> | Date | string
    guests?: IntFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    basePrice?: FloatFilter<"Booking"> | number
    cleaningFee?: FloatNullableFilter<"Booking"> | number | null
    serviceFee?: FloatNullableFilter<"Booking"> | number | null
    taxes?: FloatNullableFilter<"Booking"> | number | null
    currency?: StringFilter<"Booking"> | string
    ownerRevenue?: FloatNullableFilter<"Booking"> | number | null
    platformFee?: FloatNullableFilter<"Booking"> | number | null
    source?: EnumBookingSourceFilter<"Booking"> | $Enums.BookingSource
    externalId?: StringNullableFilter<"Booking"> | string | null
    externalPlatform?: StringNullableFilter<"Booking"> | string | null
    externalData?: JsonNullableFilter<"Booking">
    commissionRate?: FloatNullableFilter<"Booking"> | number | null
    commissionAmount?: FloatNullableFilter<"Booking"> | number | null
    netRevenue?: FloatNullableFilter<"Booking"> | number | null
    externalGuestId?: StringNullableFilter<"Booking"> | string | null
    iCalUid?: StringNullableFilter<"Booking"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    roomId?: StringNullableFilter<"Booking"> | string | null
    roomName?: StringNullableFilter<"Booking"> | string | null
    guestName?: StringFilter<"Booking"> | string
    guestEmail?: StringFilter<"Booking"> | string
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    guest?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
    reviews?: ReviewListRelationFilter
    messages?: MessageListRelationFilter
    maintenance?: MaintenanceRequestListRelationFilter
  }, "id" | "source_externalId">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrderInput | SortOrder
    serviceFee?: SortOrderInput | SortOrder
    taxes?: SortOrderInput | SortOrder
    currency?: SortOrder
    ownerRevenue?: SortOrderInput | SortOrder
    platformFee?: SortOrderInput | SortOrder
    source?: SortOrder
    externalId?: SortOrderInput | SortOrder
    externalPlatform?: SortOrderInput | SortOrder
    externalData?: SortOrderInput | SortOrder
    commissionRate?: SortOrderInput | SortOrder
    commissionAmount?: SortOrderInput | SortOrder
    netRevenue?: SortOrderInput | SortOrder
    externalGuestId?: SortOrderInput | SortOrder
    iCalUid?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    roomId?: SortOrderInput | SortOrder
    roomName?: SortOrderInput | SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrderInput | SortOrder
    specialRequests?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    propertyId?: StringWithAggregatesFilter<"Booking"> | string
    guestId?: StringWithAggregatesFilter<"Booking"> | string
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Booking"> | $Enums.PaymentStatus
    checkIn?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    checkOut?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    guests?: IntWithAggregatesFilter<"Booking"> | number
    totalPrice?: FloatWithAggregatesFilter<"Booking"> | number
    basePrice?: FloatWithAggregatesFilter<"Booking"> | number
    cleaningFee?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    serviceFee?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    taxes?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    currency?: StringWithAggregatesFilter<"Booking"> | string
    ownerRevenue?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    platformFee?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    source?: EnumBookingSourceWithAggregatesFilter<"Booking"> | $Enums.BookingSource
    externalId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    externalPlatform?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    externalData?: JsonNullableWithAggregatesFilter<"Booking">
    commissionRate?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    commissionAmount?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    netRevenue?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    externalGuestId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    iCalUid?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    roomId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    roomName?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    guestName?: StringWithAggregatesFilter<"Booking"> | string
    guestEmail?: StringWithAggregatesFilter<"Booking"> | string
    guestPhone?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    specialRequests?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type PropertyAvailabilityWhereInput = {
    AND?: PropertyAvailabilityWhereInput | PropertyAvailabilityWhereInput[]
    OR?: PropertyAvailabilityWhereInput[]
    NOT?: PropertyAvailabilityWhereInput | PropertyAvailabilityWhereInput[]
    id?: StringFilter<"PropertyAvailability"> | string
    propertyId?: StringFilter<"PropertyAvailability"> | string
    date?: DateTimeFilter<"PropertyAvailability"> | Date | string
    available?: BoolFilter<"PropertyAvailability"> | boolean
    price?: FloatNullableFilter<"PropertyAvailability"> | number | null
    minStay?: IntNullableFilter<"PropertyAvailability"> | number | null
    createdAt?: DateTimeFilter<"PropertyAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAvailability"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyAvailabilityOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrderInput | SortOrder
    minStay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyAvailabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_date?: PropertyAvailabilityPropertyIdDateCompoundUniqueInput
    AND?: PropertyAvailabilityWhereInput | PropertyAvailabilityWhereInput[]
    OR?: PropertyAvailabilityWhereInput[]
    NOT?: PropertyAvailabilityWhereInput | PropertyAvailabilityWhereInput[]
    propertyId?: StringFilter<"PropertyAvailability"> | string
    date?: DateTimeFilter<"PropertyAvailability"> | Date | string
    available?: BoolFilter<"PropertyAvailability"> | boolean
    price?: FloatNullableFilter<"PropertyAvailability"> | number | null
    minStay?: IntNullableFilter<"PropertyAvailability"> | number | null
    createdAt?: DateTimeFilter<"PropertyAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAvailability"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "propertyId_date">

  export type PropertyAvailabilityOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrderInput | SortOrder
    minStay?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyAvailabilityCountOrderByAggregateInput
    _avg?: PropertyAvailabilityAvgOrderByAggregateInput
    _max?: PropertyAvailabilityMaxOrderByAggregateInput
    _min?: PropertyAvailabilityMinOrderByAggregateInput
    _sum?: PropertyAvailabilitySumOrderByAggregateInput
  }

  export type PropertyAvailabilityScalarWhereWithAggregatesInput = {
    AND?: PropertyAvailabilityScalarWhereWithAggregatesInput | PropertyAvailabilityScalarWhereWithAggregatesInput[]
    OR?: PropertyAvailabilityScalarWhereWithAggregatesInput[]
    NOT?: PropertyAvailabilityScalarWhereWithAggregatesInput | PropertyAvailabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAvailability"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyAvailability"> | string
    date?: DateTimeWithAggregatesFilter<"PropertyAvailability"> | Date | string
    available?: BoolWithAggregatesFilter<"PropertyAvailability"> | boolean
    price?: FloatNullableWithAggregatesFilter<"PropertyAvailability"> | number | null
    minStay?: IntNullableWithAggregatesFilter<"PropertyAvailability"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"PropertyAvailability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyAvailability"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    propertyId?: StringFilter<"Review"> | string
    bookingId?: StringFilter<"Review"> | string
    guestId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    cleanlinessRating?: IntNullableFilter<"Review"> | number | null
    accuracyRating?: IntNullableFilter<"Review"> | number | null
    communicationRating?: IntNullableFilter<"Review"> | number | null
    locationRating?: IntNullableFilter<"Review"> | number | null
    valueRating?: IntNullableFilter<"Review"> | number | null
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    response?: StringNullableFilter<"Review"> | string | null
    isPublic?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    guest?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    guestId?: SortOrder
    rating?: SortOrder
    cleanlinessRating?: SortOrderInput | SortOrder
    accuracyRating?: SortOrderInput | SortOrder
    communicationRating?: SortOrderInput | SortOrder
    locationRating?: SortOrderInput | SortOrder
    valueRating?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    guest?: UserOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    propertyId?: StringFilter<"Review"> | string
    guestId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    cleanlinessRating?: IntNullableFilter<"Review"> | number | null
    accuracyRating?: IntNullableFilter<"Review"> | number | null
    communicationRating?: IntNullableFilter<"Review"> | number | null
    locationRating?: IntNullableFilter<"Review"> | number | null
    valueRating?: IntNullableFilter<"Review"> | number | null
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    response?: StringNullableFilter<"Review"> | string | null
    isPublic?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    guest?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "bookingId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    guestId?: SortOrder
    rating?: SortOrder
    cleanlinessRating?: SortOrderInput | SortOrder
    accuracyRating?: SortOrderInput | SortOrder
    communicationRating?: SortOrderInput | SortOrder
    locationRating?: SortOrderInput | SortOrder
    valueRating?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    comment?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    propertyId?: StringWithAggregatesFilter<"Review"> | string
    bookingId?: StringWithAggregatesFilter<"Review"> | string
    guestId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    cleanlinessRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    accuracyRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    communicationRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    locationRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    valueRating?: IntNullableWithAggregatesFilter<"Review"> | number | null
    title?: StringNullableWithAggregatesFilter<"Review"> | string | null
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    response?: StringNullableWithAggregatesFilter<"Review"> | string | null
    isPublic?: BoolWithAggregatesFilter<"Review"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type MaintenanceRequestWhereInput = {
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    propertyId?: StringFilter<"MaintenanceRequest"> | string
    bookingId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    title?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    priority?: EnumMaintenancePriorityFilter<"MaintenanceRequest"> | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFilter<"MaintenanceRequest"> | $Enums.MaintenanceStatus
    assignedTo?: StringNullableFilter<"MaintenanceRequest"> | string | null
    completedAt?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type MaintenanceRequestOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
  }

  export type MaintenanceRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    OR?: MaintenanceRequestWhereInput[]
    NOT?: MaintenanceRequestWhereInput | MaintenanceRequestWhereInput[]
    propertyId?: StringFilter<"MaintenanceRequest"> | string
    bookingId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    title?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    priority?: EnumMaintenancePriorityFilter<"MaintenanceRequest"> | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFilter<"MaintenanceRequest"> | $Enums.MaintenanceStatus
    assignedTo?: StringNullableFilter<"MaintenanceRequest"> | string | null
    completedAt?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type MaintenanceRequestOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MaintenanceRequestCountOrderByAggregateInput
    _max?: MaintenanceRequestMaxOrderByAggregateInput
    _min?: MaintenanceRequestMinOrderByAggregateInput
  }

  export type MaintenanceRequestScalarWhereWithAggregatesInput = {
    AND?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    OR?: MaintenanceRequestScalarWhereWithAggregatesInput[]
    NOT?: MaintenanceRequestScalarWhereWithAggregatesInput | MaintenanceRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    propertyId?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    bookingId?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    title?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    description?: StringWithAggregatesFilter<"MaintenanceRequest"> | string
    priority?: EnumMaintenancePriorityWithAggregatesFilter<"MaintenanceRequest"> | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusWithAggregatesFilter<"MaintenanceRequest"> | $Enums.MaintenanceStatus
    assignedTo?: StringNullableWithAggregatesFilter<"MaintenanceRequest"> | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"MaintenanceRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MaintenanceRequest"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    bookingId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    bookingId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    bookingId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    content?: StringWithAggregatesFilter<"Message"> | string
    type?: EnumMessageTypeWithAggregatesFilter<"Message"> | $Enums.MessageType
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    data?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type EditionWhereInput = {
    AND?: EditionWhereInput | EditionWhereInput[]
    OR?: EditionWhereInput[]
    NOT?: EditionWhereInput | EditionWhereInput[]
    id?: StringFilter<"Edition"> | string
    category?: StringFilter<"Edition"> | string
    titleGr?: StringFilter<"Edition"> | string
    titleEn?: StringFilter<"Edition"> | string
    descriptionGr?: StringNullableFilter<"Edition"> | string | null
    descriptionEn?: StringNullableFilter<"Edition"> | string | null
    contentGr?: StringNullableFilter<"Edition"> | string | null
    contentEn?: StringNullableFilter<"Edition"> | string | null
    status?: EnumContentStatusFilter<"Edition"> | $Enums.ContentStatus
    featured?: BoolFilter<"Edition"> | boolean
    order?: IntNullableFilter<"Edition"> | number | null
    icon?: StringNullableFilter<"Edition"> | string | null
    color?: StringNullableFilter<"Edition"> | string | null
    createdAt?: DateTimeFilter<"Edition"> | Date | string
    updatedAt?: DateTimeFilter<"Edition"> | Date | string
  }

  export type EditionOrderByWithRelationInput = {
    id?: SortOrder
    category?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    contentGr?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EditionWhereInput | EditionWhereInput[]
    OR?: EditionWhereInput[]
    NOT?: EditionWhereInput | EditionWhereInput[]
    category?: StringFilter<"Edition"> | string
    titleGr?: StringFilter<"Edition"> | string
    titleEn?: StringFilter<"Edition"> | string
    descriptionGr?: StringNullableFilter<"Edition"> | string | null
    descriptionEn?: StringNullableFilter<"Edition"> | string | null
    contentGr?: StringNullableFilter<"Edition"> | string | null
    contentEn?: StringNullableFilter<"Edition"> | string | null
    status?: EnumContentStatusFilter<"Edition"> | $Enums.ContentStatus
    featured?: BoolFilter<"Edition"> | boolean
    order?: IntNullableFilter<"Edition"> | number | null
    icon?: StringNullableFilter<"Edition"> | string | null
    color?: StringNullableFilter<"Edition"> | string | null
    createdAt?: DateTimeFilter<"Edition"> | Date | string
    updatedAt?: DateTimeFilter<"Edition"> | Date | string
  }, "id">

  export type EditionOrderByWithAggregationInput = {
    id?: SortOrder
    category?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    contentGr?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EditionCountOrderByAggregateInput
    _avg?: EditionAvgOrderByAggregateInput
    _max?: EditionMaxOrderByAggregateInput
    _min?: EditionMinOrderByAggregateInput
    _sum?: EditionSumOrderByAggregateInput
  }

  export type EditionScalarWhereWithAggregatesInput = {
    AND?: EditionScalarWhereWithAggregatesInput | EditionScalarWhereWithAggregatesInput[]
    OR?: EditionScalarWhereWithAggregatesInput[]
    NOT?: EditionScalarWhereWithAggregatesInput | EditionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Edition"> | string
    category?: StringWithAggregatesFilter<"Edition"> | string
    titleGr?: StringWithAggregatesFilter<"Edition"> | string
    titleEn?: StringWithAggregatesFilter<"Edition"> | string
    descriptionGr?: StringNullableWithAggregatesFilter<"Edition"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"Edition"> | string | null
    contentGr?: StringNullableWithAggregatesFilter<"Edition"> | string | null
    contentEn?: StringNullableWithAggregatesFilter<"Edition"> | string | null
    status?: EnumContentStatusWithAggregatesFilter<"Edition"> | $Enums.ContentStatus
    featured?: BoolWithAggregatesFilter<"Edition"> | boolean
    order?: IntNullableWithAggregatesFilter<"Edition"> | number | null
    icon?: StringNullableWithAggregatesFilter<"Edition"> | string | null
    color?: StringNullableWithAggregatesFilter<"Edition"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Edition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Edition"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    titleGr?: StringFilter<"Service"> | string
    titleEn?: StringFilter<"Service"> | string
    descriptionGr?: StringNullableFilter<"Service"> | string | null
    descriptionEn?: StringNullableFilter<"Service"> | string | null
    icon?: StringNullableFilter<"Service"> | string | null
    features?: JsonNullableFilter<"Service">
    pricingGr?: StringNullableFilter<"Service"> | string | null
    pricingEn?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    pricingGr?: SortOrderInput | SortOrder
    pricingEn?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    titleGr?: StringFilter<"Service"> | string
    titleEn?: StringFilter<"Service"> | string
    descriptionGr?: StringNullableFilter<"Service"> | string | null
    descriptionEn?: StringNullableFilter<"Service"> | string | null
    icon?: StringNullableFilter<"Service"> | string | null
    features?: JsonNullableFilter<"Service">
    pricingGr?: StringNullableFilter<"Service"> | string | null
    pricingEn?: StringNullableFilter<"Service"> | string | null
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    features?: SortOrderInput | SortOrder
    pricingGr?: SortOrderInput | SortOrder
    pricingEn?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    titleGr?: StringWithAggregatesFilter<"Service"> | string
    titleEn?: StringWithAggregatesFilter<"Service"> | string
    descriptionGr?: StringNullableWithAggregatesFilter<"Service"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"Service"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Service"> | string | null
    features?: JsonNullableWithAggregatesFilter<"Service">
    pricingGr?: StringNullableWithAggregatesFilter<"Service"> | string | null
    pricingEn?: StringNullableWithAggregatesFilter<"Service"> | string | null
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type KnowledgeArticleWhereInput = {
    AND?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    OR?: KnowledgeArticleWhereInput[]
    NOT?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    id?: StringFilter<"KnowledgeArticle"> | string
    titleGr?: StringFilter<"KnowledgeArticle"> | string
    titleEn?: StringFilter<"KnowledgeArticle"> | string
    contentGr?: StringNullableFilter<"KnowledgeArticle"> | string | null
    contentEn?: StringNullableFilter<"KnowledgeArticle"> | string | null
    category?: StringFilter<"KnowledgeArticle"> | string
    tags?: JsonNullableFilter<"KnowledgeArticle">
    author?: StringFilter<"KnowledgeArticle"> | string
    readTime?: IntNullableFilter<"KnowledgeArticle"> | number | null
    publishedAt?: DateTimeNullableFilter<"KnowledgeArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
  }

  export type KnowledgeArticleOrderByWithRelationInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    contentGr?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrderInput | SortOrder
    author?: SortOrder
    readTime?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    OR?: KnowledgeArticleWhereInput[]
    NOT?: KnowledgeArticleWhereInput | KnowledgeArticleWhereInput[]
    titleGr?: StringFilter<"KnowledgeArticle"> | string
    titleEn?: StringFilter<"KnowledgeArticle"> | string
    contentGr?: StringNullableFilter<"KnowledgeArticle"> | string | null
    contentEn?: StringNullableFilter<"KnowledgeArticle"> | string | null
    category?: StringFilter<"KnowledgeArticle"> | string
    tags?: JsonNullableFilter<"KnowledgeArticle">
    author?: StringFilter<"KnowledgeArticle"> | string
    readTime?: IntNullableFilter<"KnowledgeArticle"> | number | null
    publishedAt?: DateTimeNullableFilter<"KnowledgeArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
    updatedAt?: DateTimeFilter<"KnowledgeArticle"> | Date | string
  }, "id">

  export type KnowledgeArticleOrderByWithAggregationInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    contentGr?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    category?: SortOrder
    tags?: SortOrderInput | SortOrder
    author?: SortOrder
    readTime?: SortOrderInput | SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: KnowledgeArticleCountOrderByAggregateInput
    _avg?: KnowledgeArticleAvgOrderByAggregateInput
    _max?: KnowledgeArticleMaxOrderByAggregateInput
    _min?: KnowledgeArticleMinOrderByAggregateInput
    _sum?: KnowledgeArticleSumOrderByAggregateInput
  }

  export type KnowledgeArticleScalarWhereWithAggregatesInput = {
    AND?: KnowledgeArticleScalarWhereWithAggregatesInput | KnowledgeArticleScalarWhereWithAggregatesInput[]
    OR?: KnowledgeArticleScalarWhereWithAggregatesInput[]
    NOT?: KnowledgeArticleScalarWhereWithAggregatesInput | KnowledgeArticleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    titleGr?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    titleEn?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    contentGr?: StringNullableWithAggregatesFilter<"KnowledgeArticle"> | string | null
    contentEn?: StringNullableWithAggregatesFilter<"KnowledgeArticle"> | string | null
    category?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    tags?: JsonNullableWithAggregatesFilter<"KnowledgeArticle">
    author?: StringWithAggregatesFilter<"KnowledgeArticle"> | string
    readTime?: IntNullableWithAggregatesFilter<"KnowledgeArticle"> | number | null
    publishedAt?: DateTimeNullableWithAggregatesFilter<"KnowledgeArticle"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"KnowledgeArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"KnowledgeArticle"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    propertyId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transactionId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    refundAmount?: FloatNullableFilter<"Payment"> | number | null
    refundReason?: StringNullableFilter<"Payment"> | string | null
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    payoutId?: StringNullableFilter<"Payment"> | string | null
    payoutStatus?: StringNullableFilter<"Payment"> | string | null
    payoutScheduledFor?: DateTimeNullableFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundReason?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    payoutId?: SortOrderInput | SortOrder
    payoutStatus?: SortOrderInput | SortOrder
    payoutScheduledFor?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
    property?: PropertyOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: StringFilter<"Payment"> | string
    propertyId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transactionId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    refundAmount?: FloatNullableFilter<"Payment"> | number | null
    refundReason?: StringNullableFilter<"Payment"> | string | null
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    payoutId?: StringNullableFilter<"Payment"> | string | null
    payoutStatus?: StringNullableFilter<"Payment"> | string | null
    payoutScheduledFor?: DateTimeNullableFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingScalarRelationFilter, BookingWhereInput>
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    stripePaymentIntentId?: SortOrderInput | SortOrder
    stripeChargeId?: SortOrderInput | SortOrder
    refundAmount?: SortOrderInput | SortOrder
    refundReason?: SortOrderInput | SortOrder
    refundedAt?: SortOrderInput | SortOrder
    payoutId?: SortOrderInput | SortOrder
    payoutStatus?: SortOrderInput | SortOrder
    payoutScheduledFor?: SortOrderInput | SortOrder
    processedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringWithAggregatesFilter<"Payment"> | string
    propertyId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    refundAmount?: FloatNullableWithAggregatesFilter<"Payment"> | number | null
    refundReason?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    refundedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    payoutId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    payoutStatus?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    payoutScheduledFor?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableWithAggregatesFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: StringFilter<"Room"> | string
    propertyId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    nameGr?: StringNullableFilter<"Room"> | string | null
    nameEn?: StringNullableFilter<"Room"> | string | null
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    capacity?: IntFilter<"Room"> | number
    maxAdults?: IntNullableFilter<"Room"> | number | null
    maxChildren?: IntNullableFilter<"Room"> | number | null
    maxInfants?: IntNullableFilter<"Room"> | number | null
    basePrice?: FloatFilter<"Room"> | number
    isBookable?: BoolFilter<"Room"> | boolean
    amenities?: JsonNullableFilter<"Room">
    images?: JsonNullableFilter<"Room">
    descriptionGr?: StringNullableFilter<"Room"> | string | null
    descriptionEn?: StringNullableFilter<"Room"> | string | null
    ownerId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    roomContent?: XOR<RoomContentNullableScalarRelationFilter, RoomContentWhereInput> | null
    availabilityRules?: RoomAvailabilityRuleListRelationFilter
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    nameGr?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    type?: SortOrder
    capacity?: SortOrder
    maxAdults?: SortOrderInput | SortOrder
    maxChildren?: SortOrderInput | SortOrder
    maxInfants?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    isBookable?: SortOrder
    amenities?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
    roomContent?: RoomContentOrderByWithRelationInput
    availabilityRules?: RoomAvailabilityRuleOrderByRelationAggregateInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    propertyId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    nameGr?: StringNullableFilter<"Room"> | string | null
    nameEn?: StringNullableFilter<"Room"> | string | null
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    capacity?: IntFilter<"Room"> | number
    maxAdults?: IntNullableFilter<"Room"> | number | null
    maxChildren?: IntNullableFilter<"Room"> | number | null
    maxInfants?: IntNullableFilter<"Room"> | number | null
    basePrice?: FloatFilter<"Room"> | number
    isBookable?: BoolFilter<"Room"> | boolean
    amenities?: JsonNullableFilter<"Room">
    images?: JsonNullableFilter<"Room">
    descriptionGr?: StringNullableFilter<"Room"> | string | null
    descriptionEn?: StringNullableFilter<"Room"> | string | null
    ownerId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    roomContent?: XOR<RoomContentNullableScalarRelationFilter, RoomContentWhereInput> | null
    availabilityRules?: RoomAvailabilityRuleListRelationFilter
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    nameGr?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    type?: SortOrder
    capacity?: SortOrder
    maxAdults?: SortOrderInput | SortOrder
    maxChildren?: SortOrderInput | SortOrder
    maxInfants?: SortOrderInput | SortOrder
    basePrice?: SortOrder
    isBookable?: SortOrder
    amenities?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    descriptionGr?: SortOrderInput | SortOrder
    descriptionEn?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Room"> | string
    propertyId?: StringWithAggregatesFilter<"Room"> | string
    name?: StringWithAggregatesFilter<"Room"> | string
    nameGr?: StringNullableWithAggregatesFilter<"Room"> | string | null
    nameEn?: StringNullableWithAggregatesFilter<"Room"> | string | null
    type?: EnumRoomTypeWithAggregatesFilter<"Room"> | $Enums.RoomType
    capacity?: IntWithAggregatesFilter<"Room"> | number
    maxAdults?: IntNullableWithAggregatesFilter<"Room"> | number | null
    maxChildren?: IntNullableWithAggregatesFilter<"Room"> | number | null
    maxInfants?: IntNullableWithAggregatesFilter<"Room"> | number | null
    basePrice?: FloatWithAggregatesFilter<"Room"> | number
    isBookable?: BoolWithAggregatesFilter<"Room"> | boolean
    amenities?: JsonNullableWithAggregatesFilter<"Room">
    images?: JsonNullableWithAggregatesFilter<"Room">
    descriptionGr?: StringNullableWithAggregatesFilter<"Room"> | string | null
    descriptionEn?: StringNullableWithAggregatesFilter<"Room"> | string | null
    ownerId?: StringWithAggregatesFilter<"Room"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type PropertyGroupWhereInput = {
    AND?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    OR?: PropertyGroupWhereInput[]
    NOT?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    id?: StringFilter<"PropertyGroup"> | string
    name?: StringFilter<"PropertyGroup"> | string
    nameGr?: StringNullableFilter<"PropertyGroup"> | string | null
    nameEn?: StringNullableFilter<"PropertyGroup"> | string | null
    description?: StringNullableFilter<"PropertyGroup"> | string | null
    ownerId?: StringFilter<"PropertyGroup"> | string
    createdAt?: DateTimeFilter<"PropertyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyGroup"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
  }

  export type PropertyGroupOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameGr?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    properties?: PropertyOrderByRelationAggregateInput
  }

  export type PropertyGroupWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    OR?: PropertyGroupWhereInput[]
    NOT?: PropertyGroupWhereInput | PropertyGroupWhereInput[]
    name?: StringFilter<"PropertyGroup"> | string
    nameGr?: StringNullableFilter<"PropertyGroup"> | string | null
    nameEn?: StringNullableFilter<"PropertyGroup"> | string | null
    description?: StringNullableFilter<"PropertyGroup"> | string | null
    ownerId?: StringFilter<"PropertyGroup"> | string
    createdAt?: DateTimeFilter<"PropertyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyGroup"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    properties?: PropertyListRelationFilter
  }, "id">

  export type PropertyGroupOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameGr?: SortOrderInput | SortOrder
    nameEn?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyGroupCountOrderByAggregateInput
    _max?: PropertyGroupMaxOrderByAggregateInput
    _min?: PropertyGroupMinOrderByAggregateInput
  }

  export type PropertyGroupScalarWhereWithAggregatesInput = {
    AND?: PropertyGroupScalarWhereWithAggregatesInput | PropertyGroupScalarWhereWithAggregatesInput[]
    OR?: PropertyGroupScalarWhereWithAggregatesInput[]
    NOT?: PropertyGroupScalarWhereWithAggregatesInput | PropertyGroupScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyGroup"> | string
    name?: StringWithAggregatesFilter<"PropertyGroup"> | string
    nameGr?: StringNullableWithAggregatesFilter<"PropertyGroup"> | string | null
    nameEn?: StringNullableWithAggregatesFilter<"PropertyGroup"> | string | null
    description?: StringNullableWithAggregatesFilter<"PropertyGroup"> | string | null
    ownerId?: StringWithAggregatesFilter<"PropertyGroup"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyGroup"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyGroup"> | Date | string
  }

  export type CleaningScheduleWhereInput = {
    AND?: CleaningScheduleWhereInput | CleaningScheduleWhereInput[]
    OR?: CleaningScheduleWhereInput[]
    NOT?: CleaningScheduleWhereInput | CleaningScheduleWhereInput[]
    id?: StringFilter<"CleaningSchedule"> | string
    propertyId?: StringFilter<"CleaningSchedule"> | string
    frequency?: EnumCleaningFrequencyFilter<"CleaningSchedule"> | $Enums.CleaningFrequency
    lastCleaned?: DateTimeNullableFilter<"CleaningSchedule"> | Date | string | null
    nextCleaning?: DateTimeNullableFilter<"CleaningSchedule"> | Date | string | null
    assignedCleaner?: StringNullableFilter<"CleaningSchedule"> | string | null
    ownerId?: StringFilter<"CleaningSchedule"> | string
    notes?: StringNullableFilter<"CleaningSchedule"> | string | null
    createdAt?: DateTimeFilter<"CleaningSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSchedule"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CleaningScheduleOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    frequency?: SortOrder
    lastCleaned?: SortOrderInput | SortOrder
    nextCleaning?: SortOrderInput | SortOrder
    assignedCleaner?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    owner?: UserOrderByWithRelationInput
  }

  export type CleaningScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CleaningScheduleWhereInput | CleaningScheduleWhereInput[]
    OR?: CleaningScheduleWhereInput[]
    NOT?: CleaningScheduleWhereInput | CleaningScheduleWhereInput[]
    propertyId?: StringFilter<"CleaningSchedule"> | string
    frequency?: EnumCleaningFrequencyFilter<"CleaningSchedule"> | $Enums.CleaningFrequency
    lastCleaned?: DateTimeNullableFilter<"CleaningSchedule"> | Date | string | null
    nextCleaning?: DateTimeNullableFilter<"CleaningSchedule"> | Date | string | null
    assignedCleaner?: StringNullableFilter<"CleaningSchedule"> | string | null
    ownerId?: StringFilter<"CleaningSchedule"> | string
    notes?: StringNullableFilter<"CleaningSchedule"> | string | null
    createdAt?: DateTimeFilter<"CleaningSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSchedule"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CleaningScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    frequency?: SortOrder
    lastCleaned?: SortOrderInput | SortOrder
    nextCleaning?: SortOrderInput | SortOrder
    assignedCleaner?: SortOrderInput | SortOrder
    ownerId?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CleaningScheduleCountOrderByAggregateInput
    _max?: CleaningScheduleMaxOrderByAggregateInput
    _min?: CleaningScheduleMinOrderByAggregateInput
  }

  export type CleaningScheduleScalarWhereWithAggregatesInput = {
    AND?: CleaningScheduleScalarWhereWithAggregatesInput | CleaningScheduleScalarWhereWithAggregatesInput[]
    OR?: CleaningScheduleScalarWhereWithAggregatesInput[]
    NOT?: CleaningScheduleScalarWhereWithAggregatesInput | CleaningScheduleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CleaningSchedule"> | string
    propertyId?: StringWithAggregatesFilter<"CleaningSchedule"> | string
    frequency?: EnumCleaningFrequencyWithAggregatesFilter<"CleaningSchedule"> | $Enums.CleaningFrequency
    lastCleaned?: DateTimeNullableWithAggregatesFilter<"CleaningSchedule"> | Date | string | null
    nextCleaning?: DateTimeNullableWithAggregatesFilter<"CleaningSchedule"> | Date | string | null
    assignedCleaner?: StringNullableWithAggregatesFilter<"CleaningSchedule"> | string | null
    ownerId?: StringWithAggregatesFilter<"CleaningSchedule"> | string
    notes?: StringNullableWithAggregatesFilter<"CleaningSchedule"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CleaningSchedule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CleaningSchedule"> | Date | string
  }

  export type PropertyAnalyticsWhereInput = {
    AND?: PropertyAnalyticsWhereInput | PropertyAnalyticsWhereInput[]
    OR?: PropertyAnalyticsWhereInput[]
    NOT?: PropertyAnalyticsWhereInput | PropertyAnalyticsWhereInput[]
    id?: StringFilter<"PropertyAnalytics"> | string
    propertyId?: StringFilter<"PropertyAnalytics"> | string
    period?: EnumAnalyticsPeriodFilter<"PropertyAnalytics"> | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    periodEnd?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    totalRevenue?: FloatFilter<"PropertyAnalytics"> | number
    totalCosts?: FloatFilter<"PropertyAnalytics"> | number
    cleaningCosts?: FloatFilter<"PropertyAnalytics"> | number
    maintenanceCosts?: FloatFilter<"PropertyAnalytics"> | number
    platformFees?: FloatFilter<"PropertyAnalytics"> | number
    netProfit?: FloatFilter<"PropertyAnalytics"> | number
    profitMargin?: FloatFilter<"PropertyAnalytics"> | number
    totalBookings?: IntFilter<"PropertyAnalytics"> | number
    cancelledBookings?: IntFilter<"PropertyAnalytics"> | number
    occupancyRate?: FloatFilter<"PropertyAnalytics"> | number
    averageDailyRate?: FloatFilter<"PropertyAnalytics"> | number
    revenuePerAvailableRoom?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    averageRating?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    averageCleanlinessRating?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    totalReviews?: IntFilter<"PropertyAnalytics"> | number
    createdAt?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyAnalyticsOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrderInput | SortOrder
    averageRating?: SortOrderInput | SortOrder
    averageCleanlinessRating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyAnalyticsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    propertyId_period_periodStart?: PropertyAnalyticsPropertyIdPeriodPeriodStartCompoundUniqueInput
    AND?: PropertyAnalyticsWhereInput | PropertyAnalyticsWhereInput[]
    OR?: PropertyAnalyticsWhereInput[]
    NOT?: PropertyAnalyticsWhereInput | PropertyAnalyticsWhereInput[]
    propertyId?: StringFilter<"PropertyAnalytics"> | string
    period?: EnumAnalyticsPeriodFilter<"PropertyAnalytics"> | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    periodEnd?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    totalRevenue?: FloatFilter<"PropertyAnalytics"> | number
    totalCosts?: FloatFilter<"PropertyAnalytics"> | number
    cleaningCosts?: FloatFilter<"PropertyAnalytics"> | number
    maintenanceCosts?: FloatFilter<"PropertyAnalytics"> | number
    platformFees?: FloatFilter<"PropertyAnalytics"> | number
    netProfit?: FloatFilter<"PropertyAnalytics"> | number
    profitMargin?: FloatFilter<"PropertyAnalytics"> | number
    totalBookings?: IntFilter<"PropertyAnalytics"> | number
    cancelledBookings?: IntFilter<"PropertyAnalytics"> | number
    occupancyRate?: FloatFilter<"PropertyAnalytics"> | number
    averageDailyRate?: FloatFilter<"PropertyAnalytics"> | number
    revenuePerAvailableRoom?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    averageRating?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    averageCleanlinessRating?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    totalReviews?: IntFilter<"PropertyAnalytics"> | number
    createdAt?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id" | "propertyId_period_periodStart">

  export type PropertyAnalyticsOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrderInput | SortOrder
    averageRating?: SortOrderInput | SortOrder
    averageCleanlinessRating?: SortOrderInput | SortOrder
    totalReviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyAnalyticsCountOrderByAggregateInput
    _avg?: PropertyAnalyticsAvgOrderByAggregateInput
    _max?: PropertyAnalyticsMaxOrderByAggregateInput
    _min?: PropertyAnalyticsMinOrderByAggregateInput
    _sum?: PropertyAnalyticsSumOrderByAggregateInput
  }

  export type PropertyAnalyticsScalarWhereWithAggregatesInput = {
    AND?: PropertyAnalyticsScalarWhereWithAggregatesInput | PropertyAnalyticsScalarWhereWithAggregatesInput[]
    OR?: PropertyAnalyticsScalarWhereWithAggregatesInput[]
    NOT?: PropertyAnalyticsScalarWhereWithAggregatesInput | PropertyAnalyticsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyAnalytics"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyAnalytics"> | string
    period?: EnumAnalyticsPeriodWithAggregatesFilter<"PropertyAnalytics"> | $Enums.AnalyticsPeriod
    periodStart?: DateTimeWithAggregatesFilter<"PropertyAnalytics"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"PropertyAnalytics"> | Date | string
    totalRevenue?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    totalCosts?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    cleaningCosts?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    maintenanceCosts?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    platformFees?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    netProfit?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    profitMargin?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    totalBookings?: IntWithAggregatesFilter<"PropertyAnalytics"> | number
    cancelledBookings?: IntWithAggregatesFilter<"PropertyAnalytics"> | number
    occupancyRate?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    averageDailyRate?: FloatWithAggregatesFilter<"PropertyAnalytics"> | number
    revenuePerAvailableRoom?: FloatNullableWithAggregatesFilter<"PropertyAnalytics"> | number | null
    averageRating?: FloatNullableWithAggregatesFilter<"PropertyAnalytics"> | number | null
    averageCleanlinessRating?: FloatNullableWithAggregatesFilter<"PropertyAnalytics"> | number | null
    totalReviews?: IntWithAggregatesFilter<"PropertyAnalytics"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PropertyAnalytics"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyAnalytics"> | Date | string
  }

  export type PropertyNoteWhereInput = {
    AND?: PropertyNoteWhereInput | PropertyNoteWhereInput[]
    OR?: PropertyNoteWhereInput[]
    NOT?: PropertyNoteWhereInput | PropertyNoteWhereInput[]
    id?: StringFilter<"PropertyNote"> | string
    propertyId?: StringFilter<"PropertyNote"> | string
    type?: EnumNoteTypeFilter<"PropertyNote"> | $Enums.NoteType
    title?: StringFilter<"PropertyNote"> | string
    content?: StringFilter<"PropertyNote"> | string
    isPrivate?: BoolFilter<"PropertyNote"> | boolean
    createdBy?: StringFilter<"PropertyNote"> | string
    createdAt?: DateTimeFilter<"PropertyNote"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyNote"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }

  export type PropertyNoteOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
  }

  export type PropertyNoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PropertyNoteWhereInput | PropertyNoteWhereInput[]
    OR?: PropertyNoteWhereInput[]
    NOT?: PropertyNoteWhereInput | PropertyNoteWhereInput[]
    propertyId?: StringFilter<"PropertyNote"> | string
    type?: EnumNoteTypeFilter<"PropertyNote"> | $Enums.NoteType
    title?: StringFilter<"PropertyNote"> | string
    content?: StringFilter<"PropertyNote"> | string
    isPrivate?: BoolFilter<"PropertyNote"> | boolean
    createdBy?: StringFilter<"PropertyNote"> | string
    createdAt?: DateTimeFilter<"PropertyNote"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyNote"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
  }, "id">

  export type PropertyNoteOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PropertyNoteCountOrderByAggregateInput
    _max?: PropertyNoteMaxOrderByAggregateInput
    _min?: PropertyNoteMinOrderByAggregateInput
  }

  export type PropertyNoteScalarWhereWithAggregatesInput = {
    AND?: PropertyNoteScalarWhereWithAggregatesInput | PropertyNoteScalarWhereWithAggregatesInput[]
    OR?: PropertyNoteScalarWhereWithAggregatesInput[]
    NOT?: PropertyNoteScalarWhereWithAggregatesInput | PropertyNoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PropertyNote"> | string
    propertyId?: StringWithAggregatesFilter<"PropertyNote"> | string
    type?: EnumNoteTypeWithAggregatesFilter<"PropertyNote"> | $Enums.NoteType
    title?: StringWithAggregatesFilter<"PropertyNote"> | string
    content?: StringWithAggregatesFilter<"PropertyNote"> | string
    isPrivate?: BoolWithAggregatesFilter<"PropertyNote"> | boolean
    createdBy?: StringWithAggregatesFilter<"PropertyNote"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PropertyNote"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PropertyNote"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    changes?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringWithAggregatesFilter<"AuditLog"> | string
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    changes?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AuditLog">
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type ContentWhereInput = {
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    id?: StringFilter<"Content"> | string
    page?: StringFilter<"Content"> | string
    section?: StringFilter<"Content"> | string
    key?: StringFilter<"Content"> | string
    contentGr?: StringNullableFilter<"Content"> | string | null
    contentEn?: StringNullableFilter<"Content"> | string | null
    type?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    order?: IntFilter<"Content"> | number
    active?: BoolFilter<"Content"> | boolean
    metadata?: JsonNullableFilter<"Content">
    metaTitleGr?: StringNullableFilter<"Content"> | string | null
    metaTitleEn?: StringNullableFilter<"Content"> | string | null
    metaDescriptionGr?: StringNullableFilter<"Content"> | string | null
    metaDescriptionEn?: StringNullableFilter<"Content"> | string | null
    keywords?: JsonNullableFilter<"Content">
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    media?: ContentMediaListRelationFilter
  }

  export type ContentOrderByWithRelationInput = {
    id?: SortOrder
    page?: SortOrder
    section?: SortOrder
    key?: SortOrder
    contentGr?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    type?: SortOrder
    order?: SortOrder
    active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    metaTitleGr?: SortOrderInput | SortOrder
    metaTitleEn?: SortOrderInput | SortOrder
    metaDescriptionGr?: SortOrderInput | SortOrder
    metaDescriptionEn?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    media?: ContentMediaOrderByRelationAggregateInput
  }

  export type ContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    page_section_key?: ContentPageSectionKeyCompoundUniqueInput
    AND?: ContentWhereInput | ContentWhereInput[]
    OR?: ContentWhereInput[]
    NOT?: ContentWhereInput | ContentWhereInput[]
    page?: StringFilter<"Content"> | string
    section?: StringFilter<"Content"> | string
    key?: StringFilter<"Content"> | string
    contentGr?: StringNullableFilter<"Content"> | string | null
    contentEn?: StringNullableFilter<"Content"> | string | null
    type?: EnumContentTypeFilter<"Content"> | $Enums.ContentType
    order?: IntFilter<"Content"> | number
    active?: BoolFilter<"Content"> | boolean
    metadata?: JsonNullableFilter<"Content">
    metaTitleGr?: StringNullableFilter<"Content"> | string | null
    metaTitleEn?: StringNullableFilter<"Content"> | string | null
    metaDescriptionGr?: StringNullableFilter<"Content"> | string | null
    metaDescriptionEn?: StringNullableFilter<"Content"> | string | null
    keywords?: JsonNullableFilter<"Content">
    createdAt?: DateTimeFilter<"Content"> | Date | string
    updatedAt?: DateTimeFilter<"Content"> | Date | string
    media?: ContentMediaListRelationFilter
  }, "id" | "page_section_key">

  export type ContentOrderByWithAggregationInput = {
    id?: SortOrder
    page?: SortOrder
    section?: SortOrder
    key?: SortOrder
    contentGr?: SortOrderInput | SortOrder
    contentEn?: SortOrderInput | SortOrder
    type?: SortOrder
    order?: SortOrder
    active?: SortOrder
    metadata?: SortOrderInput | SortOrder
    metaTitleGr?: SortOrderInput | SortOrder
    metaTitleEn?: SortOrderInput | SortOrder
    metaDescriptionGr?: SortOrderInput | SortOrder
    metaDescriptionEn?: SortOrderInput | SortOrder
    keywords?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContentCountOrderByAggregateInput
    _avg?: ContentAvgOrderByAggregateInput
    _max?: ContentMaxOrderByAggregateInput
    _min?: ContentMinOrderByAggregateInput
    _sum?: ContentSumOrderByAggregateInput
  }

  export type ContentScalarWhereWithAggregatesInput = {
    AND?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    OR?: ContentScalarWhereWithAggregatesInput[]
    NOT?: ContentScalarWhereWithAggregatesInput | ContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Content"> | string
    page?: StringWithAggregatesFilter<"Content"> | string
    section?: StringWithAggregatesFilter<"Content"> | string
    key?: StringWithAggregatesFilter<"Content"> | string
    contentGr?: StringNullableWithAggregatesFilter<"Content"> | string | null
    contentEn?: StringNullableWithAggregatesFilter<"Content"> | string | null
    type?: EnumContentTypeWithAggregatesFilter<"Content"> | $Enums.ContentType
    order?: IntWithAggregatesFilter<"Content"> | number
    active?: BoolWithAggregatesFilter<"Content"> | boolean
    metadata?: JsonNullableWithAggregatesFilter<"Content">
    metaTitleGr?: StringNullableWithAggregatesFilter<"Content"> | string | null
    metaTitleEn?: StringNullableWithAggregatesFilter<"Content"> | string | null
    metaDescriptionGr?: StringNullableWithAggregatesFilter<"Content"> | string | null
    metaDescriptionEn?: StringNullableWithAggregatesFilter<"Content"> | string | null
    keywords?: JsonNullableWithAggregatesFilter<"Content">
    createdAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Content"> | Date | string
  }

  export type ContentMediaWhereInput = {
    AND?: ContentMediaWhereInput | ContentMediaWhereInput[]
    OR?: ContentMediaWhereInput[]
    NOT?: ContentMediaWhereInput | ContentMediaWhereInput[]
    id?: StringFilter<"ContentMedia"> | string
    contentId?: StringFilter<"ContentMedia"> | string
    mediaId?: StringFilter<"ContentMedia"> | string
    order?: IntFilter<"ContentMedia"> | number
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }

  export type ContentMediaOrderByWithRelationInput = {
    id?: SortOrder
    contentId?: SortOrder
    mediaId?: SortOrder
    order?: SortOrder
    content?: ContentOrderByWithRelationInput
    media?: MediaOrderByWithRelationInput
  }

  export type ContentMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contentId_mediaId?: ContentMediaContentIdMediaIdCompoundUniqueInput
    AND?: ContentMediaWhereInput | ContentMediaWhereInput[]
    OR?: ContentMediaWhereInput[]
    NOT?: ContentMediaWhereInput | ContentMediaWhereInput[]
    contentId?: StringFilter<"ContentMedia"> | string
    mediaId?: StringFilter<"ContentMedia"> | string
    order?: IntFilter<"ContentMedia"> | number
    content?: XOR<ContentScalarRelationFilter, ContentWhereInput>
    media?: XOR<MediaScalarRelationFilter, MediaWhereInput>
  }, "id" | "contentId_mediaId">

  export type ContentMediaOrderByWithAggregationInput = {
    id?: SortOrder
    contentId?: SortOrder
    mediaId?: SortOrder
    order?: SortOrder
    _count?: ContentMediaCountOrderByAggregateInput
    _avg?: ContentMediaAvgOrderByAggregateInput
    _max?: ContentMediaMaxOrderByAggregateInput
    _min?: ContentMediaMinOrderByAggregateInput
    _sum?: ContentMediaSumOrderByAggregateInput
  }

  export type ContentMediaScalarWhereWithAggregatesInput = {
    AND?: ContentMediaScalarWhereWithAggregatesInput | ContentMediaScalarWhereWithAggregatesInput[]
    OR?: ContentMediaScalarWhereWithAggregatesInput[]
    NOT?: ContentMediaScalarWhereWithAggregatesInput | ContentMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContentMedia"> | string
    contentId?: StringWithAggregatesFilter<"ContentMedia"> | string
    mediaId?: StringWithAggregatesFilter<"ContentMedia"> | string
    order?: IntWithAggregatesFilter<"ContentMedia"> | number
  }

  export type MediaWhereInput = {
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    id?: StringFilter<"Media"> | string
    filename?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    thumbnailUrl?: StringNullableFilter<"Media"> | string | null
    category?: EnumMediaCategoryFilter<"Media"> | $Enums.MediaCategory
    altTextGr?: StringNullableFilter<"Media"> | string | null
    altTextEn?: StringNullableFilter<"Media"> | string | null
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    content?: ContentMediaListRelationFilter
  }

  export type MediaOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    altTextGr?: SortOrderInput | SortOrder
    altTextEn?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    content?: ContentMediaOrderByRelationAggregateInput
  }

  export type MediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MediaWhereInput | MediaWhereInput[]
    OR?: MediaWhereInput[]
    NOT?: MediaWhereInput | MediaWhereInput[]
    filename?: StringFilter<"Media"> | string
    originalName?: StringFilter<"Media"> | string
    url?: StringFilter<"Media"> | string
    thumbnailUrl?: StringNullableFilter<"Media"> | string | null
    category?: EnumMediaCategoryFilter<"Media"> | $Enums.MediaCategory
    altTextGr?: StringNullableFilter<"Media"> | string | null
    altTextEn?: StringNullableFilter<"Media"> | string | null
    mimeType?: StringFilter<"Media"> | string
    size?: IntFilter<"Media"> | number
    width?: IntNullableFilter<"Media"> | number | null
    height?: IntNullableFilter<"Media"> | number | null
    createdAt?: DateTimeFilter<"Media"> | Date | string
    updatedAt?: DateTimeFilter<"Media"> | Date | string
    content?: ContentMediaListRelationFilter
  }, "id">

  export type MediaOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrderInput | SortOrder
    category?: SortOrder
    altTextGr?: SortOrderInput | SortOrder
    altTextEn?: SortOrderInput | SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrderInput | SortOrder
    height?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MediaCountOrderByAggregateInput
    _avg?: MediaAvgOrderByAggregateInput
    _max?: MediaMaxOrderByAggregateInput
    _min?: MediaMinOrderByAggregateInput
    _sum?: MediaSumOrderByAggregateInput
  }

  export type MediaScalarWhereWithAggregatesInput = {
    AND?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    OR?: MediaScalarWhereWithAggregatesInput[]
    NOT?: MediaScalarWhereWithAggregatesInput | MediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Media"> | string
    filename?: StringWithAggregatesFilter<"Media"> | string
    originalName?: StringWithAggregatesFilter<"Media"> | string
    url?: StringWithAggregatesFilter<"Media"> | string
    thumbnailUrl?: StringNullableWithAggregatesFilter<"Media"> | string | null
    category?: EnumMediaCategoryWithAggregatesFilter<"Media"> | $Enums.MediaCategory
    altTextGr?: StringNullableWithAggregatesFilter<"Media"> | string | null
    altTextEn?: StringNullableWithAggregatesFilter<"Media"> | string | null
    mimeType?: StringWithAggregatesFilter<"Media"> | string
    size?: IntWithAggregatesFilter<"Media"> | number
    width?: IntNullableWithAggregatesFilter<"Media"> | number | null
    height?: IntNullableWithAggregatesFilter<"Media"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Media"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    type?: EnumSettingTypeFilter<"Setting"> | $Enums.SettingType
    group?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    group?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
    type?: EnumSettingTypeFilter<"Setting"> | $Enums.SettingType
    group?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    group?: SortOrder
    description?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    type?: EnumSettingTypeWithAggregatesFilter<"Setting"> | $Enums.SettingType
    group?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type RoomContentWhereInput = {
    AND?: RoomContentWhereInput | RoomContentWhereInput[]
    OR?: RoomContentWhereInput[]
    NOT?: RoomContentWhereInput | RoomContentWhereInput[]
    id?: StringFilter<"RoomContent"> | string
    roomId?: StringFilter<"RoomContent"> | string
    highlightsGr?: StringNullableFilter<"RoomContent"> | string | null
    highlightsEn?: StringNullableFilter<"RoomContent"> | string | null
    featuresGr?: JsonNullableFilter<"RoomContent">
    featuresEn?: JsonNullableFilter<"RoomContent">
    virtualTourUrl?: StringNullableFilter<"RoomContent"> | string | null
    floorPlanUrl?: StringNullableFilter<"RoomContent"> | string | null
    metaTitleGr?: StringNullableFilter<"RoomContent"> | string | null
    metaTitleEn?: StringNullableFilter<"RoomContent"> | string | null
    metaDescriptionGr?: StringNullableFilter<"RoomContent"> | string | null
    metaDescriptionEn?: StringNullableFilter<"RoomContent"> | string | null
    amenitiesDetails?: JsonNullableFilter<"RoomContent">
    createdAt?: DateTimeFilter<"RoomContent"> | Date | string
    updatedAt?: DateTimeFilter<"RoomContent"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
  }

  export type RoomContentOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    highlightsGr?: SortOrderInput | SortOrder
    highlightsEn?: SortOrderInput | SortOrder
    featuresGr?: SortOrderInput | SortOrder
    featuresEn?: SortOrderInput | SortOrder
    virtualTourUrl?: SortOrderInput | SortOrder
    floorPlanUrl?: SortOrderInput | SortOrder
    metaTitleGr?: SortOrderInput | SortOrder
    metaTitleEn?: SortOrderInput | SortOrder
    metaDescriptionGr?: SortOrderInput | SortOrder
    metaDescriptionEn?: SortOrderInput | SortOrder
    amenitiesDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
  }

  export type RoomContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    roomId?: string
    AND?: RoomContentWhereInput | RoomContentWhereInput[]
    OR?: RoomContentWhereInput[]
    NOT?: RoomContentWhereInput | RoomContentWhereInput[]
    highlightsGr?: StringNullableFilter<"RoomContent"> | string | null
    highlightsEn?: StringNullableFilter<"RoomContent"> | string | null
    featuresGr?: JsonNullableFilter<"RoomContent">
    featuresEn?: JsonNullableFilter<"RoomContent">
    virtualTourUrl?: StringNullableFilter<"RoomContent"> | string | null
    floorPlanUrl?: StringNullableFilter<"RoomContent"> | string | null
    metaTitleGr?: StringNullableFilter<"RoomContent"> | string | null
    metaTitleEn?: StringNullableFilter<"RoomContent"> | string | null
    metaDescriptionGr?: StringNullableFilter<"RoomContent"> | string | null
    metaDescriptionEn?: StringNullableFilter<"RoomContent"> | string | null
    amenitiesDetails?: JsonNullableFilter<"RoomContent">
    createdAt?: DateTimeFilter<"RoomContent"> | Date | string
    updatedAt?: DateTimeFilter<"RoomContent"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
  }, "id" | "roomId">

  export type RoomContentOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    highlightsGr?: SortOrderInput | SortOrder
    highlightsEn?: SortOrderInput | SortOrder
    featuresGr?: SortOrderInput | SortOrder
    featuresEn?: SortOrderInput | SortOrder
    virtualTourUrl?: SortOrderInput | SortOrder
    floorPlanUrl?: SortOrderInput | SortOrder
    metaTitleGr?: SortOrderInput | SortOrder
    metaTitleEn?: SortOrderInput | SortOrder
    metaDescriptionGr?: SortOrderInput | SortOrder
    metaDescriptionEn?: SortOrderInput | SortOrder
    amenitiesDetails?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomContentCountOrderByAggregateInput
    _max?: RoomContentMaxOrderByAggregateInput
    _min?: RoomContentMinOrderByAggregateInput
  }

  export type RoomContentScalarWhereWithAggregatesInput = {
    AND?: RoomContentScalarWhereWithAggregatesInput | RoomContentScalarWhereWithAggregatesInput[]
    OR?: RoomContentScalarWhereWithAggregatesInput[]
    NOT?: RoomContentScalarWhereWithAggregatesInput | RoomContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomContent"> | string
    roomId?: StringWithAggregatesFilter<"RoomContent"> | string
    highlightsGr?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    highlightsEn?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    featuresGr?: JsonNullableWithAggregatesFilter<"RoomContent">
    featuresEn?: JsonNullableWithAggregatesFilter<"RoomContent">
    virtualTourUrl?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    floorPlanUrl?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    metaTitleGr?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    metaTitleEn?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    metaDescriptionGr?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    metaDescriptionEn?: StringNullableWithAggregatesFilter<"RoomContent"> | string | null
    amenitiesDetails?: JsonNullableWithAggregatesFilter<"RoomContent">
    createdAt?: DateTimeWithAggregatesFilter<"RoomContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomContent"> | Date | string
  }

  export type RoomAvailabilityRuleWhereInput = {
    AND?: RoomAvailabilityRuleWhereInput | RoomAvailabilityRuleWhereInput[]
    OR?: RoomAvailabilityRuleWhereInput[]
    NOT?: RoomAvailabilityRuleWhereInput | RoomAvailabilityRuleWhereInput[]
    id?: StringFilter<"RoomAvailabilityRule"> | string
    roomId?: StringFilter<"RoomAvailabilityRule"> | string
    startDate?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    endDate?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    isAvailable?: BoolFilter<"RoomAvailabilityRule"> | boolean
    reason?: StringNullableFilter<"RoomAvailabilityRule"> | string | null
    priceOverride?: FloatNullableFilter<"RoomAvailabilityRule"> | number | null
    minStayOverride?: IntNullableFilter<"RoomAvailabilityRule"> | number | null
    createdAt?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
  }

  export type RoomAvailabilityRuleOrderByWithRelationInput = {
    id?: SortOrder
    roomId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrderInput | SortOrder
    priceOverride?: SortOrderInput | SortOrder
    minStayOverride?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    room?: RoomOrderByWithRelationInput
  }

  export type RoomAvailabilityRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoomAvailabilityRuleWhereInput | RoomAvailabilityRuleWhereInput[]
    OR?: RoomAvailabilityRuleWhereInput[]
    NOT?: RoomAvailabilityRuleWhereInput | RoomAvailabilityRuleWhereInput[]
    roomId?: StringFilter<"RoomAvailabilityRule"> | string
    startDate?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    endDate?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    isAvailable?: BoolFilter<"RoomAvailabilityRule"> | boolean
    reason?: StringNullableFilter<"RoomAvailabilityRule"> | string | null
    priceOverride?: FloatNullableFilter<"RoomAvailabilityRule"> | number | null
    minStayOverride?: IntNullableFilter<"RoomAvailabilityRule"> | number | null
    createdAt?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    room?: XOR<RoomScalarRelationFilter, RoomWhereInput>
  }, "id">

  export type RoomAvailabilityRuleOrderByWithAggregationInput = {
    id?: SortOrder
    roomId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrderInput | SortOrder
    priceOverride?: SortOrderInput | SortOrder
    minStayOverride?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoomAvailabilityRuleCountOrderByAggregateInput
    _avg?: RoomAvailabilityRuleAvgOrderByAggregateInput
    _max?: RoomAvailabilityRuleMaxOrderByAggregateInput
    _min?: RoomAvailabilityRuleMinOrderByAggregateInput
    _sum?: RoomAvailabilityRuleSumOrderByAggregateInput
  }

  export type RoomAvailabilityRuleScalarWhereWithAggregatesInput = {
    AND?: RoomAvailabilityRuleScalarWhereWithAggregatesInput | RoomAvailabilityRuleScalarWhereWithAggregatesInput[]
    OR?: RoomAvailabilityRuleScalarWhereWithAggregatesInput[]
    NOT?: RoomAvailabilityRuleScalarWhereWithAggregatesInput | RoomAvailabilityRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoomAvailabilityRule"> | string
    roomId?: StringWithAggregatesFilter<"RoomAvailabilityRule"> | string
    startDate?: DateTimeWithAggregatesFilter<"RoomAvailabilityRule"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"RoomAvailabilityRule"> | Date | string
    isAvailable?: BoolWithAggregatesFilter<"RoomAvailabilityRule"> | boolean
    reason?: StringNullableWithAggregatesFilter<"RoomAvailabilityRule"> | string | null
    priceOverride?: FloatNullableWithAggregatesFilter<"RoomAvailabilityRule"> | number | null
    minStayOverride?: IntNullableWithAggregatesFilter<"RoomAvailabilityRule"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"RoomAvailabilityRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoomAvailabilityRule"> | Date | string
  }

  export type InquiryWhereInput = {
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    id?: StringFilter<"Inquiry"> | string
    propertyId?: StringFilter<"Inquiry"> | string
    name?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFilter<"Inquiry"> | $Enums.InquiryPriority
    respondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    respondedBy?: StringNullableFilter<"Inquiry"> | string | null
    response?: StringNullableFilter<"Inquiry"> | string | null
    adminNotes?: StringNullableFilter<"Inquiry"> | string | null
    assignedTo?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }

  export type InquiryOrderByWithRelationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    property?: PropertyOrderByWithRelationInput
    assignee?: UserOrderByWithRelationInput
  }

  export type InquiryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InquiryWhereInput | InquiryWhereInput[]
    OR?: InquiryWhereInput[]
    NOT?: InquiryWhereInput | InquiryWhereInput[]
    propertyId?: StringFilter<"Inquiry"> | string
    name?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFilter<"Inquiry"> | $Enums.InquiryPriority
    respondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    respondedBy?: StringNullableFilter<"Inquiry"> | string | null
    response?: StringNullableFilter<"Inquiry"> | string | null
    adminNotes?: StringNullableFilter<"Inquiry"> | string | null
    assignedTo?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
    property?: XOR<PropertyScalarRelationFilter, PropertyWhereInput>
    assignee?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
  }, "id">

  export type InquiryOrderByWithAggregationInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    respondedBy?: SortOrderInput | SortOrder
    response?: SortOrderInput | SortOrder
    adminNotes?: SortOrderInput | SortOrder
    assignedTo?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InquiryCountOrderByAggregateInput
    _max?: InquiryMaxOrderByAggregateInput
    _min?: InquiryMinOrderByAggregateInput
  }

  export type InquiryScalarWhereWithAggregatesInput = {
    AND?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    OR?: InquiryScalarWhereWithAggregatesInput[]
    NOT?: InquiryScalarWhereWithAggregatesInput | InquiryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Inquiry"> | string
    propertyId?: StringWithAggregatesFilter<"Inquiry"> | string
    name?: StringWithAggregatesFilter<"Inquiry"> | string
    email?: StringWithAggregatesFilter<"Inquiry"> | string
    phone?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    message?: StringWithAggregatesFilter<"Inquiry"> | string
    status?: EnumInquiryStatusWithAggregatesFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityWithAggregatesFilter<"Inquiry"> | $Enums.InquiryPriority
    respondedAt?: DateTimeNullableWithAggregatesFilter<"Inquiry"> | Date | string | null
    respondedBy?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    response?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    adminNotes?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    assignedTo?: StringNullableWithAggregatesFilter<"Inquiry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Inquiry"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateManyInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityCreateInput = {
    id?: string
    nameGr: string
    nameEn: string
    icon?: string | null
    category: string
    createdAt?: Date | string
    properties?: PropertyAmenityCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUncheckedCreateInput = {
    id?: string
    nameGr: string
    nameEn: string
    icon?: string | null
    category: string
    createdAt?: Date | string
    properties?: PropertyAmenityUncheckedCreateNestedManyWithoutAmenityInput
  }

  export type AmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameGr?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyAmenityUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameGr?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyAmenityUncheckedUpdateManyWithoutAmenityNestedInput
  }

  export type AmenityCreateManyInput = {
    id?: string
    nameGr: string
    nameEn: string
    icon?: string | null
    category: string
    createdAt?: Date | string
  }

  export type AmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameGr?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameGr?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAmenityCreateInput = {
    id?: string
    property: PropertyCreateNestedOneWithoutAmenitiesInput
    amenity: AmenityCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyAmenityUncheckedCreateInput = {
    id?: string
    propertyId: string
    amenityId: string
  }

  export type PropertyAmenityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneRequiredWithoutAmenitiesNestedInput
    amenity?: AmenityUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type PropertyAmenityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amenityId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyAmenityCreateManyInput = {
    id?: string
    propertyId: string
    amenityId: string
  }

  export type PropertyAmenityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyAmenityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amenityId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingCreateInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookingsInput
    guest: UserCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    propertyId: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookingsNestedInput
    guest?: UserUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    propertyId: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAvailabilityCreateInput = {
    id?: string
    date: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutAvailabilityInput
  }

  export type PropertyAvailabilityUncheckedCreateInput = {
    id?: string
    propertyId: string
    date: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAvailabilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type PropertyAvailabilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAvailabilityCreateManyInput = {
    id?: string
    propertyId: string
    date: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAvailabilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAvailabilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutReviewsInput
    booking: BookingCreateNestedOneWithoutReviewsInput
    guest: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    propertyId: string
    bookingId: string
    guestId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReviewsNestedInput
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
    guest?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateManyInput = {
    id?: string
    propertyId: string
    bookingId: string
    guestId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestCreateInput = {
    id?: string
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutMaintenanceInput
    booking?: BookingCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceRequestUncheckedCreateInput = {
    id?: string
    propertyId: string
    bookingId?: string | null
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutMaintenanceNestedInput
    booking?: BookingUpdateOneWithoutMaintenanceNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestCreateManyInput = {
    id?: string
    propertyId: string
    bookingId?: string | null
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    bookingId: string
    senderId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    bookingId: string
    senderId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    userId: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditionCreateInput = {
    id?: string
    category: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    contentGr?: string | null
    contentEn?: string | null
    status?: $Enums.ContentStatus
    featured?: boolean
    order?: number | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditionUncheckedCreateInput = {
    id?: string
    category: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    contentGr?: string | null
    contentEn?: string | null
    status?: $Enums.ContentStatus
    featured?: boolean
    order?: number | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditionCreateManyInput = {
    id?: string
    category: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    contentGr?: string | null
    contentEn?: string | null
    status?: $Enums.ContentStatus
    featured?: boolean
    order?: number | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EditionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EditionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumContentStatusFieldUpdateOperationsInput | $Enums.ContentStatus
    featured?: BoolFieldUpdateOperationsInput | boolean
    order?: NullableIntFieldUpdateOperationsInput | number | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    icon?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: string | null
    pricingEn?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    icon?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: string | null
    pricingEn?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: NullableStringFieldUpdateOperationsInput | string | null
    pricingEn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: NullableStringFieldUpdateOperationsInput | string | null
    pricingEn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    icon?: string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: string | null
    pricingEn?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: NullableStringFieldUpdateOperationsInput | string | null
    pricingEn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    features?: NullableJsonNullValueInput | InputJsonValue
    pricingGr?: NullableStringFieldUpdateOperationsInput | string | null
    pricingEn?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleCreateInput = {
    id?: string
    titleGr: string
    titleEn: string
    contentGr?: string | null
    contentEn?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author: string
    readTime?: number | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeArticleUncheckedCreateInput = {
    id?: string
    titleGr: string
    titleEn: string
    contentGr?: string | null
    contentEn?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author: string
    readTime?: number | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeArticleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleCreateManyInput = {
    id?: string
    titleGr: string
    titleEn: string
    contentGr?: string | null
    contentEn?: string | null
    category: string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author: string
    readTime?: number | null
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type KnowledgeArticleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type KnowledgeArticleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    tags?: NullableJsonNullValueInput | InputJsonValue
    author?: StringFieldUpdateOperationsInput | string
    readTime?: NullableIntFieldUpdateOperationsInput | number | null
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
    property: PropertyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    propertyId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
    property?: PropertyUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: string
    propertyId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRoomsInput
    owner: UserCreateNestedOneWithoutRoomsInput
    roomContent?: RoomContentCreateNestedOneWithoutRoomInput
    availabilityRules?: RoomAvailabilityRuleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateInput = {
    id?: string
    propertyId: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomContent?: RoomContentUncheckedCreateNestedOneWithoutRoomInput
    availabilityRules?: RoomAvailabilityRuleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRoomsNestedInput
    owner?: UserUpdateOneRequiredWithoutRoomsNestedInput
    roomContent?: RoomContentUpdateOneWithoutRoomNestedInput
    availabilityRules?: RoomAvailabilityRuleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomContent?: RoomContentUncheckedUpdateOneWithoutRoomNestedInput
    availabilityRules?: RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateManyInput = {
    id?: string
    propertyId: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyGroupCreateInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertyGroupsInput
    properties?: PropertyCreateNestedManyWithoutPropertyGroupInput
  }

  export type PropertyGroupUncheckedCreateInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyGroupInput
  }

  export type PropertyGroupUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertyGroupsNestedInput
    properties?: PropertyUpdateManyWithoutPropertyGroupNestedInput
  }

  export type PropertyGroupUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutPropertyGroupNestedInput
  }

  export type PropertyGroupCreateManyInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyGroupUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyGroupUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleCreateInput = {
    id?: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSchedulesInput
    owner: UserCreateNestedOneWithoutCleaningSchedulesInput
  }

  export type CleaningScheduleUncheckedCreateInput = {
    id?: string
    propertyId: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    ownerId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningScheduleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSchedulesNestedInput
    owner?: UserUpdateOneRequiredWithoutCleaningSchedulesNestedInput
  }

  export type CleaningScheduleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleCreateManyInput = {
    id?: string
    propertyId: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    ownerId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningScheduleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAnalyticsCreateInput = {
    id?: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
    periodEnd: Date | string
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom?: number | null
    averageRating?: number | null
    averageCleanlinessRating?: number | null
    totalReviews: number
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutAnalyticsInput
  }

  export type PropertyAnalyticsUncheckedCreateInput = {
    id?: string
    propertyId: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
    periodEnd: Date | string
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom?: number | null
    averageRating?: number | null
    averageCleanlinessRating?: number | null
    totalReviews: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAnalyticsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutAnalyticsNestedInput
  }

  export type PropertyAnalyticsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAnalyticsCreateManyInput = {
    id?: string
    propertyId: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
    periodEnd: Date | string
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom?: number | null
    averageRating?: number | null
    averageCleanlinessRating?: number | null
    totalReviews: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAnalyticsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAnalyticsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyNoteCreateInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutNotesInput
  }

  export type PropertyNoteUncheckedCreateInput = {
    id?: string
    propertyId: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyNoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutNotesNestedInput
  }

  export type PropertyNoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyNoteCreateManyInput = {
    id?: string
    propertyId: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyNoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyNoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutAuditLogsInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAuditLogsNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId: string
    action: string
    entityType: string
    entityId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentCreateInput = {
    id?: string
    page: string
    section: string
    key: string
    contentGr?: string | null
    contentEn?: string | null
    type?: $Enums.ContentType
    order?: number
    active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ContentMediaCreateNestedManyWithoutContentInput
  }

  export type ContentUncheckedCreateInput = {
    id?: string
    page: string
    section: string
    key: string
    contentGr?: string | null
    contentEn?: string | null
    type?: $Enums.ContentType
    order?: number
    active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    media?: ContentMediaUncheckedCreateNestedManyWithoutContentInput
  }

  export type ContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ContentMediaUpdateManyWithoutContentNestedInput
  }

  export type ContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    media?: ContentMediaUncheckedUpdateManyWithoutContentNestedInput
  }

  export type ContentCreateManyInput = {
    id?: string
    page: string
    section: string
    key: string
    contentGr?: string | null
    contentEn?: string | null
    type?: $Enums.ContentType
    order?: number
    active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentMediaCreateInput = {
    id?: string
    order?: number
    content: ContentCreateNestedOneWithoutMediaInput
    media: MediaCreateNestedOneWithoutContentInput
  }

  export type ContentMediaUncheckedCreateInput = {
    id?: string
    contentId: string
    mediaId: string
    order?: number
  }

  export type ContentMediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: ContentUpdateOneRequiredWithoutMediaNestedInput
    media?: MediaUpdateOneRequiredWithoutContentNestedInput
  }

  export type ContentMediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ContentMediaCreateManyInput = {
    id?: string
    contentId: string
    mediaId: string
    order?: number
  }

  export type ContentMediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ContentMediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type MediaCreateInput = {
    id?: string
    filename: string
    originalName: string
    url: string
    thumbnailUrl?: string | null
    category?: $Enums.MediaCategory
    altTextGr?: string | null
    altTextEn?: string | null
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: ContentMediaCreateNestedManyWithoutMediaInput
  }

  export type MediaUncheckedCreateInput = {
    id?: string
    filename: string
    originalName: string
    url: string
    thumbnailUrl?: string | null
    category?: $Enums.MediaCategory
    altTextGr?: string | null
    altTextEn?: string | null
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    content?: ContentMediaUncheckedCreateNestedManyWithoutMediaInput
  }

  export type MediaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMediaCategoryFieldUpdateOperationsInput | $Enums.MediaCategory
    altTextGr?: NullableStringFieldUpdateOperationsInput | string | null
    altTextEn?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentMediaUpdateManyWithoutMediaNestedInput
  }

  export type MediaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMediaCategoryFieldUpdateOperationsInput | $Enums.MediaCategory
    altTextGr?: NullableStringFieldUpdateOperationsInput | string | null
    altTextEn?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: ContentMediaUncheckedUpdateManyWithoutMediaNestedInput
  }

  export type MediaCreateManyInput = {
    id?: string
    filename: string
    originalName: string
    url: string
    thumbnailUrl?: string | null
    category?: $Enums.MediaCategory
    altTextGr?: string | null
    altTextEn?: string | null
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMediaCategoryFieldUpdateOperationsInput | $Enums.MediaCategory
    altTextGr?: NullableStringFieldUpdateOperationsInput | string | null
    altTextEn?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMediaCategoryFieldUpdateOperationsInput | $Enums.MediaCategory
    altTextGr?: NullableStringFieldUpdateOperationsInput | string | null
    altTextEn?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id?: string
    key: string
    value: string
    type?: $Enums.SettingType
    group?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id?: string
    key: string
    value: string
    type?: $Enums.SettingType
    group?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    group?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    group?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id?: string
    key: string
    value: string
    type?: $Enums.SettingType
    group?: string
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    group?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    type?: EnumSettingTypeFieldUpdateOperationsInput | $Enums.SettingType
    group?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomContentCreateInput = {
    id?: string
    highlightsGr?: string | null
    highlightsEn?: string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: string | null
    floorPlanUrl?: string | null
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutRoomContentInput
  }

  export type RoomContentUncheckedCreateInput = {
    id?: string
    roomId: string
    highlightsGr?: string | null
    highlightsEn?: string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: string | null
    floorPlanUrl?: string | null
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightsGr?: NullableStringFieldUpdateOperationsInput | string | null
    highlightsEn?: NullableStringFieldUpdateOperationsInput | string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: NullableStringFieldUpdateOperationsInput | string | null
    floorPlanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutRoomContentNestedInput
  }

  export type RoomContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    highlightsGr?: NullableStringFieldUpdateOperationsInput | string | null
    highlightsEn?: NullableStringFieldUpdateOperationsInput | string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: NullableStringFieldUpdateOperationsInput | string | null
    floorPlanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomContentCreateManyInput = {
    id?: string
    roomId: string
    highlightsGr?: string | null
    highlightsEn?: string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: string | null
    floorPlanUrl?: string | null
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightsGr?: NullableStringFieldUpdateOperationsInput | string | null
    highlightsEn?: NullableStringFieldUpdateOperationsInput | string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: NullableStringFieldUpdateOperationsInput | string | null
    floorPlanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    highlightsGr?: NullableStringFieldUpdateOperationsInput | string | null
    highlightsEn?: NullableStringFieldUpdateOperationsInput | string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: NullableStringFieldUpdateOperationsInput | string | null
    floorPlanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleCreateInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    isAvailable?: boolean
    reason?: string | null
    priceOverride?: number | null
    minStayOverride?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    room: RoomCreateNestedOneWithoutAvailabilityRulesInput
  }

  export type RoomAvailabilityRuleUncheckedCreateInput = {
    id?: string
    roomId: string
    startDate: Date | string
    endDate: Date | string
    isAvailable?: boolean
    reason?: string | null
    priceOverride?: number | null
    minStayOverride?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAvailabilityRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    room?: RoomUpdateOneRequiredWithoutAvailabilityRulesNestedInput
  }

  export type RoomAvailabilityRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleCreateManyInput = {
    id?: string
    roomId: string
    startDate: Date | string
    endDate: Date | string
    isAvailable?: boolean
    reason?: string | null
    priceOverride?: number | null
    minStayOverride?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAvailabilityRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roomId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInquiriesInput
    assignee?: UserCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateInput = {
    id?: string
    propertyId: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInquiriesNestedInput
    assignee?: UserUpdateOneWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryCreateManyInput = {
    id?: string
    propertyId: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type PropertyListRelationFilter = {
    every?: PropertyWhereInput
    some?: PropertyWhereInput
    none?: PropertyWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type PropertyGroupListRelationFilter = {
    every?: PropertyGroupWhereInput
    some?: PropertyGroupWhereInput
    none?: PropertyGroupWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type CleaningScheduleListRelationFilter = {
    every?: CleaningScheduleWhereInput
    some?: CleaningScheduleWhereInput
    none?: CleaningScheduleWhereInput
  }

  export type InquiryListRelationFilter = {
    every?: InquiryWhereInput
    some?: InquiryWhereInput
    none?: InquiryWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PropertyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyGroupOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CleaningScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InquiryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    mfaBackupCodes?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
    preferredCurrency?: SortOrder
    preferredLanguage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
    preferredCurrency?: SortOrder
    preferredLanguage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    name?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    role?: SortOrder
    avatar?: SortOrder
    isActive?: SortOrder
    mfaEnabled?: SortOrder
    mfaSecret?: SortOrder
    emailVerified?: SortOrder
    phoneVerified?: SortOrder
    stripeAccountId?: SortOrder
    stripeAccountStatus?: SortOrder
    preferredCurrency?: SortOrder
    preferredLanguage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[]
    notIn?: $Enums.PropertyType[]
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type EnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[]
    notIn?: $Enums.PropertyStatus[]
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EnumCancellationPolicyFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicy | EnumCancellationPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicy[]
    notIn?: $Enums.CancellationPolicy[]
    not?: NestedEnumCancellationPolicyFilter<$PrismaModel> | $Enums.CancellationPolicy
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PropertyAmenityListRelationFilter = {
    every?: PropertyAmenityWhereInput
    some?: PropertyAmenityWhereInput
    none?: PropertyAmenityWhereInput
  }

  export type PropertyAvailabilityListRelationFilter = {
    every?: PropertyAvailabilityWhereInput
    some?: PropertyAvailabilityWhereInput
    none?: PropertyAvailabilityWhereInput
  }

  export type MaintenanceRequestListRelationFilter = {
    every?: MaintenanceRequestWhereInput
    some?: MaintenanceRequestWhereInput
    none?: MaintenanceRequestWhereInput
  }

  export type PropertyNoteListRelationFilter = {
    every?: PropertyNoteWhereInput
    some?: PropertyNoteWhereInput
    none?: PropertyNoteWhereInput
  }

  export type PropertyAnalyticsListRelationFilter = {
    every?: PropertyAnalyticsWhereInput
    some?: PropertyAnalyticsWhereInput
    none?: PropertyAnalyticsWhereInput
  }

  export type PropertyGroupNullableScalarRelationFilter = {
    is?: PropertyGroupWhereInput | null
    isNot?: PropertyGroupWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PropertyAmenityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyAvailabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaintenanceRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyNoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyAnalyticsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PropertyCountOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    type?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    postalCode?: SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    cleaningFee?: SortOrder
    serviceFeePercentage?: SortOrder
    taxes?: SortOrder
    taxRate?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    advanceBooking?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrder
    petFriendly?: SortOrder
    smokingAllowed?: SortOrder
    partyAllowed?: SortOrder
    hasDynamicRooms?: SortOrder
    averageCleanlinessRating?: SortOrder
    lastCleaningDate?: SortOrder
    propertyGroupId?: SortOrder
    images?: SortOrder
    videos?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFeePercentage?: SortOrder
    taxes?: SortOrder
    taxRate?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    advanceBooking?: SortOrder
    averageCleanlinessRating?: SortOrder
  }

  export type PropertyMaxOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    type?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    postalCode?: SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    cleaningFee?: SortOrder
    serviceFeePercentage?: SortOrder
    taxes?: SortOrder
    taxRate?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    advanceBooking?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrder
    petFriendly?: SortOrder
    smokingAllowed?: SortOrder
    partyAllowed?: SortOrder
    hasDynamicRooms?: SortOrder
    averageCleanlinessRating?: SortOrder
    lastCleaningDate?: SortOrder
    propertyGroupId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyMinOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    type?: SortOrder
    status?: SortOrder
    address?: SortOrder
    city?: SortOrder
    country?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    postalCode?: SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrder
    basePrice?: SortOrder
    currency?: SortOrder
    cleaningFee?: SortOrder
    serviceFeePercentage?: SortOrder
    taxes?: SortOrder
    taxRate?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    advanceBooking?: SortOrder
    checkInTime?: SortOrder
    checkOutTime?: SortOrder
    cancellationPolicy?: SortOrder
    houseRules?: SortOrder
    petFriendly?: SortOrder
    smokingAllowed?: SortOrder
    partyAllowed?: SortOrder
    hasDynamicRooms?: SortOrder
    averageCleanlinessRating?: SortOrder
    lastCleaningDate?: SortOrder
    propertyGroupId?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertySumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    maxGuests?: SortOrder
    bedrooms?: SortOrder
    bathrooms?: SortOrder
    area?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFeePercentage?: SortOrder
    taxes?: SortOrder
    taxRate?: SortOrder
    minStay?: SortOrder
    maxStay?: SortOrder
    advanceBooking?: SortOrder
    averageCleanlinessRating?: SortOrder
  }

  export type EnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[]
    notIn?: $Enums.PropertyType[]
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type EnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[]
    notIn?: $Enums.PropertyStatus[]
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumCancellationPolicyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicy | EnumCancellationPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicy[]
    notIn?: $Enums.CancellationPolicy[]
    not?: NestedEnumCancellationPolicyWithAggregatesFilter<$PrismaModel> | $Enums.CancellationPolicy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationPolicyFilter<$PrismaModel>
    _max?: NestedEnumCancellationPolicyFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type AmenityCountOrderByAggregateInput = {
    id?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type AmenityMinOrderByAggregateInput = {
    id?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    icon?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type PropertyScalarRelationFilter = {
    is?: PropertyWhereInput
    isNot?: PropertyWhereInput
  }

  export type AmenityScalarRelationFilter = {
    is?: AmenityWhereInput
    isNot?: AmenityWhereInput
  }

  export type PropertyAmenityPropertyIdAmenityIdCompoundUniqueInput = {
    propertyId: string
    amenityId: string
  }

  export type PropertyAmenityCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amenityId?: SortOrder
  }

  export type PropertyAmenityMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amenityId?: SortOrder
  }

  export type PropertyAmenityMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    amenityId?: SortOrder
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumBookingSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingSource | EnumBookingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BookingSource[]
    notIn?: $Enums.BookingSource[]
    not?: NestedEnumBookingSourceFilter<$PrismaModel> | $Enums.BookingSource
  }

  export type BookingSourceExternalIdCompoundUniqueInput = {
    source: $Enums.BookingSource
    externalId: string
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    currency?: SortOrder
    ownerRevenue?: SortOrder
    platformFee?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    externalPlatform?: SortOrder
    externalData?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    netRevenue?: SortOrder
    externalGuestId?: SortOrder
    iCalUid?: SortOrder
    lastSyncedAt?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    ownerRevenue?: SortOrder
    platformFee?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    netRevenue?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    currency?: SortOrder
    ownerRevenue?: SortOrder
    platformFee?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    externalPlatform?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    netRevenue?: SortOrder
    externalGuestId?: SortOrder
    iCalUid?: SortOrder
    lastSyncedAt?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    guestId?: SortOrder
    status?: SortOrder
    paymentStatus?: SortOrder
    checkIn?: SortOrder
    checkOut?: SortOrder
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    currency?: SortOrder
    ownerRevenue?: SortOrder
    platformFee?: SortOrder
    source?: SortOrder
    externalId?: SortOrder
    externalPlatform?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    netRevenue?: SortOrder
    externalGuestId?: SortOrder
    iCalUid?: SortOrder
    lastSyncedAt?: SortOrder
    roomId?: SortOrder
    roomName?: SortOrder
    guestName?: SortOrder
    guestEmail?: SortOrder
    guestPhone?: SortOrder
    specialRequests?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    guests?: SortOrder
    totalPrice?: SortOrder
    basePrice?: SortOrder
    cleaningFee?: SortOrder
    serviceFee?: SortOrder
    taxes?: SortOrder
    ownerRevenue?: SortOrder
    platformFee?: SortOrder
    commissionRate?: SortOrder
    commissionAmount?: SortOrder
    netRevenue?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumBookingSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingSource | EnumBookingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BookingSource[]
    notIn?: $Enums.BookingSource[]
    not?: NestedEnumBookingSourceWithAggregatesFilter<$PrismaModel> | $Enums.BookingSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingSourceFilter<$PrismaModel>
    _max?: NestedEnumBookingSourceFilter<$PrismaModel>
  }

  export type PropertyAvailabilityPropertyIdDateCompoundUniqueInput = {
    propertyId: string
    date: Date | string
  }

  export type PropertyAvailabilityCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    minStay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvailabilityAvgOrderByAggregateInput = {
    price?: SortOrder
    minStay?: SortOrder
  }

  export type PropertyAvailabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    minStay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvailabilityMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    date?: SortOrder
    available?: SortOrder
    price?: SortOrder
    minStay?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAvailabilitySumOrderByAggregateInput = {
    price?: SortOrder
    minStay?: SortOrder
  }

  export type BookingScalarRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    guestId?: SortOrder
    rating?: SortOrder
    cleanlinessRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    locationRating?: SortOrder
    valueRating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    response?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
    cleanlinessRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    locationRating?: SortOrder
    valueRating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    guestId?: SortOrder
    rating?: SortOrder
    cleanlinessRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    locationRating?: SortOrder
    valueRating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    response?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    guestId?: SortOrder
    rating?: SortOrder
    cleanlinessRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    locationRating?: SortOrder
    valueRating?: SortOrder
    title?: SortOrder
    comment?: SortOrder
    response?: SortOrder
    isPublic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
    cleanlinessRating?: SortOrder
    accuracyRating?: SortOrder
    communicationRating?: SortOrder
    locationRating?: SortOrder
    valueRating?: SortOrder
  }

  export type EnumMaintenancePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenancePriority | EnumMaintenancePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenancePriority[]
    notIn?: $Enums.MaintenancePriority[]
    not?: NestedEnumMaintenancePriorityFilter<$PrismaModel> | $Enums.MaintenancePriority
  }

  export type EnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[]
    notIn?: $Enums.MaintenanceStatus[]
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type MaintenanceRequestCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MaintenanceRequestMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    bookingId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    assignedTo?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumMaintenancePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenancePriority | EnumMaintenancePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenancePriority[]
    notIn?: $Enums.MaintenancePriority[]
    not?: NestedEnumMaintenancePriorityWithAggregatesFilter<$PrismaModel> | $Enums.MaintenancePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenancePriorityFilter<$PrismaModel>
    _max?: NestedEnumMaintenancePriorityFilter<$PrismaModel>
  }

  export type EnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[]
    notIn?: $Enums.MaintenanceStatus[]
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type EnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type EnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[]
    notIn?: $Enums.ContentStatus[]
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type EditionCountOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EditionMaxOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditionMinOrderByAggregateInput = {
    id?: SortOrder
    category?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    status?: SortOrder
    featured?: SortOrder
    order?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EditionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[]
    notIn?: $Enums.ContentStatus[]
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    icon?: SortOrder
    features?: SortOrder
    pricingGr?: SortOrder
    pricingEn?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    icon?: SortOrder
    pricingGr?: SortOrder
    pricingEn?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    icon?: SortOrder
    pricingGr?: SortOrder
    pricingEn?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeArticleCountOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    author?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeArticleAvgOrderByAggregateInput = {
    readTime?: SortOrder
  }

  export type KnowledgeArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    category?: SortOrder
    author?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeArticleMinOrderByAggregateInput = {
    id?: SortOrder
    titleGr?: SortOrder
    titleEn?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    category?: SortOrder
    author?: SortOrder
    readTime?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type KnowledgeArticleSumOrderByAggregateInput = {
    readTime?: SortOrder
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrder
    refundedAt?: SortOrder
    payoutId?: SortOrder
    payoutStatus?: SortOrder
    payoutScheduledFor?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
    refundAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrder
    refundedAt?: SortOrder
    payoutId?: SortOrder
    payoutStatus?: SortOrder
    payoutScheduledFor?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    propertyId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    method?: SortOrder
    transactionId?: SortOrder
    stripePaymentIntentId?: SortOrder
    stripeChargeId?: SortOrder
    refundAmount?: SortOrder
    refundReason?: SortOrder
    refundedAt?: SortOrder
    payoutId?: SortOrder
    payoutStatus?: SortOrder
    payoutScheduledFor?: SortOrder
    processedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
    refundAmount?: SortOrder
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type RoomContentNullableScalarRelationFilter = {
    is?: RoomContentWhereInput | null
    isNot?: RoomContentWhereInput | null
  }

  export type RoomAvailabilityRuleListRelationFilter = {
    every?: RoomAvailabilityRuleWhereInput
    some?: RoomAvailabilityRuleWhereInput
    none?: RoomAvailabilityRuleWhereInput
  }

  export type RoomAvailabilityRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    maxAdults?: SortOrder
    maxChildren?: SortOrder
    maxInfants?: SortOrder
    basePrice?: SortOrder
    isBookable?: SortOrder
    amenities?: SortOrder
    images?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    capacity?: SortOrder
    maxAdults?: SortOrder
    maxChildren?: SortOrder
    maxInfants?: SortOrder
    basePrice?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    maxAdults?: SortOrder
    maxChildren?: SortOrder
    maxInfants?: SortOrder
    basePrice?: SortOrder
    isBookable?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    type?: SortOrder
    capacity?: SortOrder
    maxAdults?: SortOrder
    maxChildren?: SortOrder
    maxInfants?: SortOrder
    basePrice?: SortOrder
    isBookable?: SortOrder
    descriptionGr?: SortOrder
    descriptionEn?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    capacity?: SortOrder
    maxAdults?: SortOrder
    maxChildren?: SortOrder
    maxInfants?: SortOrder
    basePrice?: SortOrder
  }

  export type EnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type PropertyGroupCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyGroupMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyGroupMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameGr?: SortOrder
    nameEn?: SortOrder
    description?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCleaningFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.CleaningFrequency | EnumCleaningFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.CleaningFrequency[]
    notIn?: $Enums.CleaningFrequency[]
    not?: NestedEnumCleaningFrequencyFilter<$PrismaModel> | $Enums.CleaningFrequency
  }

  export type CleaningScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    frequency?: SortOrder
    lastCleaned?: SortOrder
    nextCleaning?: SortOrder
    assignedCleaner?: SortOrder
    ownerId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    frequency?: SortOrder
    lastCleaned?: SortOrder
    nextCleaning?: SortOrder
    assignedCleaner?: SortOrder
    ownerId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CleaningScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    frequency?: SortOrder
    lastCleaned?: SortOrder
    nextCleaning?: SortOrder
    assignedCleaner?: SortOrder
    ownerId?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCleaningFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CleaningFrequency | EnumCleaningFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.CleaningFrequency[]
    notIn?: $Enums.CleaningFrequency[]
    not?: NestedEnumCleaningFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.CleaningFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCleaningFrequencyFilter<$PrismaModel>
    _max?: NestedEnumCleaningFrequencyFilter<$PrismaModel>
  }

  export type EnumAnalyticsPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[]
    notIn?: $Enums.AnalyticsPeriod[]
    not?: NestedEnumAnalyticsPeriodFilter<$PrismaModel> | $Enums.AnalyticsPeriod
  }

  export type PropertyAnalyticsPropertyIdPeriodPeriodStartCompoundUniqueInput = {
    propertyId: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
  }

  export type PropertyAnalyticsCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrder
    averageRating?: SortOrder
    averageCleanlinessRating?: SortOrder
    totalReviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAnalyticsAvgOrderByAggregateInput = {
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrder
    averageRating?: SortOrder
    averageCleanlinessRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type PropertyAnalyticsMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrder
    averageRating?: SortOrder
    averageCleanlinessRating?: SortOrder
    totalReviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAnalyticsMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    period?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrder
    averageRating?: SortOrder
    averageCleanlinessRating?: SortOrder
    totalReviews?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyAnalyticsSumOrderByAggregateInput = {
    totalRevenue?: SortOrder
    totalCosts?: SortOrder
    cleaningCosts?: SortOrder
    maintenanceCosts?: SortOrder
    platformFees?: SortOrder
    netProfit?: SortOrder
    profitMargin?: SortOrder
    totalBookings?: SortOrder
    cancelledBookings?: SortOrder
    occupancyRate?: SortOrder
    averageDailyRate?: SortOrder
    revenuePerAvailableRoom?: SortOrder
    averageRating?: SortOrder
    averageCleanlinessRating?: SortOrder
    totalReviews?: SortOrder
  }

  export type EnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[]
    notIn?: $Enums.AnalyticsPeriod[]
    not?: NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel> | $Enums.AnalyticsPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
    _max?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
  }

  export type EnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[]
    notIn?: $Enums.NoteType[]
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type PropertyNoteCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyNoteMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PropertyNoteMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isPrivate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[]
    notIn?: $Enums.NoteType[]
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    changes?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[]
    notIn?: $Enums.ContentType[]
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type ContentMediaListRelationFilter = {
    every?: ContentMediaWhereInput
    some?: ContentMediaWhereInput
    none?: ContentMediaWhereInput
  }

  export type ContentMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContentPageSectionKeyCompoundUniqueInput = {
    page: string
    section: string
    key: string
  }

  export type ContentCountOrderByAggregateInput = {
    id?: SortOrder
    page?: SortOrder
    section?: SortOrder
    key?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    type?: SortOrder
    order?: SortOrder
    active?: SortOrder
    metadata?: SortOrder
    metaTitleGr?: SortOrder
    metaTitleEn?: SortOrder
    metaDescriptionGr?: SortOrder
    metaDescriptionEn?: SortOrder
    keywords?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentMaxOrderByAggregateInput = {
    id?: SortOrder
    page?: SortOrder
    section?: SortOrder
    key?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    type?: SortOrder
    order?: SortOrder
    active?: SortOrder
    metaTitleGr?: SortOrder
    metaTitleEn?: SortOrder
    metaDescriptionGr?: SortOrder
    metaDescriptionEn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentMinOrderByAggregateInput = {
    id?: SortOrder
    page?: SortOrder
    section?: SortOrder
    key?: SortOrder
    contentGr?: SortOrder
    contentEn?: SortOrder
    type?: SortOrder
    order?: SortOrder
    active?: SortOrder
    metaTitleGr?: SortOrder
    metaTitleEn?: SortOrder
    metaDescriptionGr?: SortOrder
    metaDescriptionEn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContentSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[]
    notIn?: $Enums.ContentType[]
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type ContentScalarRelationFilter = {
    is?: ContentWhereInput
    isNot?: ContentWhereInput
  }

  export type MediaScalarRelationFilter = {
    is?: MediaWhereInput
    isNot?: MediaWhereInput
  }

  export type ContentMediaContentIdMediaIdCompoundUniqueInput = {
    contentId: string
    mediaId: string
  }

  export type ContentMediaCountOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    mediaId?: SortOrder
    order?: SortOrder
  }

  export type ContentMediaAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ContentMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    mediaId?: SortOrder
    order?: SortOrder
  }

  export type ContentMediaMinOrderByAggregateInput = {
    id?: SortOrder
    contentId?: SortOrder
    mediaId?: SortOrder
    order?: SortOrder
  }

  export type ContentMediaSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumMediaCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaCategory | EnumMediaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MediaCategory[]
    notIn?: $Enums.MediaCategory[]
    not?: NestedEnumMediaCategoryFilter<$PrismaModel> | $Enums.MediaCategory
  }

  export type MediaCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    category?: SortOrder
    altTextGr?: SortOrder
    altTextEn?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaAvgOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type MediaMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    category?: SortOrder
    altTextGr?: SortOrder
    altTextEn?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    url?: SortOrder
    thumbnailUrl?: SortOrder
    category?: SortOrder
    altTextGr?: SortOrder
    altTextEn?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MediaSumOrderByAggregateInput = {
    size?: SortOrder
    width?: SortOrder
    height?: SortOrder
  }

  export type EnumMediaCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaCategory | EnumMediaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MediaCategory[]
    notIn?: $Enums.MediaCategory[]
    not?: NestedEnumMediaCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MediaCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaCategoryFilter<$PrismaModel>
    _max?: NestedEnumMediaCategoryFilter<$PrismaModel>
  }

  export type EnumSettingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeFilter<$PrismaModel> | $Enums.SettingType
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    type?: SortOrder
    group?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSettingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeWithAggregatesFilter<$PrismaModel> | $Enums.SettingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSettingTypeFilter<$PrismaModel>
    _max?: NestedEnumSettingTypeFilter<$PrismaModel>
  }

  export type RoomScalarRelationFilter = {
    is?: RoomWhereInput
    isNot?: RoomWhereInput
  }

  export type RoomContentCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    highlightsGr?: SortOrder
    highlightsEn?: SortOrder
    featuresGr?: SortOrder
    featuresEn?: SortOrder
    virtualTourUrl?: SortOrder
    floorPlanUrl?: SortOrder
    metaTitleGr?: SortOrder
    metaTitleEn?: SortOrder
    metaDescriptionGr?: SortOrder
    metaDescriptionEn?: SortOrder
    amenitiesDetails?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomContentMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    highlightsGr?: SortOrder
    highlightsEn?: SortOrder
    virtualTourUrl?: SortOrder
    floorPlanUrl?: SortOrder
    metaTitleGr?: SortOrder
    metaTitleEn?: SortOrder
    metaDescriptionGr?: SortOrder
    metaDescriptionEn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomContentMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    highlightsGr?: SortOrder
    highlightsEn?: SortOrder
    virtualTourUrl?: SortOrder
    floorPlanUrl?: SortOrder
    metaTitleGr?: SortOrder
    metaTitleEn?: SortOrder
    metaDescriptionGr?: SortOrder
    metaDescriptionEn?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvailabilityRuleCountOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    priceOverride?: SortOrder
    minStayOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvailabilityRuleAvgOrderByAggregateInput = {
    priceOverride?: SortOrder
    minStayOverride?: SortOrder
  }

  export type RoomAvailabilityRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    priceOverride?: SortOrder
    minStayOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvailabilityRuleMinOrderByAggregateInput = {
    id?: SortOrder
    roomId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAvailable?: SortOrder
    reason?: SortOrder
    priceOverride?: SortOrder
    minStayOverride?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoomAvailabilityRuleSumOrderByAggregateInput = {
    priceOverride?: SortOrder
    minStayOverride?: SortOrder
  }

  export type EnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[]
    notIn?: $Enums.InquiryStatus[]
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type EnumInquiryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[]
    notIn?: $Enums.InquiryPriority[]
    not?: NestedEnumInquiryPriorityFilter<$PrismaModel> | $Enums.InquiryPriority
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type InquiryCountOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    response?: SortOrder
    adminNotes?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquiryMaxOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    response?: SortOrder
    adminNotes?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InquiryMinOrderByAggregateInput = {
    id?: SortOrder
    propertyId?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    message?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    respondedAt?: SortOrder
    respondedBy?: SortOrder
    response?: SortOrder
    adminNotes?: SortOrder
    assignedTo?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[]
    notIn?: $Enums.InquiryStatus[]
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type EnumInquiryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[]
    notIn?: $Enums.InquiryPriority[]
    not?: NestedEnumInquiryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InquiryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryPriorityFilter<$PrismaModel>
    _max?: NestedEnumInquiryPriorityFilter<$PrismaModel>
  }

  export type PropertyCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutGuestInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutGuestInput = {
    create?: XOR<ReviewCreateWithoutGuestInput, ReviewUncheckedCreateWithoutGuestInput> | ReviewCreateWithoutGuestInput[] | ReviewUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGuestInput | ReviewCreateOrConnectWithoutGuestInput[]
    createMany?: ReviewCreateManyGuestInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PropertyGroupCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyGroupCreateWithoutOwnerInput, PropertyGroupUncheckedCreateWithoutOwnerInput> | PropertyGroupCreateWithoutOwnerInput[] | PropertyGroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutOwnerInput | PropertyGroupCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyGroupCreateManyOwnerInputEnvelope
    connect?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutOwnerInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type CleaningScheduleCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CleaningScheduleCreateWithoutOwnerInput, CleaningScheduleUncheckedCreateWithoutOwnerInput> | CleaningScheduleCreateWithoutOwnerInput[] | CleaningScheduleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutOwnerInput | CleaningScheduleCreateOrConnectWithoutOwnerInput[]
    createMany?: CleaningScheduleCreateManyOwnerInputEnvelope
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<InquiryCreateWithoutAssigneeInput, InquiryUncheckedCreateWithoutAssigneeInput> | InquiryCreateWithoutAssigneeInput[] | InquiryUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssigneeInput | InquiryCreateOrConnectWithoutAssigneeInput[]
    createMany?: InquiryCreateManyAssigneeInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutGuestInput = {
    create?: XOR<ReviewCreateWithoutGuestInput, ReviewUncheckedCreateWithoutGuestInput> | ReviewCreateWithoutGuestInput[] | ReviewUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGuestInput | ReviewCreateOrConnectWithoutGuestInput[]
    createMany?: ReviewCreateManyGuestInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<PropertyGroupCreateWithoutOwnerInput, PropertyGroupUncheckedCreateWithoutOwnerInput> | PropertyGroupCreateWithoutOwnerInput[] | PropertyGroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutOwnerInput | PropertyGroupCreateOrConnectWithoutOwnerInput[]
    createMany?: PropertyGroupCreateManyOwnerInputEnvelope
    connect?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<CleaningScheduleCreateWithoutOwnerInput, CleaningScheduleUncheckedCreateWithoutOwnerInput> | CleaningScheduleCreateWithoutOwnerInput[] | CleaningScheduleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutOwnerInput | CleaningScheduleCreateOrConnectWithoutOwnerInput[]
    createMany?: CleaningScheduleCreateManyOwnerInputEnvelope
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutAssigneeInput = {
    create?: XOR<InquiryCreateWithoutAssigneeInput, InquiryUncheckedCreateWithoutAssigneeInput> | InquiryCreateWithoutAssigneeInput[] | InquiryUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssigneeInput | InquiryCreateOrConnectWithoutAssigneeInput[]
    createMany?: InquiryCreateManyAssigneeInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type PropertyUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutGuestNestedInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutGuestInput | BookingUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutGuestInput | BookingUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutGuestInput | BookingUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutGuestNestedInput = {
    create?: XOR<ReviewCreateWithoutGuestInput, ReviewUncheckedCreateWithoutGuestInput> | ReviewCreateWithoutGuestInput[] | ReviewUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGuestInput | ReviewCreateOrConnectWithoutGuestInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutGuestInput | ReviewUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: ReviewCreateManyGuestInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutGuestInput | ReviewUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutGuestInput | ReviewUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PropertyGroupUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyGroupCreateWithoutOwnerInput, PropertyGroupUncheckedCreateWithoutOwnerInput> | PropertyGroupCreateWithoutOwnerInput[] | PropertyGroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutOwnerInput | PropertyGroupCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyGroupUpsertWithWhereUniqueWithoutOwnerInput | PropertyGroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyGroupCreateManyOwnerInputEnvelope
    set?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    disconnect?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    delete?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    connect?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    update?: PropertyGroupUpdateWithWhereUniqueWithoutOwnerInput | PropertyGroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyGroupUpdateManyWithWhereWithoutOwnerInput | PropertyGroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyGroupScalarWhereInput | PropertyGroupScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutOwnerInput | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutOwnerInput | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutOwnerInput | RoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type CleaningScheduleUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CleaningScheduleCreateWithoutOwnerInput, CleaningScheduleUncheckedCreateWithoutOwnerInput> | CleaningScheduleCreateWithoutOwnerInput[] | CleaningScheduleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutOwnerInput | CleaningScheduleCreateOrConnectWithoutOwnerInput[]
    upsert?: CleaningScheduleUpsertWithWhereUniqueWithoutOwnerInput | CleaningScheduleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CleaningScheduleCreateManyOwnerInputEnvelope
    set?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    disconnect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    delete?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    update?: CleaningScheduleUpdateWithWhereUniqueWithoutOwnerInput | CleaningScheduleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CleaningScheduleUpdateManyWithWhereWithoutOwnerInput | CleaningScheduleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CleaningScheduleScalarWhereInput | CleaningScheduleScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<InquiryCreateWithoutAssigneeInput, InquiryUncheckedCreateWithoutAssigneeInput> | InquiryCreateWithoutAssigneeInput[] | InquiryUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssigneeInput | InquiryCreateOrConnectWithoutAssigneeInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutAssigneeInput | InquiryUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: InquiryCreateManyAssigneeInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutAssigneeInput | InquiryUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutAssigneeInput | InquiryUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput> | PropertyCreateWithoutOwnerInput[] | PropertyUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutOwnerInput | PropertyCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutOwnerInput | PropertyUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyCreateManyOwnerInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutOwnerInput | PropertyUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutOwnerInput | PropertyUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput> | BookingCreateWithoutGuestInput[] | BookingUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutGuestInput | BookingCreateOrConnectWithoutGuestInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutGuestInput | BookingUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: BookingCreateManyGuestInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutGuestInput | BookingUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutGuestInput | BookingUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutGuestNestedInput = {
    create?: XOR<ReviewCreateWithoutGuestInput, ReviewUncheckedCreateWithoutGuestInput> | ReviewCreateWithoutGuestInput[] | ReviewUncheckedCreateWithoutGuestInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutGuestInput | ReviewCreateOrConnectWithoutGuestInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutGuestInput | ReviewUpsertWithWhereUniqueWithoutGuestInput[]
    createMany?: ReviewCreateManyGuestInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutGuestInput | ReviewUpdateWithWhereUniqueWithoutGuestInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutGuestInput | ReviewUpdateManyWithWhereWithoutGuestInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<PropertyGroupCreateWithoutOwnerInput, PropertyGroupUncheckedCreateWithoutOwnerInput> | PropertyGroupCreateWithoutOwnerInput[] | PropertyGroupUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutOwnerInput | PropertyGroupCreateOrConnectWithoutOwnerInput[]
    upsert?: PropertyGroupUpsertWithWhereUniqueWithoutOwnerInput | PropertyGroupUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: PropertyGroupCreateManyOwnerInputEnvelope
    set?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    disconnect?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    delete?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    connect?: PropertyGroupWhereUniqueInput | PropertyGroupWhereUniqueInput[]
    update?: PropertyGroupUpdateWithWhereUniqueWithoutOwnerInput | PropertyGroupUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: PropertyGroupUpdateManyWithWhereWithoutOwnerInput | PropertyGroupUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: PropertyGroupScalarWhereInput | PropertyGroupScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput> | RoomCreateWithoutOwnerInput[] | RoomUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutOwnerInput | RoomCreateOrConnectWithoutOwnerInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutOwnerInput | RoomUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: RoomCreateManyOwnerInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutOwnerInput | RoomUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutOwnerInput | RoomUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<CleaningScheduleCreateWithoutOwnerInput, CleaningScheduleUncheckedCreateWithoutOwnerInput> | CleaningScheduleCreateWithoutOwnerInput[] | CleaningScheduleUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutOwnerInput | CleaningScheduleCreateOrConnectWithoutOwnerInput[]
    upsert?: CleaningScheduleUpsertWithWhereUniqueWithoutOwnerInput | CleaningScheduleUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: CleaningScheduleCreateManyOwnerInputEnvelope
    set?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    disconnect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    delete?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    update?: CleaningScheduleUpdateWithWhereUniqueWithoutOwnerInput | CleaningScheduleUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: CleaningScheduleUpdateManyWithWhereWithoutOwnerInput | CleaningScheduleUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: CleaningScheduleScalarWhereInput | CleaningScheduleScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutAssigneeNestedInput = {
    create?: XOR<InquiryCreateWithoutAssigneeInput, InquiryUncheckedCreateWithoutAssigneeInput> | InquiryCreateWithoutAssigneeInput[] | InquiryUncheckedCreateWithoutAssigneeInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutAssigneeInput | InquiryCreateOrConnectWithoutAssigneeInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutAssigneeInput | InquiryUpsertWithWhereUniqueWithoutAssigneeInput[]
    createMany?: InquiryCreateManyAssigneeInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutAssigneeInput | InquiryUpdateWithWhereUniqueWithoutAssigneeInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutAssigneeInput | InquiryUpdateManyWithWhereWithoutAssigneeInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReviewCreateWithoutPropertyInput, ReviewUncheckedCreateWithoutPropertyInput> | ReviewCreateWithoutPropertyInput[] | ReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPropertyInput | ReviewCreateOrConnectWithoutPropertyInput[]
    createMany?: ReviewCreateManyPropertyInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PropertyAmenityCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyAmenityCreateWithoutPropertyInput, PropertyAmenityUncheckedCreateWithoutPropertyInput> | PropertyAmenityCreateWithoutPropertyInput[] | PropertyAmenityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutPropertyInput | PropertyAmenityCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyAmenityCreateManyPropertyInputEnvelope
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
  }

  export type PropertyAvailabilityCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyAvailabilityCreateWithoutPropertyInput, PropertyAvailabilityUncheckedCreateWithoutPropertyInput> | PropertyAvailabilityCreateWithoutPropertyInput[] | PropertyAvailabilityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAvailabilityCreateOrConnectWithoutPropertyInput | PropertyAvailabilityCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyAvailabilityCreateManyPropertyInputEnvelope
    connect?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPropertyInput, MaintenanceRequestUncheckedCreateWithoutPropertyInput> | MaintenanceRequestCreateWithoutPropertyInput[] | MaintenanceRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPropertyInput | MaintenanceRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: MaintenanceRequestCreateManyPropertyInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RoomCreateWithoutPropertyInput, RoomUncheckedCreateWithoutPropertyInput> | RoomCreateWithoutPropertyInput[] | RoomUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutPropertyInput | RoomCreateOrConnectWithoutPropertyInput[]
    createMany?: RoomCreateManyPropertyInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type PropertyNoteCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyNoteCreateWithoutPropertyInput, PropertyNoteUncheckedCreateWithoutPropertyInput> | PropertyNoteCreateWithoutPropertyInput[] | PropertyNoteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyNoteCreateOrConnectWithoutPropertyInput | PropertyNoteCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyNoteCreateManyPropertyInputEnvelope
    connect?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
  }

  export type PropertyAnalyticsCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyAnalyticsCreateWithoutPropertyInput, PropertyAnalyticsUncheckedCreateWithoutPropertyInput> | PropertyAnalyticsCreateWithoutPropertyInput[] | PropertyAnalyticsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAnalyticsCreateOrConnectWithoutPropertyInput | PropertyAnalyticsCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyAnalyticsCreateManyPropertyInputEnvelope
    connect?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
  }

  export type CleaningScheduleCreateNestedManyWithoutPropertyInput = {
    create?: XOR<CleaningScheduleCreateWithoutPropertyInput, CleaningScheduleUncheckedCreateWithoutPropertyInput> | CleaningScheduleCreateWithoutPropertyInput[] | CleaningScheduleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutPropertyInput | CleaningScheduleCreateOrConnectWithoutPropertyInput[]
    createMany?: CleaningScheduleCreateManyPropertyInputEnvelope
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
  }

  export type PropertyGroupCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<PropertyGroupCreateWithoutPropertiesInput, PropertyGroupUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutPropertiesInput
    connect?: PropertyGroupWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InquiryCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<ReviewCreateWithoutPropertyInput, ReviewUncheckedCreateWithoutPropertyInput> | ReviewCreateWithoutPropertyInput[] | ReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPropertyInput | ReviewCreateOrConnectWithoutPropertyInput[]
    createMany?: ReviewCreateManyPropertyInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyAmenityCreateWithoutPropertyInput, PropertyAmenityUncheckedCreateWithoutPropertyInput> | PropertyAmenityCreateWithoutPropertyInput[] | PropertyAmenityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutPropertyInput | PropertyAmenityCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyAmenityCreateManyPropertyInputEnvelope
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
  }

  export type PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyAvailabilityCreateWithoutPropertyInput, PropertyAvailabilityUncheckedCreateWithoutPropertyInput> | PropertyAvailabilityCreateWithoutPropertyInput[] | PropertyAvailabilityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAvailabilityCreateOrConnectWithoutPropertyInput | PropertyAvailabilityCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyAvailabilityCreateManyPropertyInputEnvelope
    connect?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPropertyInput, MaintenanceRequestUncheckedCreateWithoutPropertyInput> | MaintenanceRequestCreateWithoutPropertyInput[] | MaintenanceRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPropertyInput | MaintenanceRequestCreateOrConnectWithoutPropertyInput[]
    createMany?: MaintenanceRequestCreateManyPropertyInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<RoomCreateWithoutPropertyInput, RoomUncheckedCreateWithoutPropertyInput> | RoomCreateWithoutPropertyInput[] | RoomUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutPropertyInput | RoomCreateOrConnectWithoutPropertyInput[]
    createMany?: RoomCreateManyPropertyInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyNoteCreateWithoutPropertyInput, PropertyNoteUncheckedCreateWithoutPropertyInput> | PropertyNoteCreateWithoutPropertyInput[] | PropertyNoteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyNoteCreateOrConnectWithoutPropertyInput | PropertyNoteCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyNoteCreateManyPropertyInputEnvelope
    connect?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
  }

  export type PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PropertyAnalyticsCreateWithoutPropertyInput, PropertyAnalyticsUncheckedCreateWithoutPropertyInput> | PropertyAnalyticsCreateWithoutPropertyInput[] | PropertyAnalyticsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAnalyticsCreateOrConnectWithoutPropertyInput | PropertyAnalyticsCreateOrConnectWithoutPropertyInput[]
    createMany?: PropertyAnalyticsCreateManyPropertyInputEnvelope
    connect?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
  }

  export type CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<CleaningScheduleCreateWithoutPropertyInput, CleaningScheduleUncheckedCreateWithoutPropertyInput> | CleaningScheduleCreateWithoutPropertyInput[] | CleaningScheduleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutPropertyInput | CleaningScheduleCreateOrConnectWithoutPropertyInput[]
    createMany?: CleaningScheduleCreateManyPropertyInputEnvelope
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type InquiryUncheckedCreateNestedManyWithoutPropertyInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
  }

  export type EnumPropertyTypeFieldUpdateOperationsInput = {
    set?: $Enums.PropertyType
  }

  export type EnumPropertyStatusFieldUpdateOperationsInput = {
    set?: $Enums.PropertyStatus
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumCancellationPolicyFieldUpdateOperationsInput = {
    set?: $Enums.CancellationPolicy
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertiesInput
    upsert?: UserUpsertWithoutPropertiesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertiesInput, UserUpdateWithoutPropertiesInput>, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type BookingUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPropertyInput | BookingUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPropertyInput | BookingUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPropertyInput | BookingUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReviewCreateWithoutPropertyInput, ReviewUncheckedCreateWithoutPropertyInput> | ReviewCreateWithoutPropertyInput[] | ReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPropertyInput | ReviewCreateOrConnectWithoutPropertyInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutPropertyInput | ReviewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReviewCreateManyPropertyInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutPropertyInput | ReviewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutPropertyInput | ReviewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PropertyAmenityUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyAmenityCreateWithoutPropertyInput, PropertyAmenityUncheckedCreateWithoutPropertyInput> | PropertyAmenityCreateWithoutPropertyInput[] | PropertyAmenityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutPropertyInput | PropertyAmenityCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyAmenityUpsertWithWhereUniqueWithoutPropertyInput | PropertyAmenityUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyAmenityCreateManyPropertyInputEnvelope
    set?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    disconnect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    delete?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    update?: PropertyAmenityUpdateWithWhereUniqueWithoutPropertyInput | PropertyAmenityUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyAmenityUpdateManyWithWhereWithoutPropertyInput | PropertyAmenityUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyAmenityScalarWhereInput | PropertyAmenityScalarWhereInput[]
  }

  export type PropertyAvailabilityUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyAvailabilityCreateWithoutPropertyInput, PropertyAvailabilityUncheckedCreateWithoutPropertyInput> | PropertyAvailabilityCreateWithoutPropertyInput[] | PropertyAvailabilityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAvailabilityCreateOrConnectWithoutPropertyInput | PropertyAvailabilityCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyAvailabilityUpsertWithWhereUniqueWithoutPropertyInput | PropertyAvailabilityUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyAvailabilityCreateManyPropertyInputEnvelope
    set?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    disconnect?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    delete?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    connect?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    update?: PropertyAvailabilityUpdateWithWhereUniqueWithoutPropertyInput | PropertyAvailabilityUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyAvailabilityUpdateManyWithWhereWithoutPropertyInput | PropertyAvailabilityUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyAvailabilityScalarWhereInput | PropertyAvailabilityScalarWhereInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPropertyInput, MaintenanceRequestUncheckedCreateWithoutPropertyInput> | MaintenanceRequestCreateWithoutPropertyInput[] | MaintenanceRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPropertyInput | MaintenanceRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutPropertyInput | MaintenanceRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MaintenanceRequestCreateManyPropertyInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutPropertyInput | MaintenanceRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutPropertyInput | MaintenanceRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RoomCreateWithoutPropertyInput, RoomUncheckedCreateWithoutPropertyInput> | RoomCreateWithoutPropertyInput[] | RoomUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutPropertyInput | RoomCreateOrConnectWithoutPropertyInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutPropertyInput | RoomUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RoomCreateManyPropertyInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutPropertyInput | RoomUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutPropertyInput | RoomUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type PropertyNoteUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyNoteCreateWithoutPropertyInput, PropertyNoteUncheckedCreateWithoutPropertyInput> | PropertyNoteCreateWithoutPropertyInput[] | PropertyNoteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyNoteCreateOrConnectWithoutPropertyInput | PropertyNoteCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyNoteUpsertWithWhereUniqueWithoutPropertyInput | PropertyNoteUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyNoteCreateManyPropertyInputEnvelope
    set?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    disconnect?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    delete?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    connect?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    update?: PropertyNoteUpdateWithWhereUniqueWithoutPropertyInput | PropertyNoteUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyNoteUpdateManyWithWhereWithoutPropertyInput | PropertyNoteUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyNoteScalarWhereInput | PropertyNoteScalarWhereInput[]
  }

  export type PropertyAnalyticsUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyAnalyticsCreateWithoutPropertyInput, PropertyAnalyticsUncheckedCreateWithoutPropertyInput> | PropertyAnalyticsCreateWithoutPropertyInput[] | PropertyAnalyticsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAnalyticsCreateOrConnectWithoutPropertyInput | PropertyAnalyticsCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyAnalyticsUpsertWithWhereUniqueWithoutPropertyInput | PropertyAnalyticsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyAnalyticsCreateManyPropertyInputEnvelope
    set?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    disconnect?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    delete?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    connect?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    update?: PropertyAnalyticsUpdateWithWhereUniqueWithoutPropertyInput | PropertyAnalyticsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyAnalyticsUpdateManyWithWhereWithoutPropertyInput | PropertyAnalyticsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyAnalyticsScalarWhereInput | PropertyAnalyticsScalarWhereInput[]
  }

  export type CleaningScheduleUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<CleaningScheduleCreateWithoutPropertyInput, CleaningScheduleUncheckedCreateWithoutPropertyInput> | CleaningScheduleCreateWithoutPropertyInput[] | CleaningScheduleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutPropertyInput | CleaningScheduleCreateOrConnectWithoutPropertyInput[]
    upsert?: CleaningScheduleUpsertWithWhereUniqueWithoutPropertyInput | CleaningScheduleUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: CleaningScheduleCreateManyPropertyInputEnvelope
    set?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    disconnect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    delete?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    update?: CleaningScheduleUpdateWithWhereUniqueWithoutPropertyInput | CleaningScheduleUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: CleaningScheduleUpdateManyWithWhereWithoutPropertyInput | CleaningScheduleUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: CleaningScheduleScalarWhereInput | CleaningScheduleScalarWhereInput[]
  }

  export type PropertyGroupUpdateOneWithoutPropertiesNestedInput = {
    create?: XOR<PropertyGroupCreateWithoutPropertiesInput, PropertyGroupUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: PropertyGroupCreateOrConnectWithoutPropertiesInput
    upsert?: PropertyGroupUpsertWithoutPropertiesInput
    disconnect?: PropertyGroupWhereInput | boolean
    delete?: PropertyGroupWhereInput | boolean
    connect?: PropertyGroupWhereUniqueInput
    update?: XOR<XOR<PropertyGroupUpdateToOneWithWhereWithoutPropertiesInput, PropertyGroupUpdateWithoutPropertiesInput>, PropertyGroupUncheckedUpdateWithoutPropertiesInput>
  }

  export type PaymentUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPropertyInput | PaymentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPropertyInput | PaymentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPropertyInput | PaymentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InquiryUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutPropertyInput | InquiryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutPropertyInput | InquiryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutPropertyInput | InquiryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput> | BookingCreateWithoutPropertyInput[] | BookingUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutPropertyInput | BookingCreateOrConnectWithoutPropertyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutPropertyInput | BookingUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: BookingCreateManyPropertyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutPropertyInput | BookingUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutPropertyInput | BookingUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<ReviewCreateWithoutPropertyInput, ReviewUncheckedCreateWithoutPropertyInput> | ReviewCreateWithoutPropertyInput[] | ReviewUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutPropertyInput | ReviewCreateOrConnectWithoutPropertyInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutPropertyInput | ReviewUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: ReviewCreateManyPropertyInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutPropertyInput | ReviewUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutPropertyInput | ReviewUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyAmenityCreateWithoutPropertyInput, PropertyAmenityUncheckedCreateWithoutPropertyInput> | PropertyAmenityCreateWithoutPropertyInput[] | PropertyAmenityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutPropertyInput | PropertyAmenityCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyAmenityUpsertWithWhereUniqueWithoutPropertyInput | PropertyAmenityUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyAmenityCreateManyPropertyInputEnvelope
    set?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    disconnect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    delete?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    update?: PropertyAmenityUpdateWithWhereUniqueWithoutPropertyInput | PropertyAmenityUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyAmenityUpdateManyWithWhereWithoutPropertyInput | PropertyAmenityUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyAmenityScalarWhereInput | PropertyAmenityScalarWhereInput[]
  }

  export type PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyAvailabilityCreateWithoutPropertyInput, PropertyAvailabilityUncheckedCreateWithoutPropertyInput> | PropertyAvailabilityCreateWithoutPropertyInput[] | PropertyAvailabilityUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAvailabilityCreateOrConnectWithoutPropertyInput | PropertyAvailabilityCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyAvailabilityUpsertWithWhereUniqueWithoutPropertyInput | PropertyAvailabilityUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyAvailabilityCreateManyPropertyInputEnvelope
    set?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    disconnect?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    delete?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    connect?: PropertyAvailabilityWhereUniqueInput | PropertyAvailabilityWhereUniqueInput[]
    update?: PropertyAvailabilityUpdateWithWhereUniqueWithoutPropertyInput | PropertyAvailabilityUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyAvailabilityUpdateManyWithWhereWithoutPropertyInput | PropertyAvailabilityUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyAvailabilityScalarWhereInput | PropertyAvailabilityScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutPropertyInput, MaintenanceRequestUncheckedCreateWithoutPropertyInput> | MaintenanceRequestCreateWithoutPropertyInput[] | MaintenanceRequestUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutPropertyInput | MaintenanceRequestCreateOrConnectWithoutPropertyInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutPropertyInput | MaintenanceRequestUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: MaintenanceRequestCreateManyPropertyInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutPropertyInput | MaintenanceRequestUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutPropertyInput | MaintenanceRequestUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<RoomCreateWithoutPropertyInput, RoomUncheckedCreateWithoutPropertyInput> | RoomCreateWithoutPropertyInput[] | RoomUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutPropertyInput | RoomCreateOrConnectWithoutPropertyInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutPropertyInput | RoomUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: RoomCreateManyPropertyInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutPropertyInput | RoomUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutPropertyInput | RoomUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyNoteCreateWithoutPropertyInput, PropertyNoteUncheckedCreateWithoutPropertyInput> | PropertyNoteCreateWithoutPropertyInput[] | PropertyNoteUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyNoteCreateOrConnectWithoutPropertyInput | PropertyNoteCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyNoteUpsertWithWhereUniqueWithoutPropertyInput | PropertyNoteUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyNoteCreateManyPropertyInputEnvelope
    set?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    disconnect?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    delete?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    connect?: PropertyNoteWhereUniqueInput | PropertyNoteWhereUniqueInput[]
    update?: PropertyNoteUpdateWithWhereUniqueWithoutPropertyInput | PropertyNoteUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyNoteUpdateManyWithWhereWithoutPropertyInput | PropertyNoteUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyNoteScalarWhereInput | PropertyNoteScalarWhereInput[]
  }

  export type PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PropertyAnalyticsCreateWithoutPropertyInput, PropertyAnalyticsUncheckedCreateWithoutPropertyInput> | PropertyAnalyticsCreateWithoutPropertyInput[] | PropertyAnalyticsUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PropertyAnalyticsCreateOrConnectWithoutPropertyInput | PropertyAnalyticsCreateOrConnectWithoutPropertyInput[]
    upsert?: PropertyAnalyticsUpsertWithWhereUniqueWithoutPropertyInput | PropertyAnalyticsUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PropertyAnalyticsCreateManyPropertyInputEnvelope
    set?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    disconnect?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    delete?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    connect?: PropertyAnalyticsWhereUniqueInput | PropertyAnalyticsWhereUniqueInput[]
    update?: PropertyAnalyticsUpdateWithWhereUniqueWithoutPropertyInput | PropertyAnalyticsUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PropertyAnalyticsUpdateManyWithWhereWithoutPropertyInput | PropertyAnalyticsUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PropertyAnalyticsScalarWhereInput | PropertyAnalyticsScalarWhereInput[]
  }

  export type CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<CleaningScheduleCreateWithoutPropertyInput, CleaningScheduleUncheckedCreateWithoutPropertyInput> | CleaningScheduleCreateWithoutPropertyInput[] | CleaningScheduleUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: CleaningScheduleCreateOrConnectWithoutPropertyInput | CleaningScheduleCreateOrConnectWithoutPropertyInput[]
    upsert?: CleaningScheduleUpsertWithWhereUniqueWithoutPropertyInput | CleaningScheduleUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: CleaningScheduleCreateManyPropertyInputEnvelope
    set?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    disconnect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    delete?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    connect?: CleaningScheduleWhereUniqueInput | CleaningScheduleWhereUniqueInput[]
    update?: CleaningScheduleUpdateWithWhereUniqueWithoutPropertyInput | CleaningScheduleUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: CleaningScheduleUpdateManyWithWhereWithoutPropertyInput | CleaningScheduleUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: CleaningScheduleScalarWhereInput | CleaningScheduleScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput> | PaymentCreateWithoutPropertyInput[] | PaymentUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutPropertyInput | PaymentCreateOrConnectWithoutPropertyInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutPropertyInput | PaymentUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: PaymentCreateManyPropertyInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutPropertyInput | PaymentUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutPropertyInput | PaymentUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InquiryUncheckedUpdateManyWithoutPropertyNestedInput = {
    create?: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput> | InquiryCreateWithoutPropertyInput[] | InquiryUncheckedCreateWithoutPropertyInput[]
    connectOrCreate?: InquiryCreateOrConnectWithoutPropertyInput | InquiryCreateOrConnectWithoutPropertyInput[]
    upsert?: InquiryUpsertWithWhereUniqueWithoutPropertyInput | InquiryUpsertWithWhereUniqueWithoutPropertyInput[]
    createMany?: InquiryCreateManyPropertyInputEnvelope
    set?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    disconnect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    delete?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    connect?: InquiryWhereUniqueInput | InquiryWhereUniqueInput[]
    update?: InquiryUpdateWithWhereUniqueWithoutPropertyInput | InquiryUpdateWithWhereUniqueWithoutPropertyInput[]
    updateMany?: InquiryUpdateManyWithWhereWithoutPropertyInput | InquiryUpdateManyWithWhereWithoutPropertyInput[]
    deleteMany?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
  }

  export type PropertyAmenityCreateNestedManyWithoutAmenityInput = {
    create?: XOR<PropertyAmenityCreateWithoutAmenityInput, PropertyAmenityUncheckedCreateWithoutAmenityInput> | PropertyAmenityCreateWithoutAmenityInput[] | PropertyAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutAmenityInput | PropertyAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: PropertyAmenityCreateManyAmenityInputEnvelope
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
  }

  export type PropertyAmenityUncheckedCreateNestedManyWithoutAmenityInput = {
    create?: XOR<PropertyAmenityCreateWithoutAmenityInput, PropertyAmenityUncheckedCreateWithoutAmenityInput> | PropertyAmenityCreateWithoutAmenityInput[] | PropertyAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutAmenityInput | PropertyAmenityCreateOrConnectWithoutAmenityInput[]
    createMany?: PropertyAmenityCreateManyAmenityInputEnvelope
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
  }

  export type PropertyAmenityUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<PropertyAmenityCreateWithoutAmenityInput, PropertyAmenityUncheckedCreateWithoutAmenityInput> | PropertyAmenityCreateWithoutAmenityInput[] | PropertyAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutAmenityInput | PropertyAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: PropertyAmenityUpsertWithWhereUniqueWithoutAmenityInput | PropertyAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: PropertyAmenityCreateManyAmenityInputEnvelope
    set?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    disconnect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    delete?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    update?: PropertyAmenityUpdateWithWhereUniqueWithoutAmenityInput | PropertyAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: PropertyAmenityUpdateManyWithWhereWithoutAmenityInput | PropertyAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: PropertyAmenityScalarWhereInput | PropertyAmenityScalarWhereInput[]
  }

  export type PropertyAmenityUncheckedUpdateManyWithoutAmenityNestedInput = {
    create?: XOR<PropertyAmenityCreateWithoutAmenityInput, PropertyAmenityUncheckedCreateWithoutAmenityInput> | PropertyAmenityCreateWithoutAmenityInput[] | PropertyAmenityUncheckedCreateWithoutAmenityInput[]
    connectOrCreate?: PropertyAmenityCreateOrConnectWithoutAmenityInput | PropertyAmenityCreateOrConnectWithoutAmenityInput[]
    upsert?: PropertyAmenityUpsertWithWhereUniqueWithoutAmenityInput | PropertyAmenityUpsertWithWhereUniqueWithoutAmenityInput[]
    createMany?: PropertyAmenityCreateManyAmenityInputEnvelope
    set?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    disconnect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    delete?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    connect?: PropertyAmenityWhereUniqueInput | PropertyAmenityWhereUniqueInput[]
    update?: PropertyAmenityUpdateWithWhereUniqueWithoutAmenityInput | PropertyAmenityUpdateWithWhereUniqueWithoutAmenityInput[]
    updateMany?: PropertyAmenityUpdateManyWithWhereWithoutAmenityInput | PropertyAmenityUpdateManyWithWhereWithoutAmenityInput[]
    deleteMany?: PropertyAmenityScalarWhereInput | PropertyAmenityScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutAmenitiesInput = {
    create?: XOR<PropertyCreateWithoutAmenitiesInput, PropertyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAmenitiesInput
    connect?: PropertyWhereUniqueInput
  }

  export type AmenityCreateNestedOneWithoutPropertiesInput = {
    create?: XOR<AmenityCreateWithoutPropertiesInput, AmenityUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutPropertiesInput
    connect?: AmenityWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutAmenitiesNestedInput = {
    create?: XOR<PropertyCreateWithoutAmenitiesInput, PropertyUncheckedCreateWithoutAmenitiesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAmenitiesInput
    upsert?: PropertyUpsertWithoutAmenitiesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutAmenitiesInput, PropertyUpdateWithoutAmenitiesInput>, PropertyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type AmenityUpdateOneRequiredWithoutPropertiesNestedInput = {
    create?: XOR<AmenityCreateWithoutPropertiesInput, AmenityUncheckedCreateWithoutPropertiesInput>
    connectOrCreate?: AmenityCreateOrConnectWithoutPropertiesInput
    upsert?: AmenityUpsertWithoutPropertiesInput
    connect?: AmenityWhereUniqueInput
    update?: XOR<XOR<AmenityUpdateToOneWithWhereWithoutPropertiesInput, AmenityUpdateWithoutPropertiesInput>, AmenityUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyCreateNestedOneWithoutBookingsInput = {
    create?: XOR<PropertyCreateWithoutBookingsInput, PropertyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBookingsInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutBookingsInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutBookingInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MaintenanceRequestCreateNestedManyWithoutBookingInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBookingInput, MaintenanceRequestUncheckedCreateWithoutBookingInput> | MaintenanceRequestCreateWithoutBookingInput[] | MaintenanceRequestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBookingInput | MaintenanceRequestCreateOrConnectWithoutBookingInput[]
    createMany?: MaintenanceRequestCreateManyBookingInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBookingInput, MaintenanceRequestUncheckedCreateWithoutBookingInput> | MaintenanceRequestCreateWithoutBookingInput[] | MaintenanceRequestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBookingInput | MaintenanceRequestCreateOrConnectWithoutBookingInput[]
    createMany?: MaintenanceRequestCreateManyBookingInputEnvelope
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumBookingSourceFieldUpdateOperationsInput = {
    set?: $Enums.BookingSource
  }

  export type PropertyUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<PropertyCreateWithoutBookingsInput, PropertyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutBookingsInput
    upsert?: PropertyUpsertWithoutBookingsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutBookingsInput, PropertyUpdateWithoutBookingsInput>, PropertyUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutBookingsInput
    upsert?: UserUpsertWithoutBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBookingsInput, UserUpdateWithoutBookingsInput>, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBookingInput | ReviewUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBookingInput | ReviewUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBookingInput | ReviewUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBookingInput | MessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBookingInput | MessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBookingInput | MessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MaintenanceRequestUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBookingInput, MaintenanceRequestUncheckedCreateWithoutBookingInput> | MaintenanceRequestCreateWithoutBookingInput[] | MaintenanceRequestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBookingInput | MaintenanceRequestCreateOrConnectWithoutBookingInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutBookingInput | MaintenanceRequestUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MaintenanceRequestCreateManyBookingInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutBookingInput | MaintenanceRequestUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutBookingInput | MaintenanceRequestUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput> | PaymentCreateWithoutBookingInput[] | PaymentUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput | PaymentCreateOrConnectWithoutBookingInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInput | PaymentUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: PaymentCreateManyBookingInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInput | PaymentUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInput | PaymentUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput> | ReviewCreateWithoutBookingInput[] | ReviewUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutBookingInput | ReviewCreateOrConnectWithoutBookingInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutBookingInput | ReviewUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: ReviewCreateManyBookingInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutBookingInput | ReviewUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutBookingInput | ReviewUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput> | MessageCreateWithoutBookingInput[] | MessageUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutBookingInput | MessageCreateOrConnectWithoutBookingInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutBookingInput | MessageUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MessageCreateManyBookingInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutBookingInput | MessageUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutBookingInput | MessageUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<MaintenanceRequestCreateWithoutBookingInput, MaintenanceRequestUncheckedCreateWithoutBookingInput> | MaintenanceRequestCreateWithoutBookingInput[] | MaintenanceRequestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: MaintenanceRequestCreateOrConnectWithoutBookingInput | MaintenanceRequestCreateOrConnectWithoutBookingInput[]
    upsert?: MaintenanceRequestUpsertWithWhereUniqueWithoutBookingInput | MaintenanceRequestUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: MaintenanceRequestCreateManyBookingInputEnvelope
    set?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    disconnect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    delete?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    connect?: MaintenanceRequestWhereUniqueInput | MaintenanceRequestWhereUniqueInput[]
    update?: MaintenanceRequestUpdateWithWhereUniqueWithoutBookingInput | MaintenanceRequestUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: MaintenanceRequestUpdateManyWithWhereWithoutBookingInput | MaintenanceRequestUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<PropertyCreateWithoutAvailabilityInput, PropertyUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAvailabilityInput
    connect?: PropertyWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<PropertyCreateWithoutAvailabilityInput, PropertyUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAvailabilityInput
    upsert?: PropertyUpsertWithoutAvailabilityInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutAvailabilityInput, PropertyUpdateWithoutAvailabilityInput>, PropertyUncheckedUpdateWithoutAvailabilityInput>
  }

  export type PropertyCreateNestedOneWithoutReviewsInput = {
    create?: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReviewsInput
    connect?: PropertyWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutReviewsInput = {
    create?: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewsInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutReviewsInput
    upsert?: PropertyUpsertWithoutReviewsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutReviewsInput, PropertyUpdateWithoutReviewsInput>, PropertyUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutReviewsInput
    upsert?: BookingUpsertWithoutReviewsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutReviewsInput, BookingUpdateWithoutReviewsInput>, BookingUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type PropertyCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<PropertyCreateWithoutMaintenanceInput, PropertyUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMaintenanceInput
    connect?: PropertyWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutMaintenanceInput = {
    create?: XOR<BookingCreateWithoutMaintenanceInput, BookingUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMaintenanceInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumMaintenancePriorityFieldUpdateOperationsInput = {
    set?: $Enums.MaintenancePriority
  }

  export type EnumMaintenanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.MaintenanceStatus
  }

  export type PropertyUpdateOneRequiredWithoutMaintenanceNestedInput = {
    create?: XOR<PropertyCreateWithoutMaintenanceInput, PropertyUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutMaintenanceInput
    upsert?: PropertyUpsertWithoutMaintenanceInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutMaintenanceInput, PropertyUpdateWithoutMaintenanceInput>, PropertyUncheckedUpdateWithoutMaintenanceInput>
  }

  export type BookingUpdateOneWithoutMaintenanceNestedInput = {
    create?: XOR<BookingCreateWithoutMaintenanceInput, BookingUncheckedCreateWithoutMaintenanceInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMaintenanceInput
    upsert?: BookingUpsertWithoutMaintenanceInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutMaintenanceInput, BookingUpdateWithoutMaintenanceInput>, BookingUncheckedUpdateWithoutMaintenanceInput>
  }

  export type BookingCreateNestedOneWithoutMessagesInput = {
    create?: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMessagesInput
    connect?: BookingWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMessagesInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumMessageTypeFieldUpdateOperationsInput = {
    set?: $Enums.MessageType
  }

  export type BookingUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: BookingCreateOrConnectWithoutMessagesInput
    upsert?: BookingUpsertWithoutMessagesInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutMessagesInput, BookingUpdateWithoutMessagesInput>, BookingUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMessagesInput
    upsert?: UserUpsertWithoutMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMessagesInput, UserUpdateWithoutMessagesInput>, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type EnumContentStatusFieldUpdateOperationsInput = {
    set?: $Enums.ContentStatus
  }

  export type BookingCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
  }

  export type PropertyCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPaymentsInput
    connect?: PropertyWhereUniqueInput
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type BookingUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentsInput
    upsert?: BookingUpsertWithoutPaymentsInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentsInput, BookingUpdateWithoutPaymentsInput>, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type PropertyUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutPaymentsInput
    upsert?: PropertyUpsertWithoutPaymentsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutPaymentsInput, PropertyUpdateWithoutPaymentsInput>, PropertyUncheckedUpdateWithoutPaymentsInput>
  }

  export type PropertyCreateNestedOneWithoutRoomsInput = {
    create?: XOR<PropertyCreateWithoutRoomsInput, PropertyUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRoomsInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutRoomsInput = {
    create?: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomsInput
    connect?: UserWhereUniqueInput
  }

  export type RoomContentCreateNestedOneWithoutRoomInput = {
    create?: XOR<RoomContentCreateWithoutRoomInput, RoomContentUncheckedCreateWithoutRoomInput>
    connectOrCreate?: RoomContentCreateOrConnectWithoutRoomInput
    connect?: RoomContentWhereUniqueInput
  }

  export type RoomAvailabilityRuleCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAvailabilityRuleCreateWithoutRoomInput, RoomAvailabilityRuleUncheckedCreateWithoutRoomInput> | RoomAvailabilityRuleCreateWithoutRoomInput[] | RoomAvailabilityRuleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAvailabilityRuleCreateOrConnectWithoutRoomInput | RoomAvailabilityRuleCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAvailabilityRuleCreateManyRoomInputEnvelope
    connect?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
  }

  export type RoomContentUncheckedCreateNestedOneWithoutRoomInput = {
    create?: XOR<RoomContentCreateWithoutRoomInput, RoomContentUncheckedCreateWithoutRoomInput>
    connectOrCreate?: RoomContentCreateOrConnectWithoutRoomInput
    connect?: RoomContentWhereUniqueInput
  }

  export type RoomAvailabilityRuleUncheckedCreateNestedManyWithoutRoomInput = {
    create?: XOR<RoomAvailabilityRuleCreateWithoutRoomInput, RoomAvailabilityRuleUncheckedCreateWithoutRoomInput> | RoomAvailabilityRuleCreateWithoutRoomInput[] | RoomAvailabilityRuleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAvailabilityRuleCreateOrConnectWithoutRoomInput | RoomAvailabilityRuleCreateOrConnectWithoutRoomInput[]
    createMany?: RoomAvailabilityRuleCreateManyRoomInputEnvelope
    connect?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
  }

  export type EnumRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoomType
  }

  export type PropertyUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<PropertyCreateWithoutRoomsInput, PropertyUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutRoomsInput
    upsert?: PropertyUpsertWithoutRoomsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutRoomsInput, PropertyUpdateWithoutRoomsInput>, PropertyUncheckedUpdateWithoutRoomsInput>
  }

  export type UserUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoomsInput
    upsert?: UserUpsertWithoutRoomsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoomsInput, UserUpdateWithoutRoomsInput>, UserUncheckedUpdateWithoutRoomsInput>
  }

  export type RoomContentUpdateOneWithoutRoomNestedInput = {
    create?: XOR<RoomContentCreateWithoutRoomInput, RoomContentUncheckedCreateWithoutRoomInput>
    connectOrCreate?: RoomContentCreateOrConnectWithoutRoomInput
    upsert?: RoomContentUpsertWithoutRoomInput
    disconnect?: RoomContentWhereInput | boolean
    delete?: RoomContentWhereInput | boolean
    connect?: RoomContentWhereUniqueInput
    update?: XOR<XOR<RoomContentUpdateToOneWithWhereWithoutRoomInput, RoomContentUpdateWithoutRoomInput>, RoomContentUncheckedUpdateWithoutRoomInput>
  }

  export type RoomAvailabilityRuleUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAvailabilityRuleCreateWithoutRoomInput, RoomAvailabilityRuleUncheckedCreateWithoutRoomInput> | RoomAvailabilityRuleCreateWithoutRoomInput[] | RoomAvailabilityRuleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAvailabilityRuleCreateOrConnectWithoutRoomInput | RoomAvailabilityRuleCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAvailabilityRuleUpsertWithWhereUniqueWithoutRoomInput | RoomAvailabilityRuleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAvailabilityRuleCreateManyRoomInputEnvelope
    set?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    disconnect?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    delete?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    connect?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    update?: RoomAvailabilityRuleUpdateWithWhereUniqueWithoutRoomInput | RoomAvailabilityRuleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAvailabilityRuleUpdateManyWithWhereWithoutRoomInput | RoomAvailabilityRuleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAvailabilityRuleScalarWhereInput | RoomAvailabilityRuleScalarWhereInput[]
  }

  export type RoomContentUncheckedUpdateOneWithoutRoomNestedInput = {
    create?: XOR<RoomContentCreateWithoutRoomInput, RoomContentUncheckedCreateWithoutRoomInput>
    connectOrCreate?: RoomContentCreateOrConnectWithoutRoomInput
    upsert?: RoomContentUpsertWithoutRoomInput
    disconnect?: RoomContentWhereInput | boolean
    delete?: RoomContentWhereInput | boolean
    connect?: RoomContentWhereUniqueInput
    update?: XOR<XOR<RoomContentUpdateToOneWithWhereWithoutRoomInput, RoomContentUpdateWithoutRoomInput>, RoomContentUncheckedUpdateWithoutRoomInput>
  }

  export type RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomNestedInput = {
    create?: XOR<RoomAvailabilityRuleCreateWithoutRoomInput, RoomAvailabilityRuleUncheckedCreateWithoutRoomInput> | RoomAvailabilityRuleCreateWithoutRoomInput[] | RoomAvailabilityRuleUncheckedCreateWithoutRoomInput[]
    connectOrCreate?: RoomAvailabilityRuleCreateOrConnectWithoutRoomInput | RoomAvailabilityRuleCreateOrConnectWithoutRoomInput[]
    upsert?: RoomAvailabilityRuleUpsertWithWhereUniqueWithoutRoomInput | RoomAvailabilityRuleUpsertWithWhereUniqueWithoutRoomInput[]
    createMany?: RoomAvailabilityRuleCreateManyRoomInputEnvelope
    set?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    disconnect?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    delete?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    connect?: RoomAvailabilityRuleWhereUniqueInput | RoomAvailabilityRuleWhereUniqueInput[]
    update?: RoomAvailabilityRuleUpdateWithWhereUniqueWithoutRoomInput | RoomAvailabilityRuleUpdateWithWhereUniqueWithoutRoomInput[]
    updateMany?: RoomAvailabilityRuleUpdateManyWithWhereWithoutRoomInput | RoomAvailabilityRuleUpdateManyWithWhereWithoutRoomInput[]
    deleteMany?: RoomAvailabilityRuleScalarWhereInput | RoomAvailabilityRuleScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPropertyGroupsInput = {
    create?: XOR<UserCreateWithoutPropertyGroupsInput, UserUncheckedCreateWithoutPropertyGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyGroupsInput
    connect?: UserWhereUniqueInput
  }

  export type PropertyCreateNestedManyWithoutPropertyGroupInput = {
    create?: XOR<PropertyCreateWithoutPropertyGroupInput, PropertyUncheckedCreateWithoutPropertyGroupInput> | PropertyCreateWithoutPropertyGroupInput[] | PropertyUncheckedCreateWithoutPropertyGroupInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyGroupInput | PropertyCreateOrConnectWithoutPropertyGroupInput[]
    createMany?: PropertyCreateManyPropertyGroupInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type PropertyUncheckedCreateNestedManyWithoutPropertyGroupInput = {
    create?: XOR<PropertyCreateWithoutPropertyGroupInput, PropertyUncheckedCreateWithoutPropertyGroupInput> | PropertyCreateWithoutPropertyGroupInput[] | PropertyUncheckedCreateWithoutPropertyGroupInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyGroupInput | PropertyCreateOrConnectWithoutPropertyGroupInput[]
    createMany?: PropertyCreateManyPropertyGroupInputEnvelope
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutPropertyGroupsNestedInput = {
    create?: XOR<UserCreateWithoutPropertyGroupsInput, UserUncheckedCreateWithoutPropertyGroupsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPropertyGroupsInput
    upsert?: UserUpsertWithoutPropertyGroupsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPropertyGroupsInput, UserUpdateWithoutPropertyGroupsInput>, UserUncheckedUpdateWithoutPropertyGroupsInput>
  }

  export type PropertyUpdateManyWithoutPropertyGroupNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyGroupInput, PropertyUncheckedCreateWithoutPropertyGroupInput> | PropertyCreateWithoutPropertyGroupInput[] | PropertyUncheckedCreateWithoutPropertyGroupInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyGroupInput | PropertyCreateOrConnectWithoutPropertyGroupInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyGroupInput | PropertyUpsertWithWhereUniqueWithoutPropertyGroupInput[]
    createMany?: PropertyCreateManyPropertyGroupInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyGroupInput | PropertyUpdateWithWhereUniqueWithoutPropertyGroupInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyGroupInput | PropertyUpdateManyWithWhereWithoutPropertyGroupInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyGroupNestedInput = {
    create?: XOR<PropertyCreateWithoutPropertyGroupInput, PropertyUncheckedCreateWithoutPropertyGroupInput> | PropertyCreateWithoutPropertyGroupInput[] | PropertyUncheckedCreateWithoutPropertyGroupInput[]
    connectOrCreate?: PropertyCreateOrConnectWithoutPropertyGroupInput | PropertyCreateOrConnectWithoutPropertyGroupInput[]
    upsert?: PropertyUpsertWithWhereUniqueWithoutPropertyGroupInput | PropertyUpsertWithWhereUniqueWithoutPropertyGroupInput[]
    createMany?: PropertyCreateManyPropertyGroupInputEnvelope
    set?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    disconnect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    delete?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    connect?: PropertyWhereUniqueInput | PropertyWhereUniqueInput[]
    update?: PropertyUpdateWithWhereUniqueWithoutPropertyGroupInput | PropertyUpdateWithWhereUniqueWithoutPropertyGroupInput[]
    updateMany?: PropertyUpdateManyWithWhereWithoutPropertyGroupInput | PropertyUpdateManyWithWhereWithoutPropertyGroupInput[]
    deleteMany?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
  }

  export type PropertyCreateNestedOneWithoutCleaningSchedulesInput = {
    create?: XOR<PropertyCreateWithoutCleaningSchedulesInput, PropertyUncheckedCreateWithoutCleaningSchedulesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutCleaningSchedulesInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCleaningSchedulesInput = {
    create?: XOR<UserCreateWithoutCleaningSchedulesInput, UserUncheckedCreateWithoutCleaningSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCleaningSchedulesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumCleaningFrequencyFieldUpdateOperationsInput = {
    set?: $Enums.CleaningFrequency
  }

  export type PropertyUpdateOneRequiredWithoutCleaningSchedulesNestedInput = {
    create?: XOR<PropertyCreateWithoutCleaningSchedulesInput, PropertyUncheckedCreateWithoutCleaningSchedulesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutCleaningSchedulesInput
    upsert?: PropertyUpsertWithoutCleaningSchedulesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutCleaningSchedulesInput, PropertyUpdateWithoutCleaningSchedulesInput>, PropertyUncheckedUpdateWithoutCleaningSchedulesInput>
  }

  export type UserUpdateOneRequiredWithoutCleaningSchedulesNestedInput = {
    create?: XOR<UserCreateWithoutCleaningSchedulesInput, UserUncheckedCreateWithoutCleaningSchedulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCleaningSchedulesInput
    upsert?: UserUpsertWithoutCleaningSchedulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCleaningSchedulesInput, UserUpdateWithoutCleaningSchedulesInput>, UserUncheckedUpdateWithoutCleaningSchedulesInput>
  }

  export type PropertyCreateNestedOneWithoutAnalyticsInput = {
    create?: XOR<PropertyCreateWithoutAnalyticsInput, PropertyUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAnalyticsInput
    connect?: PropertyWhereUniqueInput
  }

  export type EnumAnalyticsPeriodFieldUpdateOperationsInput = {
    set?: $Enums.AnalyticsPeriod
  }

  export type PropertyUpdateOneRequiredWithoutAnalyticsNestedInput = {
    create?: XOR<PropertyCreateWithoutAnalyticsInput, PropertyUncheckedCreateWithoutAnalyticsInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutAnalyticsInput
    upsert?: PropertyUpsertWithoutAnalyticsInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutAnalyticsInput, PropertyUpdateWithoutAnalyticsInput>, PropertyUncheckedUpdateWithoutAnalyticsInput>
  }

  export type PropertyCreateNestedOneWithoutNotesInput = {
    create?: XOR<PropertyCreateWithoutNotesInput, PropertyUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutNotesInput
    connect?: PropertyWhereUniqueInput
  }

  export type EnumNoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.NoteType
  }

  export type PropertyUpdateOneRequiredWithoutNotesNestedInput = {
    create?: XOR<PropertyCreateWithoutNotesInput, PropertyUncheckedCreateWithoutNotesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutNotesInput
    upsert?: PropertyUpsertWithoutNotesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutNotesInput, PropertyUpdateWithoutNotesInput>, PropertyUncheckedUpdateWithoutNotesInput>
  }

  export type UserCreateNestedOneWithoutAuditLogsInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAuditLogsNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogsInput
    upsert?: UserUpsertWithoutAuditLogsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogsInput, UserUpdateWithoutAuditLogsInput>, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type ContentMediaCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentMediaCreateWithoutContentInput, ContentMediaUncheckedCreateWithoutContentInput> | ContentMediaCreateWithoutContentInput[] | ContentMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutContentInput | ContentMediaCreateOrConnectWithoutContentInput[]
    createMany?: ContentMediaCreateManyContentInputEnvelope
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
  }

  export type ContentMediaUncheckedCreateNestedManyWithoutContentInput = {
    create?: XOR<ContentMediaCreateWithoutContentInput, ContentMediaUncheckedCreateWithoutContentInput> | ContentMediaCreateWithoutContentInput[] | ContentMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutContentInput | ContentMediaCreateOrConnectWithoutContentInput[]
    createMany?: ContentMediaCreateManyContentInputEnvelope
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type ContentMediaUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentMediaCreateWithoutContentInput, ContentMediaUncheckedCreateWithoutContentInput> | ContentMediaCreateWithoutContentInput[] | ContentMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutContentInput | ContentMediaCreateOrConnectWithoutContentInput[]
    upsert?: ContentMediaUpsertWithWhereUniqueWithoutContentInput | ContentMediaUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentMediaCreateManyContentInputEnvelope
    set?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    disconnect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    delete?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    update?: ContentMediaUpdateWithWhereUniqueWithoutContentInput | ContentMediaUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentMediaUpdateManyWithWhereWithoutContentInput | ContentMediaUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentMediaScalarWhereInput | ContentMediaScalarWhereInput[]
  }

  export type ContentMediaUncheckedUpdateManyWithoutContentNestedInput = {
    create?: XOR<ContentMediaCreateWithoutContentInput, ContentMediaUncheckedCreateWithoutContentInput> | ContentMediaCreateWithoutContentInput[] | ContentMediaUncheckedCreateWithoutContentInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutContentInput | ContentMediaCreateOrConnectWithoutContentInput[]
    upsert?: ContentMediaUpsertWithWhereUniqueWithoutContentInput | ContentMediaUpsertWithWhereUniqueWithoutContentInput[]
    createMany?: ContentMediaCreateManyContentInputEnvelope
    set?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    disconnect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    delete?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    update?: ContentMediaUpdateWithWhereUniqueWithoutContentInput | ContentMediaUpdateWithWhereUniqueWithoutContentInput[]
    updateMany?: ContentMediaUpdateManyWithWhereWithoutContentInput | ContentMediaUpdateManyWithWhereWithoutContentInput[]
    deleteMany?: ContentMediaScalarWhereInput | ContentMediaScalarWhereInput[]
  }

  export type ContentCreateNestedOneWithoutMediaInput = {
    create?: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ContentCreateOrConnectWithoutMediaInput
    connect?: ContentWhereUniqueInput
  }

  export type MediaCreateNestedOneWithoutContentInput = {
    create?: XOR<MediaCreateWithoutContentInput, MediaUncheckedCreateWithoutContentInput>
    connectOrCreate?: MediaCreateOrConnectWithoutContentInput
    connect?: MediaWhereUniqueInput
  }

  export type ContentUpdateOneRequiredWithoutMediaNestedInput = {
    create?: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
    connectOrCreate?: ContentCreateOrConnectWithoutMediaInput
    upsert?: ContentUpsertWithoutMediaInput
    connect?: ContentWhereUniqueInput
    update?: XOR<XOR<ContentUpdateToOneWithWhereWithoutMediaInput, ContentUpdateWithoutMediaInput>, ContentUncheckedUpdateWithoutMediaInput>
  }

  export type MediaUpdateOneRequiredWithoutContentNestedInput = {
    create?: XOR<MediaCreateWithoutContentInput, MediaUncheckedCreateWithoutContentInput>
    connectOrCreate?: MediaCreateOrConnectWithoutContentInput
    upsert?: MediaUpsertWithoutContentInput
    connect?: MediaWhereUniqueInput
    update?: XOR<XOR<MediaUpdateToOneWithWhereWithoutContentInput, MediaUpdateWithoutContentInput>, MediaUncheckedUpdateWithoutContentInput>
  }

  export type ContentMediaCreateNestedManyWithoutMediaInput = {
    create?: XOR<ContentMediaCreateWithoutMediaInput, ContentMediaUncheckedCreateWithoutMediaInput> | ContentMediaCreateWithoutMediaInput[] | ContentMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutMediaInput | ContentMediaCreateOrConnectWithoutMediaInput[]
    createMany?: ContentMediaCreateManyMediaInputEnvelope
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
  }

  export type ContentMediaUncheckedCreateNestedManyWithoutMediaInput = {
    create?: XOR<ContentMediaCreateWithoutMediaInput, ContentMediaUncheckedCreateWithoutMediaInput> | ContentMediaCreateWithoutMediaInput[] | ContentMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutMediaInput | ContentMediaCreateOrConnectWithoutMediaInput[]
    createMany?: ContentMediaCreateManyMediaInputEnvelope
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
  }

  export type EnumMediaCategoryFieldUpdateOperationsInput = {
    set?: $Enums.MediaCategory
  }

  export type ContentMediaUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ContentMediaCreateWithoutMediaInput, ContentMediaUncheckedCreateWithoutMediaInput> | ContentMediaCreateWithoutMediaInput[] | ContentMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutMediaInput | ContentMediaCreateOrConnectWithoutMediaInput[]
    upsert?: ContentMediaUpsertWithWhereUniqueWithoutMediaInput | ContentMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ContentMediaCreateManyMediaInputEnvelope
    set?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    disconnect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    delete?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    update?: ContentMediaUpdateWithWhereUniqueWithoutMediaInput | ContentMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ContentMediaUpdateManyWithWhereWithoutMediaInput | ContentMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ContentMediaScalarWhereInput | ContentMediaScalarWhereInput[]
  }

  export type ContentMediaUncheckedUpdateManyWithoutMediaNestedInput = {
    create?: XOR<ContentMediaCreateWithoutMediaInput, ContentMediaUncheckedCreateWithoutMediaInput> | ContentMediaCreateWithoutMediaInput[] | ContentMediaUncheckedCreateWithoutMediaInput[]
    connectOrCreate?: ContentMediaCreateOrConnectWithoutMediaInput | ContentMediaCreateOrConnectWithoutMediaInput[]
    upsert?: ContentMediaUpsertWithWhereUniqueWithoutMediaInput | ContentMediaUpsertWithWhereUniqueWithoutMediaInput[]
    createMany?: ContentMediaCreateManyMediaInputEnvelope
    set?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    disconnect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    delete?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    connect?: ContentMediaWhereUniqueInput | ContentMediaWhereUniqueInput[]
    update?: ContentMediaUpdateWithWhereUniqueWithoutMediaInput | ContentMediaUpdateWithWhereUniqueWithoutMediaInput[]
    updateMany?: ContentMediaUpdateManyWithWhereWithoutMediaInput | ContentMediaUpdateManyWithWhereWithoutMediaInput[]
    deleteMany?: ContentMediaScalarWhereInput | ContentMediaScalarWhereInput[]
  }

  export type EnumSettingTypeFieldUpdateOperationsInput = {
    set?: $Enums.SettingType
  }

  export type RoomCreateNestedOneWithoutRoomContentInput = {
    create?: XOR<RoomCreateWithoutRoomContentInput, RoomUncheckedCreateWithoutRoomContentInput>
    connectOrCreate?: RoomCreateOrConnectWithoutRoomContentInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomUpdateOneRequiredWithoutRoomContentNestedInput = {
    create?: XOR<RoomCreateWithoutRoomContentInput, RoomUncheckedCreateWithoutRoomContentInput>
    connectOrCreate?: RoomCreateOrConnectWithoutRoomContentInput
    upsert?: RoomUpsertWithoutRoomContentInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutRoomContentInput, RoomUpdateWithoutRoomContentInput>, RoomUncheckedUpdateWithoutRoomContentInput>
  }

  export type RoomCreateNestedOneWithoutAvailabilityRulesInput = {
    create?: XOR<RoomCreateWithoutAvailabilityRulesInput, RoomUncheckedCreateWithoutAvailabilityRulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAvailabilityRulesInput
    connect?: RoomWhereUniqueInput
  }

  export type RoomUpdateOneRequiredWithoutAvailabilityRulesNestedInput = {
    create?: XOR<RoomCreateWithoutAvailabilityRulesInput, RoomUncheckedCreateWithoutAvailabilityRulesInput>
    connectOrCreate?: RoomCreateOrConnectWithoutAvailabilityRulesInput
    upsert?: RoomUpsertWithoutAvailabilityRulesInput
    connect?: RoomWhereUniqueInput
    update?: XOR<XOR<RoomUpdateToOneWithWhereWithoutAvailabilityRulesInput, RoomUpdateWithoutAvailabilityRulesInput>, RoomUncheckedUpdateWithoutAvailabilityRulesInput>
  }

  export type PropertyCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInquiriesInput
    connect?: PropertyWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInquiriesInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInquiryStatusFieldUpdateOperationsInput = {
    set?: $Enums.InquiryStatus
  }

  export type EnumInquiryPriorityFieldUpdateOperationsInput = {
    set?: $Enums.InquiryPriority
  }

  export type PropertyUpdateOneRequiredWithoutInquiriesNestedInput = {
    create?: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: PropertyCreateOrConnectWithoutInquiriesInput
    upsert?: PropertyUpsertWithoutInquiriesInput
    connect?: PropertyWhereUniqueInput
    update?: XOR<XOR<PropertyUpdateToOneWithWhereWithoutInquiriesInput, PropertyUpdateWithoutInquiriesInput>, PropertyUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserUpdateOneWithoutInquiriesNestedInput = {
    create?: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInquiriesInput
    upsert?: UserUpsertWithoutInquiriesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInquiriesInput, UserUpdateWithoutInquiriesInput>, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[]
    notIn?: $Enums.PropertyType[]
    not?: NestedEnumPropertyTypeFilter<$PrismaModel> | $Enums.PropertyType
  }

  export type NestedEnumPropertyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[]
    notIn?: $Enums.PropertyStatus[]
    not?: NestedEnumPropertyStatusFilter<$PrismaModel> | $Enums.PropertyStatus
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumCancellationPolicyFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicy | EnumCancellationPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicy[]
    notIn?: $Enums.CancellationPolicy[]
    not?: NestedEnumCancellationPolicyFilter<$PrismaModel> | $Enums.CancellationPolicy
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyType | EnumPropertyTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyType[]
    notIn?: $Enums.PropertyType[]
    not?: NestedEnumPropertyTypeWithAggregatesFilter<$PrismaModel> | $Enums.PropertyType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyTypeFilter<$PrismaModel>
    _max?: NestedEnumPropertyTypeFilter<$PrismaModel>
  }

  export type NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PropertyStatus | EnumPropertyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PropertyStatus[]
    notIn?: $Enums.PropertyStatus[]
    not?: NestedEnumPropertyStatusWithAggregatesFilter<$PrismaModel> | $Enums.PropertyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPropertyStatusFilter<$PrismaModel>
    _max?: NestedEnumPropertyStatusFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumCancellationPolicyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CancellationPolicy | EnumCancellationPolicyFieldRefInput<$PrismaModel>
    in?: $Enums.CancellationPolicy[]
    notIn?: $Enums.CancellationPolicy[]
    not?: NestedEnumCancellationPolicyWithAggregatesFilter<$PrismaModel> | $Enums.CancellationPolicy
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCancellationPolicyFilter<$PrismaModel>
    _max?: NestedEnumCancellationPolicyFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumBookingSourceFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingSource | EnumBookingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BookingSource[]
    notIn?: $Enums.BookingSource[]
    not?: NestedEnumBookingSourceFilter<$PrismaModel> | $Enums.BookingSource
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumBookingSourceWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingSource | EnumBookingSourceFieldRefInput<$PrismaModel>
    in?: $Enums.BookingSource[]
    notIn?: $Enums.BookingSource[]
    not?: NestedEnumBookingSourceWithAggregatesFilter<$PrismaModel> | $Enums.BookingSource
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingSourceFilter<$PrismaModel>
    _max?: NestedEnumBookingSourceFilter<$PrismaModel>
  }

  export type NestedEnumMaintenancePriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenancePriority | EnumMaintenancePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenancePriority[]
    notIn?: $Enums.MaintenancePriority[]
    not?: NestedEnumMaintenancePriorityFilter<$PrismaModel> | $Enums.MaintenancePriority
  }

  export type NestedEnumMaintenanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[]
    notIn?: $Enums.MaintenanceStatus[]
    not?: NestedEnumMaintenanceStatusFilter<$PrismaModel> | $Enums.MaintenanceStatus
  }

  export type NestedEnumMaintenancePriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenancePriority | EnumMaintenancePriorityFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenancePriority[]
    notIn?: $Enums.MaintenancePriority[]
    not?: NestedEnumMaintenancePriorityWithAggregatesFilter<$PrismaModel> | $Enums.MaintenancePriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenancePriorityFilter<$PrismaModel>
    _max?: NestedEnumMaintenancePriorityFilter<$PrismaModel>
  }

  export type NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MaintenanceStatus | EnumMaintenanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MaintenanceStatus[]
    notIn?: $Enums.MaintenanceStatus[]
    not?: NestedEnumMaintenanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.MaintenanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
    _max?: NestedEnumMaintenanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumMessageTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeFilter<$PrismaModel> | $Enums.MessageType
  }

  export type NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MessageType | EnumMessageTypeFieldRefInput<$PrismaModel>
    in?: $Enums.MessageType[]
    notIn?: $Enums.MessageType[]
    not?: NestedEnumMessageTypeWithAggregatesFilter<$PrismaModel> | $Enums.MessageType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMessageTypeFilter<$PrismaModel>
    _max?: NestedEnumMessageTypeFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[]
    notIn?: $Enums.NotificationType[]
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[]
    notIn?: $Enums.ContentStatus[]
    not?: NestedEnumContentStatusFilter<$PrismaModel> | $Enums.ContentStatus
  }

  export type NestedEnumContentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentStatus | EnumContentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ContentStatus[]
    notIn?: $Enums.ContentStatus[]
    not?: NestedEnumContentStatusWithAggregatesFilter<$PrismaModel> | $Enums.ContentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentStatusFilter<$PrismaModel>
    _max?: NestedEnumContentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[]
    notIn?: $Enums.PaymentMethod[]
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[]
    notIn?: $Enums.RoomType[]
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type NestedEnumCleaningFrequencyFilter<$PrismaModel = never> = {
    equals?: $Enums.CleaningFrequency | EnumCleaningFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.CleaningFrequency[]
    notIn?: $Enums.CleaningFrequency[]
    not?: NestedEnumCleaningFrequencyFilter<$PrismaModel> | $Enums.CleaningFrequency
  }

  export type NestedEnumCleaningFrequencyWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CleaningFrequency | EnumCleaningFrequencyFieldRefInput<$PrismaModel>
    in?: $Enums.CleaningFrequency[]
    notIn?: $Enums.CleaningFrequency[]
    not?: NestedEnumCleaningFrequencyWithAggregatesFilter<$PrismaModel> | $Enums.CleaningFrequency
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCleaningFrequencyFilter<$PrismaModel>
    _max?: NestedEnumCleaningFrequencyFilter<$PrismaModel>
  }

  export type NestedEnumAnalyticsPeriodFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[]
    notIn?: $Enums.AnalyticsPeriod[]
    not?: NestedEnumAnalyticsPeriodFilter<$PrismaModel> | $Enums.AnalyticsPeriod
  }

  export type NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AnalyticsPeriod | EnumAnalyticsPeriodFieldRefInput<$PrismaModel>
    in?: $Enums.AnalyticsPeriod[]
    notIn?: $Enums.AnalyticsPeriod[]
    not?: NestedEnumAnalyticsPeriodWithAggregatesFilter<$PrismaModel> | $Enums.AnalyticsPeriod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
    _max?: NestedEnumAnalyticsPeriodFilter<$PrismaModel>
  }

  export type NestedEnumNoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[]
    notIn?: $Enums.NoteType[]
    not?: NestedEnumNoteTypeFilter<$PrismaModel> | $Enums.NoteType
  }

  export type NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NoteType | EnumNoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NoteType[]
    notIn?: $Enums.NoteType[]
    not?: NestedEnumNoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.NoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNoteTypeFilter<$PrismaModel>
    _max?: NestedEnumNoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[]
    notIn?: $Enums.ContentType[]
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[]
    notIn?: $Enums.ContentType[]
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumMediaCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaCategory | EnumMediaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MediaCategory[]
    notIn?: $Enums.MediaCategory[]
    not?: NestedEnumMediaCategoryFilter<$PrismaModel> | $Enums.MediaCategory
  }

  export type NestedEnumMediaCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MediaCategory | EnumMediaCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.MediaCategory[]
    notIn?: $Enums.MediaCategory[]
    not?: NestedEnumMediaCategoryWithAggregatesFilter<$PrismaModel> | $Enums.MediaCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMediaCategoryFilter<$PrismaModel>
    _max?: NestedEnumMediaCategoryFilter<$PrismaModel>
  }

  export type NestedEnumSettingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeFilter<$PrismaModel> | $Enums.SettingType
  }

  export type NestedEnumSettingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SettingType | EnumSettingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SettingType[]
    notIn?: $Enums.SettingType[]
    not?: NestedEnumSettingTypeWithAggregatesFilter<$PrismaModel> | $Enums.SettingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSettingTypeFilter<$PrismaModel>
    _max?: NestedEnumSettingTypeFilter<$PrismaModel>
  }

  export type NestedEnumInquiryStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[]
    notIn?: $Enums.InquiryStatus[]
    not?: NestedEnumInquiryStatusFilter<$PrismaModel> | $Enums.InquiryStatus
  }

  export type NestedEnumInquiryPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[]
    notIn?: $Enums.InquiryPriority[]
    not?: NestedEnumInquiryPriorityFilter<$PrismaModel> | $Enums.InquiryPriority
  }

  export type NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryStatus | EnumInquiryStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryStatus[]
    notIn?: $Enums.InquiryStatus[]
    not?: NestedEnumInquiryStatusWithAggregatesFilter<$PrismaModel> | $Enums.InquiryStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryStatusFilter<$PrismaModel>
    _max?: NestedEnumInquiryStatusFilter<$PrismaModel>
  }

  export type NestedEnumInquiryPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InquiryPriority | EnumInquiryPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.InquiryPriority[]
    notIn?: $Enums.InquiryPriority[]
    not?: NestedEnumInquiryPriorityWithAggregatesFilter<$PrismaModel> | $Enums.InquiryPriority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInquiryPriorityFilter<$PrismaModel>
    _max?: NestedEnumInquiryPriorityFilter<$PrismaModel>
  }

  export type PropertyCreateWithoutOwnerInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutOwnerInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyCreateManyOwnerInputEnvelope = {
    data: PropertyCreateManyOwnerInput | PropertyCreateManyOwnerInput[]
  }

  export type BookingCreateWithoutGuestInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutGuestInput = {
    id?: string
    propertyId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutGuestInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput>
  }

  export type BookingCreateManyGuestInputEnvelope = {
    data: BookingCreateManyGuestInput | BookingCreateManyGuestInput[]
  }

  export type ReviewCreateWithoutGuestInput = {
    id?: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutReviewsInput
    booking: BookingCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutGuestInput = {
    id?: string
    propertyId: string
    bookingId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutGuestInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutGuestInput, ReviewUncheckedCreateWithoutGuestInput>
  }

  export type ReviewCreateManyGuestInputEnvelope = {
    data: ReviewCreateManyGuestInput | ReviewCreateManyGuestInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
    booking: BookingCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    bookingId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
  }

  export type PropertyGroupCreateWithoutOwnerInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutPropertyGroupInput
  }

  export type PropertyGroupUncheckedCreateWithoutOwnerInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutPropertyGroupInput
  }

  export type PropertyGroupCreateOrConnectWithoutOwnerInput = {
    where: PropertyGroupWhereUniqueInput
    create: XOR<PropertyGroupCreateWithoutOwnerInput, PropertyGroupUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyGroupCreateManyOwnerInputEnvelope = {
    data: PropertyGroupCreateManyOwnerInput | PropertyGroupCreateManyOwnerInput[]
  }

  export type RoomCreateWithoutOwnerInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRoomsInput
    roomContent?: RoomContentCreateNestedOneWithoutRoomInput
    availabilityRules?: RoomAvailabilityRuleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutOwnerInput = {
    id?: string
    propertyId: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    roomContent?: RoomContentUncheckedCreateNestedOneWithoutRoomInput
    availabilityRules?: RoomAvailabilityRuleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput>
  }

  export type RoomCreateManyOwnerInputEnvelope = {
    data: RoomCreateManyOwnerInput | RoomCreateManyOwnerInput[]
  }

  export type CleaningScheduleCreateWithoutOwnerInput = {
    id?: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutCleaningSchedulesInput
  }

  export type CleaningScheduleUncheckedCreateWithoutOwnerInput = {
    id?: string
    propertyId: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningScheduleCreateOrConnectWithoutOwnerInput = {
    where: CleaningScheduleWhereUniqueInput
    create: XOR<CleaningScheduleCreateWithoutOwnerInput, CleaningScheduleUncheckedCreateWithoutOwnerInput>
  }

  export type CleaningScheduleCreateManyOwnerInputEnvelope = {
    data: CleaningScheduleCreateManyOwnerInput | CleaningScheduleCreateManyOwnerInput[]
  }

  export type InquiryCreateWithoutAssigneeInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutAssigneeInput = {
    id?: string
    propertyId: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutAssigneeInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutAssigneeInput, InquiryUncheckedCreateWithoutAssigneeInput>
  }

  export type InquiryCreateManyAssigneeInputEnvelope = {
    data: InquiryCreateManyAssigneeInput | InquiryCreateManyAssigneeInput[]
  }

  export type PropertyUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
    create: XOR<PropertyCreateWithoutOwnerInput, PropertyUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutOwnerInput, PropertyUncheckedUpdateWithoutOwnerInput>
  }

  export type PropertyUpdateManyWithWhereWithoutOwnerInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PropertyScalarWhereInput = {
    AND?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    OR?: PropertyScalarWhereInput[]
    NOT?: PropertyScalarWhereInput | PropertyScalarWhereInput[]
    id?: StringFilter<"Property"> | string
    titleGr?: StringFilter<"Property"> | string
    titleEn?: StringFilter<"Property"> | string
    descriptionGr?: StringNullableFilter<"Property"> | string | null
    descriptionEn?: StringNullableFilter<"Property"> | string | null
    type?: EnumPropertyTypeFilter<"Property"> | $Enums.PropertyType
    status?: EnumPropertyStatusFilter<"Property"> | $Enums.PropertyStatus
    address?: StringFilter<"Property"> | string
    city?: StringFilter<"Property"> | string
    country?: StringFilter<"Property"> | string
    latitude?: FloatNullableFilter<"Property"> | number | null
    longitude?: FloatNullableFilter<"Property"> | number | null
    postalCode?: StringNullableFilter<"Property"> | string | null
    maxGuests?: IntFilter<"Property"> | number
    bedrooms?: IntFilter<"Property"> | number
    bathrooms?: IntFilter<"Property"> | number
    area?: FloatNullableFilter<"Property"> | number | null
    basePrice?: FloatFilter<"Property"> | number
    currency?: StringFilter<"Property"> | string
    cleaningFee?: FloatNullableFilter<"Property"> | number | null
    serviceFeePercentage?: FloatNullableFilter<"Property"> | number | null
    taxes?: FloatNullableFilter<"Property"> | number | null
    taxRate?: FloatNullableFilter<"Property"> | number | null
    minStay?: IntFilter<"Property"> | number
    maxStay?: IntNullableFilter<"Property"> | number | null
    advanceBooking?: IntFilter<"Property"> | number
    checkInTime?: StringNullableFilter<"Property"> | string | null
    checkOutTime?: StringNullableFilter<"Property"> | string | null
    cancellationPolicy?: EnumCancellationPolicyFilter<"Property"> | $Enums.CancellationPolicy
    houseRules?: StringNullableFilter<"Property"> | string | null
    petFriendly?: BoolFilter<"Property"> | boolean
    smokingAllowed?: BoolFilter<"Property"> | boolean
    partyAllowed?: BoolFilter<"Property"> | boolean
    hasDynamicRooms?: BoolFilter<"Property"> | boolean
    averageCleanlinessRating?: FloatNullableFilter<"Property"> | number | null
    lastCleaningDate?: DateTimeNullableFilter<"Property"> | Date | string | null
    propertyGroupId?: StringNullableFilter<"Property"> | string | null
    images?: JsonNullableFilter<"Property">
    videos?: JsonNullableFilter<"Property">
    ownerId?: StringFilter<"Property"> | string
    createdAt?: DateTimeFilter<"Property"> | Date | string
    updatedAt?: DateTimeFilter<"Property"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutGuestInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutGuestInput, BookingUncheckedUpdateWithoutGuestInput>
    create: XOR<BookingCreateWithoutGuestInput, BookingUncheckedCreateWithoutGuestInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutGuestInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutGuestInput, BookingUncheckedUpdateWithoutGuestInput>
  }

  export type BookingUpdateManyWithWhereWithoutGuestInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutGuestInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    propertyId?: StringFilter<"Booking"> | string
    guestId?: StringFilter<"Booking"> | string
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFilter<"Booking"> | $Enums.PaymentStatus
    checkIn?: DateTimeFilter<"Booking"> | Date | string
    checkOut?: DateTimeFilter<"Booking"> | Date | string
    guests?: IntFilter<"Booking"> | number
    totalPrice?: FloatFilter<"Booking"> | number
    basePrice?: FloatFilter<"Booking"> | number
    cleaningFee?: FloatNullableFilter<"Booking"> | number | null
    serviceFee?: FloatNullableFilter<"Booking"> | number | null
    taxes?: FloatNullableFilter<"Booking"> | number | null
    currency?: StringFilter<"Booking"> | string
    ownerRevenue?: FloatNullableFilter<"Booking"> | number | null
    platformFee?: FloatNullableFilter<"Booking"> | number | null
    source?: EnumBookingSourceFilter<"Booking"> | $Enums.BookingSource
    externalId?: StringNullableFilter<"Booking"> | string | null
    externalPlatform?: StringNullableFilter<"Booking"> | string | null
    externalData?: JsonNullableFilter<"Booking">
    commissionRate?: FloatNullableFilter<"Booking"> | number | null
    commissionAmount?: FloatNullableFilter<"Booking"> | number | null
    netRevenue?: FloatNullableFilter<"Booking"> | number | null
    externalGuestId?: StringNullableFilter<"Booking"> | string | null
    iCalUid?: StringNullableFilter<"Booking"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    roomId?: StringNullableFilter<"Booking"> | string | null
    roomName?: StringNullableFilter<"Booking"> | string | null
    guestName?: StringFilter<"Booking"> | string
    guestEmail?: StringFilter<"Booking"> | string
    guestPhone?: StringNullableFilter<"Booking"> | string | null
    specialRequests?: StringNullableFilter<"Booking"> | string | null
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutGuestInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutGuestInput, ReviewUncheckedUpdateWithoutGuestInput>
    create: XOR<ReviewCreateWithoutGuestInput, ReviewUncheckedCreateWithoutGuestInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutGuestInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutGuestInput, ReviewUncheckedUpdateWithoutGuestInput>
  }

  export type ReviewUpdateManyWithWhereWithoutGuestInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutGuestInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    propertyId?: StringFilter<"Review"> | string
    bookingId?: StringFilter<"Review"> | string
    guestId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    cleanlinessRating?: IntNullableFilter<"Review"> | number | null
    accuracyRating?: IntNullableFilter<"Review"> | number | null
    communicationRating?: IntNullableFilter<"Review"> | number | null
    locationRating?: IntNullableFilter<"Review"> | number | null
    valueRating?: IntNullableFilter<"Review"> | number | null
    title?: StringNullableFilter<"Review"> | string | null
    comment?: StringNullableFilter<"Review"> | string | null
    response?: StringNullableFilter<"Review"> | string | null
    isPublic?: BoolFilter<"Review"> | boolean
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    bookingId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    content?: StringFilter<"Message"> | string
    type?: EnumMessageTypeFilter<"Message"> | $Enums.MessageType
    isRead?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringFilter<"AuditLog"> | string
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    changes?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    metadata?: JsonNullableFilter<"AuditLog">
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type PropertyGroupUpsertWithWhereUniqueWithoutOwnerInput = {
    where: PropertyGroupWhereUniqueInput
    update: XOR<PropertyGroupUpdateWithoutOwnerInput, PropertyGroupUncheckedUpdateWithoutOwnerInput>
    create: XOR<PropertyGroupCreateWithoutOwnerInput, PropertyGroupUncheckedCreateWithoutOwnerInput>
  }

  export type PropertyGroupUpdateWithWhereUniqueWithoutOwnerInput = {
    where: PropertyGroupWhereUniqueInput
    data: XOR<PropertyGroupUpdateWithoutOwnerInput, PropertyGroupUncheckedUpdateWithoutOwnerInput>
  }

  export type PropertyGroupUpdateManyWithWhereWithoutOwnerInput = {
    where: PropertyGroupScalarWhereInput
    data: XOR<PropertyGroupUpdateManyMutationInput, PropertyGroupUncheckedUpdateManyWithoutOwnerInput>
  }

  export type PropertyGroupScalarWhereInput = {
    AND?: PropertyGroupScalarWhereInput | PropertyGroupScalarWhereInput[]
    OR?: PropertyGroupScalarWhereInput[]
    NOT?: PropertyGroupScalarWhereInput | PropertyGroupScalarWhereInput[]
    id?: StringFilter<"PropertyGroup"> | string
    name?: StringFilter<"PropertyGroup"> | string
    nameGr?: StringNullableFilter<"PropertyGroup"> | string | null
    nameEn?: StringNullableFilter<"PropertyGroup"> | string | null
    description?: StringNullableFilter<"PropertyGroup"> | string | null
    ownerId?: StringFilter<"PropertyGroup"> | string
    createdAt?: DateTimeFilter<"PropertyGroup"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyGroup"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutOwnerInput, RoomUncheckedUpdateWithoutOwnerInput>
    create: XOR<RoomCreateWithoutOwnerInput, RoomUncheckedCreateWithoutOwnerInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutOwnerInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutOwnerInput, RoomUncheckedUpdateWithoutOwnerInput>
  }

  export type RoomUpdateManyWithWhereWithoutOwnerInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutOwnerInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: StringFilter<"Room"> | string
    propertyId?: StringFilter<"Room"> | string
    name?: StringFilter<"Room"> | string
    nameGr?: StringNullableFilter<"Room"> | string | null
    nameEn?: StringNullableFilter<"Room"> | string | null
    type?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    capacity?: IntFilter<"Room"> | number
    maxAdults?: IntNullableFilter<"Room"> | number | null
    maxChildren?: IntNullableFilter<"Room"> | number | null
    maxInfants?: IntNullableFilter<"Room"> | number | null
    basePrice?: FloatFilter<"Room"> | number
    isBookable?: BoolFilter<"Room"> | boolean
    amenities?: JsonNullableFilter<"Room">
    images?: JsonNullableFilter<"Room">
    descriptionGr?: StringNullableFilter<"Room"> | string | null
    descriptionEn?: StringNullableFilter<"Room"> | string | null
    ownerId?: StringFilter<"Room"> | string
    createdAt?: DateTimeFilter<"Room"> | Date | string
    updatedAt?: DateTimeFilter<"Room"> | Date | string
  }

  export type CleaningScheduleUpsertWithWhereUniqueWithoutOwnerInput = {
    where: CleaningScheduleWhereUniqueInput
    update: XOR<CleaningScheduleUpdateWithoutOwnerInput, CleaningScheduleUncheckedUpdateWithoutOwnerInput>
    create: XOR<CleaningScheduleCreateWithoutOwnerInput, CleaningScheduleUncheckedCreateWithoutOwnerInput>
  }

  export type CleaningScheduleUpdateWithWhereUniqueWithoutOwnerInput = {
    where: CleaningScheduleWhereUniqueInput
    data: XOR<CleaningScheduleUpdateWithoutOwnerInput, CleaningScheduleUncheckedUpdateWithoutOwnerInput>
  }

  export type CleaningScheduleUpdateManyWithWhereWithoutOwnerInput = {
    where: CleaningScheduleScalarWhereInput
    data: XOR<CleaningScheduleUpdateManyMutationInput, CleaningScheduleUncheckedUpdateManyWithoutOwnerInput>
  }

  export type CleaningScheduleScalarWhereInput = {
    AND?: CleaningScheduleScalarWhereInput | CleaningScheduleScalarWhereInput[]
    OR?: CleaningScheduleScalarWhereInput[]
    NOT?: CleaningScheduleScalarWhereInput | CleaningScheduleScalarWhereInput[]
    id?: StringFilter<"CleaningSchedule"> | string
    propertyId?: StringFilter<"CleaningSchedule"> | string
    frequency?: EnumCleaningFrequencyFilter<"CleaningSchedule"> | $Enums.CleaningFrequency
    lastCleaned?: DateTimeNullableFilter<"CleaningSchedule"> | Date | string | null
    nextCleaning?: DateTimeNullableFilter<"CleaningSchedule"> | Date | string | null
    assignedCleaner?: StringNullableFilter<"CleaningSchedule"> | string | null
    ownerId?: StringFilter<"CleaningSchedule"> | string
    notes?: StringNullableFilter<"CleaningSchedule"> | string | null
    createdAt?: DateTimeFilter<"CleaningSchedule"> | Date | string
    updatedAt?: DateTimeFilter<"CleaningSchedule"> | Date | string
  }

  export type InquiryUpsertWithWhereUniqueWithoutAssigneeInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutAssigneeInput, InquiryUncheckedUpdateWithoutAssigneeInput>
    create: XOR<InquiryCreateWithoutAssigneeInput, InquiryUncheckedCreateWithoutAssigneeInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutAssigneeInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutAssigneeInput, InquiryUncheckedUpdateWithoutAssigneeInput>
  }

  export type InquiryUpdateManyWithWhereWithoutAssigneeInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutAssigneeInput>
  }

  export type InquiryScalarWhereInput = {
    AND?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    OR?: InquiryScalarWhereInput[]
    NOT?: InquiryScalarWhereInput | InquiryScalarWhereInput[]
    id?: StringFilter<"Inquiry"> | string
    propertyId?: StringFilter<"Inquiry"> | string
    name?: StringFilter<"Inquiry"> | string
    email?: StringFilter<"Inquiry"> | string
    phone?: StringNullableFilter<"Inquiry"> | string | null
    message?: StringFilter<"Inquiry"> | string
    status?: EnumInquiryStatusFilter<"Inquiry"> | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFilter<"Inquiry"> | $Enums.InquiryPriority
    respondedAt?: DateTimeNullableFilter<"Inquiry"> | Date | string | null
    respondedBy?: StringNullableFilter<"Inquiry"> | string | null
    response?: StringNullableFilter<"Inquiry"> | string | null
    adminNotes?: StringNullableFilter<"Inquiry"> | string | null
    assignedTo?: StringNullableFilter<"Inquiry"> | string | null
    createdAt?: DateTimeFilter<"Inquiry"> | Date | string
    updatedAt?: DateTimeFilter<"Inquiry"> | Date | string
  }

  export type UserCreateWithoutPropertiesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutPropertiesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutPropertiesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
  }

  export type BookingCreateWithoutPropertyInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    guest: UserCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPropertyInput = {
    id?: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPropertyInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput>
  }

  export type BookingCreateManyPropertyInputEnvelope = {
    data: BookingCreateManyPropertyInput | BookingCreateManyPropertyInput[]
  }

  export type ReviewCreateWithoutPropertyInput = {
    id?: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutReviewsInput
    guest: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutPropertyInput = {
    id?: string
    bookingId: string
    guestId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutPropertyInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutPropertyInput, ReviewUncheckedCreateWithoutPropertyInput>
  }

  export type ReviewCreateManyPropertyInputEnvelope = {
    data: ReviewCreateManyPropertyInput | ReviewCreateManyPropertyInput[]
  }

  export type PropertyAmenityCreateWithoutPropertyInput = {
    id?: string
    amenity: AmenityCreateNestedOneWithoutPropertiesInput
  }

  export type PropertyAmenityUncheckedCreateWithoutPropertyInput = {
    id?: string
    amenityId: string
  }

  export type PropertyAmenityCreateOrConnectWithoutPropertyInput = {
    where: PropertyAmenityWhereUniqueInput
    create: XOR<PropertyAmenityCreateWithoutPropertyInput, PropertyAmenityUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyAmenityCreateManyPropertyInputEnvelope = {
    data: PropertyAmenityCreateManyPropertyInput | PropertyAmenityCreateManyPropertyInput[]
  }

  export type PropertyAvailabilityCreateWithoutPropertyInput = {
    id?: string
    date: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAvailabilityUncheckedCreateWithoutPropertyInput = {
    id?: string
    date: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAvailabilityCreateOrConnectWithoutPropertyInput = {
    where: PropertyAvailabilityWhereUniqueInput
    create: XOR<PropertyAvailabilityCreateWithoutPropertyInput, PropertyAvailabilityUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyAvailabilityCreateManyPropertyInputEnvelope = {
    data: PropertyAvailabilityCreateManyPropertyInput | PropertyAvailabilityCreateManyPropertyInput[]
  }

  export type MaintenanceRequestCreateWithoutPropertyInput = {
    id?: string
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking?: BookingCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutPropertyInput = {
    id?: string
    bookingId?: string | null
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestCreateOrConnectWithoutPropertyInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutPropertyInput, MaintenanceRequestUncheckedCreateWithoutPropertyInput>
  }

  export type MaintenanceRequestCreateManyPropertyInputEnvelope = {
    data: MaintenanceRequestCreateManyPropertyInput | MaintenanceRequestCreateManyPropertyInput[]
  }

  export type RoomCreateWithoutPropertyInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutRoomsInput
    roomContent?: RoomContentCreateNestedOneWithoutRoomInput
    availabilityRules?: RoomAvailabilityRuleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomContent?: RoomContentUncheckedCreateNestedOneWithoutRoomInput
    availabilityRules?: RoomAvailabilityRuleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutPropertyInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutPropertyInput, RoomUncheckedCreateWithoutPropertyInput>
  }

  export type RoomCreateManyPropertyInputEnvelope = {
    data: RoomCreateManyPropertyInput | RoomCreateManyPropertyInput[]
  }

  export type PropertyNoteCreateWithoutPropertyInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyNoteUncheckedCreateWithoutPropertyInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyNoteCreateOrConnectWithoutPropertyInput = {
    where: PropertyNoteWhereUniqueInput
    create: XOR<PropertyNoteCreateWithoutPropertyInput, PropertyNoteUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyNoteCreateManyPropertyInputEnvelope = {
    data: PropertyNoteCreateManyPropertyInput | PropertyNoteCreateManyPropertyInput[]
  }

  export type PropertyAnalyticsCreateWithoutPropertyInput = {
    id?: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
    periodEnd: Date | string
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom?: number | null
    averageRating?: number | null
    averageCleanlinessRating?: number | null
    totalReviews: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAnalyticsUncheckedCreateWithoutPropertyInput = {
    id?: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
    periodEnd: Date | string
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom?: number | null
    averageRating?: number | null
    averageCleanlinessRating?: number | null
    totalReviews: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAnalyticsCreateOrConnectWithoutPropertyInput = {
    where: PropertyAnalyticsWhereUniqueInput
    create: XOR<PropertyAnalyticsCreateWithoutPropertyInput, PropertyAnalyticsUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyAnalyticsCreateManyPropertyInputEnvelope = {
    data: PropertyAnalyticsCreateManyPropertyInput | PropertyAnalyticsCreateManyPropertyInput[]
  }

  export type CleaningScheduleCreateWithoutPropertyInput = {
    id?: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutCleaningSchedulesInput
  }

  export type CleaningScheduleUncheckedCreateWithoutPropertyInput = {
    id?: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    ownerId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningScheduleCreateOrConnectWithoutPropertyInput = {
    where: CleaningScheduleWhereUniqueInput
    create: XOR<CleaningScheduleCreateWithoutPropertyInput, CleaningScheduleUncheckedCreateWithoutPropertyInput>
  }

  export type CleaningScheduleCreateManyPropertyInputEnvelope = {
    data: CleaningScheduleCreateManyPropertyInput | CleaningScheduleCreateManyPropertyInput[]
  }

  export type PropertyGroupCreateWithoutPropertiesInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertyGroupsInput
  }

  export type PropertyGroupUncheckedCreateWithoutPropertiesInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyGroupCreateOrConnectWithoutPropertiesInput = {
    where: PropertyGroupWhereUniqueInput
    create: XOR<PropertyGroupCreateWithoutPropertiesInput, PropertyGroupUncheckedCreateWithoutPropertiesInput>
  }

  export type PaymentCreateWithoutPropertyInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutPropertyInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutPropertyInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput>
  }

  export type PaymentCreateManyPropertyInputEnvelope = {
    data: PaymentCreateManyPropertyInput | PaymentCreateManyPropertyInput[]
  }

  export type InquiryCreateWithoutPropertyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assignee?: UserCreateNestedOneWithoutInquiriesInput
  }

  export type InquiryUncheckedCreateWithoutPropertyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateOrConnectWithoutPropertyInput = {
    where: InquiryWhereUniqueInput
    create: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput>
  }

  export type InquiryCreateManyPropertyInputEnvelope = {
    data: InquiryCreateManyPropertyInput | InquiryCreateManyPropertyInput[]
  }

  export type UserUpsertWithoutPropertiesInput = {
    update: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
    create: XOR<UserCreateWithoutPropertiesInput, UserUncheckedCreateWithoutPropertiesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertiesInput, UserUncheckedUpdateWithoutPropertiesInput>
  }

  export type UserUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutPropertyInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutPropertyInput, BookingUncheckedUpdateWithoutPropertyInput>
    create: XOR<BookingCreateWithoutPropertyInput, BookingUncheckedCreateWithoutPropertyInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutPropertyInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutPropertyInput, BookingUncheckedUpdateWithoutPropertyInput>
  }

  export type BookingUpdateManyWithWhereWithoutPropertyInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutPropertyInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutPropertyInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutPropertyInput, ReviewUncheckedUpdateWithoutPropertyInput>
    create: XOR<ReviewCreateWithoutPropertyInput, ReviewUncheckedCreateWithoutPropertyInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutPropertyInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutPropertyInput, ReviewUncheckedUpdateWithoutPropertyInput>
  }

  export type ReviewUpdateManyWithWhereWithoutPropertyInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyAmenityUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyAmenityWhereUniqueInput
    update: XOR<PropertyAmenityUpdateWithoutPropertyInput, PropertyAmenityUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyAmenityCreateWithoutPropertyInput, PropertyAmenityUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyAmenityUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyAmenityWhereUniqueInput
    data: XOR<PropertyAmenityUpdateWithoutPropertyInput, PropertyAmenityUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyAmenityUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyAmenityScalarWhereInput
    data: XOR<PropertyAmenityUpdateManyMutationInput, PropertyAmenityUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyAmenityScalarWhereInput = {
    AND?: PropertyAmenityScalarWhereInput | PropertyAmenityScalarWhereInput[]
    OR?: PropertyAmenityScalarWhereInput[]
    NOT?: PropertyAmenityScalarWhereInput | PropertyAmenityScalarWhereInput[]
    id?: StringFilter<"PropertyAmenity"> | string
    propertyId?: StringFilter<"PropertyAmenity"> | string
    amenityId?: StringFilter<"PropertyAmenity"> | string
  }

  export type PropertyAvailabilityUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyAvailabilityWhereUniqueInput
    update: XOR<PropertyAvailabilityUpdateWithoutPropertyInput, PropertyAvailabilityUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyAvailabilityCreateWithoutPropertyInput, PropertyAvailabilityUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyAvailabilityUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyAvailabilityWhereUniqueInput
    data: XOR<PropertyAvailabilityUpdateWithoutPropertyInput, PropertyAvailabilityUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyAvailabilityUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyAvailabilityScalarWhereInput
    data: XOR<PropertyAvailabilityUpdateManyMutationInput, PropertyAvailabilityUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyAvailabilityScalarWhereInput = {
    AND?: PropertyAvailabilityScalarWhereInput | PropertyAvailabilityScalarWhereInput[]
    OR?: PropertyAvailabilityScalarWhereInput[]
    NOT?: PropertyAvailabilityScalarWhereInput | PropertyAvailabilityScalarWhereInput[]
    id?: StringFilter<"PropertyAvailability"> | string
    propertyId?: StringFilter<"PropertyAvailability"> | string
    date?: DateTimeFilter<"PropertyAvailability"> | Date | string
    available?: BoolFilter<"PropertyAvailability"> | boolean
    price?: FloatNullableFilter<"PropertyAvailability"> | number | null
    minStay?: IntNullableFilter<"PropertyAvailability"> | number | null
    createdAt?: DateTimeFilter<"PropertyAvailability"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAvailability"> | Date | string
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutPropertyInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutPropertyInput, MaintenanceRequestUncheckedUpdateWithoutPropertyInput>
    create: XOR<MaintenanceRequestCreateWithoutPropertyInput, MaintenanceRequestUncheckedCreateWithoutPropertyInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutPropertyInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutPropertyInput, MaintenanceRequestUncheckedUpdateWithoutPropertyInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutPropertyInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutPropertyInput>
  }

  export type MaintenanceRequestScalarWhereInput = {
    AND?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    OR?: MaintenanceRequestScalarWhereInput[]
    NOT?: MaintenanceRequestScalarWhereInput | MaintenanceRequestScalarWhereInput[]
    id?: StringFilter<"MaintenanceRequest"> | string
    propertyId?: StringFilter<"MaintenanceRequest"> | string
    bookingId?: StringNullableFilter<"MaintenanceRequest"> | string | null
    title?: StringFilter<"MaintenanceRequest"> | string
    description?: StringFilter<"MaintenanceRequest"> | string
    priority?: EnumMaintenancePriorityFilter<"MaintenanceRequest"> | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFilter<"MaintenanceRequest"> | $Enums.MaintenanceStatus
    assignedTo?: StringNullableFilter<"MaintenanceRequest"> | string | null
    completedAt?: DateTimeNullableFilter<"MaintenanceRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
    updatedAt?: DateTimeFilter<"MaintenanceRequest"> | Date | string
  }

  export type RoomUpsertWithWhereUniqueWithoutPropertyInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutPropertyInput, RoomUncheckedUpdateWithoutPropertyInput>
    create: XOR<RoomCreateWithoutPropertyInput, RoomUncheckedCreateWithoutPropertyInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutPropertyInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutPropertyInput, RoomUncheckedUpdateWithoutPropertyInput>
  }

  export type RoomUpdateManyWithWhereWithoutPropertyInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyNoteUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyNoteWhereUniqueInput
    update: XOR<PropertyNoteUpdateWithoutPropertyInput, PropertyNoteUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyNoteCreateWithoutPropertyInput, PropertyNoteUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyNoteUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyNoteWhereUniqueInput
    data: XOR<PropertyNoteUpdateWithoutPropertyInput, PropertyNoteUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyNoteUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyNoteScalarWhereInput
    data: XOR<PropertyNoteUpdateManyMutationInput, PropertyNoteUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyNoteScalarWhereInput = {
    AND?: PropertyNoteScalarWhereInput | PropertyNoteScalarWhereInput[]
    OR?: PropertyNoteScalarWhereInput[]
    NOT?: PropertyNoteScalarWhereInput | PropertyNoteScalarWhereInput[]
    id?: StringFilter<"PropertyNote"> | string
    propertyId?: StringFilter<"PropertyNote"> | string
    type?: EnumNoteTypeFilter<"PropertyNote"> | $Enums.NoteType
    title?: StringFilter<"PropertyNote"> | string
    content?: StringFilter<"PropertyNote"> | string
    isPrivate?: BoolFilter<"PropertyNote"> | boolean
    createdBy?: StringFilter<"PropertyNote"> | string
    createdAt?: DateTimeFilter<"PropertyNote"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyNote"> | Date | string
  }

  export type PropertyAnalyticsUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PropertyAnalyticsWhereUniqueInput
    update: XOR<PropertyAnalyticsUpdateWithoutPropertyInput, PropertyAnalyticsUncheckedUpdateWithoutPropertyInput>
    create: XOR<PropertyAnalyticsCreateWithoutPropertyInput, PropertyAnalyticsUncheckedCreateWithoutPropertyInput>
  }

  export type PropertyAnalyticsUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PropertyAnalyticsWhereUniqueInput
    data: XOR<PropertyAnalyticsUpdateWithoutPropertyInput, PropertyAnalyticsUncheckedUpdateWithoutPropertyInput>
  }

  export type PropertyAnalyticsUpdateManyWithWhereWithoutPropertyInput = {
    where: PropertyAnalyticsScalarWhereInput
    data: XOR<PropertyAnalyticsUpdateManyMutationInput, PropertyAnalyticsUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyAnalyticsScalarWhereInput = {
    AND?: PropertyAnalyticsScalarWhereInput | PropertyAnalyticsScalarWhereInput[]
    OR?: PropertyAnalyticsScalarWhereInput[]
    NOT?: PropertyAnalyticsScalarWhereInput | PropertyAnalyticsScalarWhereInput[]
    id?: StringFilter<"PropertyAnalytics"> | string
    propertyId?: StringFilter<"PropertyAnalytics"> | string
    period?: EnumAnalyticsPeriodFilter<"PropertyAnalytics"> | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    periodEnd?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    totalRevenue?: FloatFilter<"PropertyAnalytics"> | number
    totalCosts?: FloatFilter<"PropertyAnalytics"> | number
    cleaningCosts?: FloatFilter<"PropertyAnalytics"> | number
    maintenanceCosts?: FloatFilter<"PropertyAnalytics"> | number
    platformFees?: FloatFilter<"PropertyAnalytics"> | number
    netProfit?: FloatFilter<"PropertyAnalytics"> | number
    profitMargin?: FloatFilter<"PropertyAnalytics"> | number
    totalBookings?: IntFilter<"PropertyAnalytics"> | number
    cancelledBookings?: IntFilter<"PropertyAnalytics"> | number
    occupancyRate?: FloatFilter<"PropertyAnalytics"> | number
    averageDailyRate?: FloatFilter<"PropertyAnalytics"> | number
    revenuePerAvailableRoom?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    averageRating?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    averageCleanlinessRating?: FloatNullableFilter<"PropertyAnalytics"> | number | null
    totalReviews?: IntFilter<"PropertyAnalytics"> | number
    createdAt?: DateTimeFilter<"PropertyAnalytics"> | Date | string
    updatedAt?: DateTimeFilter<"PropertyAnalytics"> | Date | string
  }

  export type CleaningScheduleUpsertWithWhereUniqueWithoutPropertyInput = {
    where: CleaningScheduleWhereUniqueInput
    update: XOR<CleaningScheduleUpdateWithoutPropertyInput, CleaningScheduleUncheckedUpdateWithoutPropertyInput>
    create: XOR<CleaningScheduleCreateWithoutPropertyInput, CleaningScheduleUncheckedCreateWithoutPropertyInput>
  }

  export type CleaningScheduleUpdateWithWhereUniqueWithoutPropertyInput = {
    where: CleaningScheduleWhereUniqueInput
    data: XOR<CleaningScheduleUpdateWithoutPropertyInput, CleaningScheduleUncheckedUpdateWithoutPropertyInput>
  }

  export type CleaningScheduleUpdateManyWithWhereWithoutPropertyInput = {
    where: CleaningScheduleScalarWhereInput
    data: XOR<CleaningScheduleUpdateManyMutationInput, CleaningScheduleUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyGroupUpsertWithoutPropertiesInput = {
    update: XOR<PropertyGroupUpdateWithoutPropertiesInput, PropertyGroupUncheckedUpdateWithoutPropertiesInput>
    create: XOR<PropertyGroupCreateWithoutPropertiesInput, PropertyGroupUncheckedCreateWithoutPropertiesInput>
    where?: PropertyGroupWhereInput
  }

  export type PropertyGroupUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: PropertyGroupWhereInput
    data: XOR<PropertyGroupUpdateWithoutPropertiesInput, PropertyGroupUncheckedUpdateWithoutPropertiesInput>
  }

  export type PropertyGroupUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertyGroupsNestedInput
  }

  export type PropertyGroupUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutPropertyInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutPropertyInput, PaymentUncheckedUpdateWithoutPropertyInput>
    create: XOR<PaymentCreateWithoutPropertyInput, PaymentUncheckedCreateWithoutPropertyInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutPropertyInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutPropertyInput, PaymentUncheckedUpdateWithoutPropertyInput>
  }

  export type PaymentUpdateManyWithWhereWithoutPropertyInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    propertyId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    method?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    transactionId?: StringNullableFilter<"Payment"> | string | null
    stripePaymentIntentId?: StringNullableFilter<"Payment"> | string | null
    stripeChargeId?: StringNullableFilter<"Payment"> | string | null
    refundAmount?: FloatNullableFilter<"Payment"> | number | null
    refundReason?: StringNullableFilter<"Payment"> | string | null
    refundedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    payoutId?: StringNullableFilter<"Payment"> | string | null
    payoutStatus?: StringNullableFilter<"Payment"> | string | null
    payoutScheduledFor?: DateTimeNullableFilter<"Payment"> | Date | string | null
    processedAt?: DateTimeNullableFilter<"Payment"> | Date | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InquiryUpsertWithWhereUniqueWithoutPropertyInput = {
    where: InquiryWhereUniqueInput
    update: XOR<InquiryUpdateWithoutPropertyInput, InquiryUncheckedUpdateWithoutPropertyInput>
    create: XOR<InquiryCreateWithoutPropertyInput, InquiryUncheckedCreateWithoutPropertyInput>
  }

  export type InquiryUpdateWithWhereUniqueWithoutPropertyInput = {
    where: InquiryWhereUniqueInput
    data: XOR<InquiryUpdateWithoutPropertyInput, InquiryUncheckedUpdateWithoutPropertyInput>
  }

  export type InquiryUpdateManyWithWhereWithoutPropertyInput = {
    where: InquiryScalarWhereInput
    data: XOR<InquiryUpdateManyMutationInput, InquiryUncheckedUpdateManyWithoutPropertyInput>
  }

  export type PropertyAmenityCreateWithoutAmenityInput = {
    id?: string
    property: PropertyCreateNestedOneWithoutAmenitiesInput
  }

  export type PropertyAmenityUncheckedCreateWithoutAmenityInput = {
    id?: string
    propertyId: string
  }

  export type PropertyAmenityCreateOrConnectWithoutAmenityInput = {
    where: PropertyAmenityWhereUniqueInput
    create: XOR<PropertyAmenityCreateWithoutAmenityInput, PropertyAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type PropertyAmenityCreateManyAmenityInputEnvelope = {
    data: PropertyAmenityCreateManyAmenityInput | PropertyAmenityCreateManyAmenityInput[]
  }

  export type PropertyAmenityUpsertWithWhereUniqueWithoutAmenityInput = {
    where: PropertyAmenityWhereUniqueInput
    update: XOR<PropertyAmenityUpdateWithoutAmenityInput, PropertyAmenityUncheckedUpdateWithoutAmenityInput>
    create: XOR<PropertyAmenityCreateWithoutAmenityInput, PropertyAmenityUncheckedCreateWithoutAmenityInput>
  }

  export type PropertyAmenityUpdateWithWhereUniqueWithoutAmenityInput = {
    where: PropertyAmenityWhereUniqueInput
    data: XOR<PropertyAmenityUpdateWithoutAmenityInput, PropertyAmenityUncheckedUpdateWithoutAmenityInput>
  }

  export type PropertyAmenityUpdateManyWithWhereWithoutAmenityInput = {
    where: PropertyAmenityScalarWhereInput
    data: XOR<PropertyAmenityUpdateManyMutationInput, PropertyAmenityUncheckedUpdateManyWithoutAmenityInput>
  }

  export type PropertyCreateWithoutAmenitiesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAmenitiesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAmenitiesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAmenitiesInput, PropertyUncheckedCreateWithoutAmenitiesInput>
  }

  export type AmenityCreateWithoutPropertiesInput = {
    id?: string
    nameGr: string
    nameEn: string
    icon?: string | null
    category: string
    createdAt?: Date | string
  }

  export type AmenityUncheckedCreateWithoutPropertiesInput = {
    id?: string
    nameGr: string
    nameEn: string
    icon?: string | null
    category: string
    createdAt?: Date | string
  }

  export type AmenityCreateOrConnectWithoutPropertiesInput = {
    where: AmenityWhereUniqueInput
    create: XOR<AmenityCreateWithoutPropertiesInput, AmenityUncheckedCreateWithoutPropertiesInput>
  }

  export type PropertyUpsertWithoutAmenitiesInput = {
    update: XOR<PropertyUpdateWithoutAmenitiesInput, PropertyUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<PropertyCreateWithoutAmenitiesInput, PropertyUncheckedCreateWithoutAmenitiesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutAmenitiesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutAmenitiesInput, PropertyUncheckedUpdateWithoutAmenitiesInput>
  }

  export type PropertyUpdateWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type AmenityUpsertWithoutPropertiesInput = {
    update: XOR<AmenityUpdateWithoutPropertiesInput, AmenityUncheckedUpdateWithoutPropertiesInput>
    create: XOR<AmenityCreateWithoutPropertiesInput, AmenityUncheckedCreateWithoutPropertiesInput>
    where?: AmenityWhereInput
  }

  export type AmenityUpdateToOneWithWhereWithoutPropertiesInput = {
    where?: AmenityWhereInput
    data: XOR<AmenityUpdateWithoutPropertiesInput, AmenityUncheckedUpdateWithoutPropertiesInput>
  }

  export type AmenityUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameGr?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AmenityUncheckedUpdateWithoutPropertiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nameGr?: StringFieldUpdateOperationsInput | string
    nameEn?: StringFieldUpdateOperationsInput | string
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateWithoutBookingsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutBookingsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutBookingsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutBookingsInput, PropertyUncheckedCreateWithoutBookingsInput>
  }

  export type UserCreateWithoutBookingsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutBookingsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: string
    propertyId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateManyBookingInputEnvelope = {
    data: PaymentCreateManyBookingInput | PaymentCreateManyBookingInput[]
  }

  export type ReviewCreateWithoutBookingInput = {
    id?: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutReviewsInput
    guest: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutBookingInput = {
    id?: string
    propertyId: string
    guestId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type ReviewCreateManyBookingInputEnvelope = {
    data: ReviewCreateManyBookingInput | ReviewCreateManyBookingInput[]
  }

  export type MessageCreateWithoutBookingInput = {
    id?: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
    sender: UserCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutBookingInput = {
    id?: string
    senderId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutBookingInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput>
  }

  export type MessageCreateManyBookingInputEnvelope = {
    data: MessageCreateManyBookingInput | MessageCreateManyBookingInput[]
  }

  export type MaintenanceRequestCreateWithoutBookingInput = {
    id?: string
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutMaintenanceInput
  }

  export type MaintenanceRequestUncheckedCreateWithoutBookingInput = {
    id?: string
    propertyId: string
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestCreateOrConnectWithoutBookingInput = {
    where: MaintenanceRequestWhereUniqueInput
    create: XOR<MaintenanceRequestCreateWithoutBookingInput, MaintenanceRequestUncheckedCreateWithoutBookingInput>
  }

  export type MaintenanceRequestCreateManyBookingInputEnvelope = {
    data: MaintenanceRequestCreateManyBookingInput | MaintenanceRequestCreateManyBookingInput[]
  }

  export type PropertyUpsertWithoutBookingsInput = {
    update: XOR<PropertyUpdateWithoutBookingsInput, PropertyUncheckedUpdateWithoutBookingsInput>
    create: XOR<PropertyCreateWithoutBookingsInput, PropertyUncheckedCreateWithoutBookingsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutBookingsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutBookingsInput, PropertyUncheckedUpdateWithoutBookingsInput>
  }

  export type PropertyUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutBookingsInput = {
    update: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
    create: XOR<UserCreateWithoutBookingsInput, UserUncheckedCreateWithoutBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBookingsInput, UserUncheckedUpdateWithoutBookingsInput>
  }

  export type UserUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
    create: XOR<ReviewCreateWithoutBookingInput, ReviewUncheckedCreateWithoutBookingInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutBookingInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutBookingInput, ReviewUncheckedUpdateWithoutBookingInput>
  }

  export type ReviewUpdateManyWithWhereWithoutBookingInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutBookingInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutBookingInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutBookingInput, MessageUncheckedUpdateWithoutBookingInput>
    create: XOR<MessageCreateWithoutBookingInput, MessageUncheckedCreateWithoutBookingInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutBookingInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutBookingInput, MessageUncheckedUpdateWithoutBookingInput>
  }

  export type MessageUpdateManyWithWhereWithoutBookingInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutBookingInput>
  }

  export type MaintenanceRequestUpsertWithWhereUniqueWithoutBookingInput = {
    where: MaintenanceRequestWhereUniqueInput
    update: XOR<MaintenanceRequestUpdateWithoutBookingInput, MaintenanceRequestUncheckedUpdateWithoutBookingInput>
    create: XOR<MaintenanceRequestCreateWithoutBookingInput, MaintenanceRequestUncheckedCreateWithoutBookingInput>
  }

  export type MaintenanceRequestUpdateWithWhereUniqueWithoutBookingInput = {
    where: MaintenanceRequestWhereUniqueInput
    data: XOR<MaintenanceRequestUpdateWithoutBookingInput, MaintenanceRequestUncheckedUpdateWithoutBookingInput>
  }

  export type MaintenanceRequestUpdateManyWithWhereWithoutBookingInput = {
    where: MaintenanceRequestScalarWhereInput
    data: XOR<MaintenanceRequestUpdateManyMutationInput, MaintenanceRequestUncheckedUpdateManyWithoutBookingInput>
  }

  export type PropertyCreateWithoutAvailabilityInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAvailabilityInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAvailabilityInput, PropertyUncheckedCreateWithoutAvailabilityInput>
  }

  export type PropertyUpsertWithoutAvailabilityInput = {
    update: XOR<PropertyUpdateWithoutAvailabilityInput, PropertyUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<PropertyCreateWithoutAvailabilityInput, PropertyUncheckedCreateWithoutAvailabilityInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutAvailabilityInput, PropertyUncheckedUpdateWithoutAvailabilityInput>
  }

  export type PropertyUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAvailabilityInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutReviewsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutReviewsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutReviewsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
  }

  export type BookingCreateWithoutReviewsInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookingsInput
    guest: UserCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutReviewsInput = {
    id?: string
    propertyId: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutReviewsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type PropertyUpsertWithoutReviewsInput = {
    update: XOR<PropertyUpdateWithoutReviewsInput, PropertyUncheckedUpdateWithoutReviewsInput>
    create: XOR<PropertyCreateWithoutReviewsInput, PropertyUncheckedCreateWithoutReviewsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutReviewsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutReviewsInput, PropertyUncheckedUpdateWithoutReviewsInput>
  }

  export type PropertyUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BookingUpsertWithoutReviewsInput = {
    update: XOR<BookingUpdateWithoutReviewsInput, BookingUncheckedUpdateWithoutReviewsInput>
    create: XOR<BookingCreateWithoutReviewsInput, BookingUncheckedCreateWithoutReviewsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutReviewsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutReviewsInput, BookingUncheckedUpdateWithoutReviewsInput>
  }

  export type BookingUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookingsNestedInput
    guest?: UserUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type PropertyCreateWithoutMaintenanceInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutMaintenanceInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutMaintenanceInput, PropertyUncheckedCreateWithoutMaintenanceInput>
  }

  export type BookingCreateWithoutMaintenanceInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookingsInput
    guest: UserCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutMaintenanceInput = {
    id?: string
    propertyId: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutMaintenanceInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutMaintenanceInput, BookingUncheckedCreateWithoutMaintenanceInput>
  }

  export type PropertyUpsertWithoutMaintenanceInput = {
    update: XOR<PropertyUpdateWithoutMaintenanceInput, PropertyUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<PropertyCreateWithoutMaintenanceInput, PropertyUncheckedCreateWithoutMaintenanceInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutMaintenanceInput, PropertyUncheckedUpdateWithoutMaintenanceInput>
  }

  export type PropertyUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type BookingUpsertWithoutMaintenanceInput = {
    update: XOR<BookingUpdateWithoutMaintenanceInput, BookingUncheckedUpdateWithoutMaintenanceInput>
    create: XOR<BookingCreateWithoutMaintenanceInput, BookingUncheckedCreateWithoutMaintenanceInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutMaintenanceInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutMaintenanceInput, BookingUncheckedUpdateWithoutMaintenanceInput>
  }

  export type BookingUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookingsNestedInput
    guest?: UserUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutMaintenanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingCreateWithoutMessagesInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookingsInput
    guest: UserCreateNestedOneWithoutBookingsInput
    payments?: PaymentCreateNestedManyWithoutBookingInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutMessagesInput = {
    id?: string
    propertyId: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutBookingInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutMessagesInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutMessagesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutMessagesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
  }

  export type BookingUpsertWithoutMessagesInput = {
    update: XOR<BookingUpdateWithoutMessagesInput, BookingUncheckedUpdateWithoutMessagesInput>
    create: XOR<BookingCreateWithoutMessagesInput, BookingUncheckedCreateWithoutMessagesInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutMessagesInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutMessagesInput, BookingUncheckedUpdateWithoutMessagesInput>
  }

  export type BookingUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookingsNestedInput
    guest?: UserUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserUpsertWithoutMessagesInput = {
    update: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
    create: XOR<UserCreateWithoutMessagesInput, UserUncheckedCreateWithoutMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMessagesInput, UserUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type BookingCreateWithoutPaymentsInput = {
    id?: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutBookingsInput
    guest: UserCreateNestedOneWithoutBookingsInput
    reviews?: ReviewCreateNestedManyWithoutBookingInput
    messages?: MessageCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentsInput = {
    id?: string
    propertyId: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: ReviewUncheckedCreateNestedManyWithoutBookingInput
    messages?: MessageUncheckedCreateNestedManyWithoutBookingInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentsInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
  }

  export type PropertyCreateWithoutPaymentsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPaymentsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPaymentsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
  }

  export type BookingUpsertWithoutPaymentsInput = {
    update: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
    create: XOR<BookingCreateWithoutPaymentsInput, BookingUncheckedCreateWithoutPaymentsInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentsInput, BookingUncheckedUpdateWithoutPaymentsInput>
  }

  export type BookingUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookingsNestedInput
    guest?: UserUpdateOneRequiredWithoutBookingsNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type PropertyUpsertWithoutPaymentsInput = {
    update: XOR<PropertyUpdateWithoutPaymentsInput, PropertyUncheckedUpdateWithoutPaymentsInput>
    create: XOR<PropertyCreateWithoutPaymentsInput, PropertyUncheckedCreateWithoutPaymentsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutPaymentsInput, PropertyUncheckedUpdateWithoutPaymentsInput>
  }

  export type PropertyUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutRoomsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutRoomsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutRoomsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutRoomsInput, PropertyUncheckedCreateWithoutRoomsInput>
  }

  export type UserCreateWithoutRoomsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutRoomsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutRoomsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput>
  }

  export type RoomContentCreateWithoutRoomInput = {
    id?: string
    highlightsGr?: string | null
    highlightsEn?: string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: string | null
    floorPlanUrl?: string | null
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomContentUncheckedCreateWithoutRoomInput = {
    id?: string
    highlightsGr?: string | null
    highlightsEn?: string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: string | null
    floorPlanUrl?: string | null
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomContentCreateOrConnectWithoutRoomInput = {
    where: RoomContentWhereUniqueInput
    create: XOR<RoomContentCreateWithoutRoomInput, RoomContentUncheckedCreateWithoutRoomInput>
  }

  export type RoomAvailabilityRuleCreateWithoutRoomInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    isAvailable?: boolean
    reason?: string | null
    priceOverride?: number | null
    minStayOverride?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAvailabilityRuleUncheckedCreateWithoutRoomInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    isAvailable?: boolean
    reason?: string | null
    priceOverride?: number | null
    minStayOverride?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAvailabilityRuleCreateOrConnectWithoutRoomInput = {
    where: RoomAvailabilityRuleWhereUniqueInput
    create: XOR<RoomAvailabilityRuleCreateWithoutRoomInput, RoomAvailabilityRuleUncheckedCreateWithoutRoomInput>
  }

  export type RoomAvailabilityRuleCreateManyRoomInputEnvelope = {
    data: RoomAvailabilityRuleCreateManyRoomInput | RoomAvailabilityRuleCreateManyRoomInput[]
  }

  export type PropertyUpsertWithoutRoomsInput = {
    update: XOR<PropertyUpdateWithoutRoomsInput, PropertyUncheckedUpdateWithoutRoomsInput>
    create: XOR<PropertyCreateWithoutRoomsInput, PropertyUncheckedCreateWithoutRoomsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutRoomsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutRoomsInput, PropertyUncheckedUpdateWithoutRoomsInput>
  }

  export type PropertyUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutRoomsInput = {
    update: XOR<UserUpdateWithoutRoomsInput, UserUncheckedUpdateWithoutRoomsInput>
    create: XOR<UserCreateWithoutRoomsInput, UserUncheckedCreateWithoutRoomsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoomsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoomsInput, UserUncheckedUpdateWithoutRoomsInput>
  }

  export type UserUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutRoomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type RoomContentUpsertWithoutRoomInput = {
    update: XOR<RoomContentUpdateWithoutRoomInput, RoomContentUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomContentCreateWithoutRoomInput, RoomContentUncheckedCreateWithoutRoomInput>
    where?: RoomContentWhereInput
  }

  export type RoomContentUpdateToOneWithWhereWithoutRoomInput = {
    where?: RoomContentWhereInput
    data: XOR<RoomContentUpdateWithoutRoomInput, RoomContentUncheckedUpdateWithoutRoomInput>
  }

  export type RoomContentUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightsGr?: NullableStringFieldUpdateOperationsInput | string | null
    highlightsEn?: NullableStringFieldUpdateOperationsInput | string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: NullableStringFieldUpdateOperationsInput | string | null
    floorPlanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomContentUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    highlightsGr?: NullableStringFieldUpdateOperationsInput | string | null
    highlightsEn?: NullableStringFieldUpdateOperationsInput | string | null
    featuresGr?: NullableJsonNullValueInput | InputJsonValue
    featuresEn?: NullableJsonNullValueInput | InputJsonValue
    virtualTourUrl?: NullableStringFieldUpdateOperationsInput | string | null
    floorPlanUrl?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    amenitiesDetails?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleUpsertWithWhereUniqueWithoutRoomInput = {
    where: RoomAvailabilityRuleWhereUniqueInput
    update: XOR<RoomAvailabilityRuleUpdateWithoutRoomInput, RoomAvailabilityRuleUncheckedUpdateWithoutRoomInput>
    create: XOR<RoomAvailabilityRuleCreateWithoutRoomInput, RoomAvailabilityRuleUncheckedCreateWithoutRoomInput>
  }

  export type RoomAvailabilityRuleUpdateWithWhereUniqueWithoutRoomInput = {
    where: RoomAvailabilityRuleWhereUniqueInput
    data: XOR<RoomAvailabilityRuleUpdateWithoutRoomInput, RoomAvailabilityRuleUncheckedUpdateWithoutRoomInput>
  }

  export type RoomAvailabilityRuleUpdateManyWithWhereWithoutRoomInput = {
    where: RoomAvailabilityRuleScalarWhereInput
    data: XOR<RoomAvailabilityRuleUpdateManyMutationInput, RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomInput>
  }

  export type RoomAvailabilityRuleScalarWhereInput = {
    AND?: RoomAvailabilityRuleScalarWhereInput | RoomAvailabilityRuleScalarWhereInput[]
    OR?: RoomAvailabilityRuleScalarWhereInput[]
    NOT?: RoomAvailabilityRuleScalarWhereInput | RoomAvailabilityRuleScalarWhereInput[]
    id?: StringFilter<"RoomAvailabilityRule"> | string
    roomId?: StringFilter<"RoomAvailabilityRule"> | string
    startDate?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    endDate?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    isAvailable?: BoolFilter<"RoomAvailabilityRule"> | boolean
    reason?: StringNullableFilter<"RoomAvailabilityRule"> | string | null
    priceOverride?: FloatNullableFilter<"RoomAvailabilityRule"> | number | null
    minStayOverride?: IntNullableFilter<"RoomAvailabilityRule"> | number | null
    createdAt?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
    updatedAt?: DateTimeFilter<"RoomAvailabilityRule"> | Date | string
  }

  export type UserCreateWithoutPropertyGroupsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutPropertyGroupsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutPropertyGroupsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPropertyGroupsInput, UserUncheckedCreateWithoutPropertyGroupsInput>
  }

  export type PropertyCreateWithoutPropertyGroupInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutPropertyGroupInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutPropertyGroupInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutPropertyGroupInput, PropertyUncheckedCreateWithoutPropertyGroupInput>
  }

  export type PropertyCreateManyPropertyGroupInputEnvelope = {
    data: PropertyCreateManyPropertyGroupInput | PropertyCreateManyPropertyGroupInput[]
  }

  export type UserUpsertWithoutPropertyGroupsInput = {
    update: XOR<UserUpdateWithoutPropertyGroupsInput, UserUncheckedUpdateWithoutPropertyGroupsInput>
    create: XOR<UserCreateWithoutPropertyGroupsInput, UserUncheckedCreateWithoutPropertyGroupsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPropertyGroupsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPropertyGroupsInput, UserUncheckedUpdateWithoutPropertyGroupsInput>
  }

  export type UserUpdateWithoutPropertyGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutPropertyGroupsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type PropertyUpsertWithWhereUniqueWithoutPropertyGroupInput = {
    where: PropertyWhereUniqueInput
    update: XOR<PropertyUpdateWithoutPropertyGroupInput, PropertyUncheckedUpdateWithoutPropertyGroupInput>
    create: XOR<PropertyCreateWithoutPropertyGroupInput, PropertyUncheckedCreateWithoutPropertyGroupInput>
  }

  export type PropertyUpdateWithWhereUniqueWithoutPropertyGroupInput = {
    where: PropertyWhereUniqueInput
    data: XOR<PropertyUpdateWithoutPropertyGroupInput, PropertyUncheckedUpdateWithoutPropertyGroupInput>
  }

  export type PropertyUpdateManyWithWhereWithoutPropertyGroupInput = {
    where: PropertyScalarWhereInput
    data: XOR<PropertyUpdateManyMutationInput, PropertyUncheckedUpdateManyWithoutPropertyGroupInput>
  }

  export type PropertyCreateWithoutCleaningSchedulesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutCleaningSchedulesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutCleaningSchedulesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutCleaningSchedulesInput, PropertyUncheckedCreateWithoutCleaningSchedulesInput>
  }

  export type UserCreateWithoutCleaningSchedulesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutCleaningSchedulesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutCleaningSchedulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCleaningSchedulesInput, UserUncheckedCreateWithoutCleaningSchedulesInput>
  }

  export type PropertyUpsertWithoutCleaningSchedulesInput = {
    update: XOR<PropertyUpdateWithoutCleaningSchedulesInput, PropertyUncheckedUpdateWithoutCleaningSchedulesInput>
    create: XOR<PropertyCreateWithoutCleaningSchedulesInput, PropertyUncheckedCreateWithoutCleaningSchedulesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutCleaningSchedulesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutCleaningSchedulesInput, PropertyUncheckedUpdateWithoutCleaningSchedulesInput>
  }

  export type PropertyUpdateWithoutCleaningSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutCleaningSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutCleaningSchedulesInput = {
    update: XOR<UserUpdateWithoutCleaningSchedulesInput, UserUncheckedUpdateWithoutCleaningSchedulesInput>
    create: XOR<UserCreateWithoutCleaningSchedulesInput, UserUncheckedCreateWithoutCleaningSchedulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCleaningSchedulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCleaningSchedulesInput, UserUncheckedUpdateWithoutCleaningSchedulesInput>
  }

  export type UserUpdateWithoutCleaningSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutCleaningSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type PropertyCreateWithoutAnalyticsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutAnalyticsInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutAnalyticsInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutAnalyticsInput, PropertyUncheckedCreateWithoutAnalyticsInput>
  }

  export type PropertyUpsertWithoutAnalyticsInput = {
    update: XOR<PropertyUpdateWithoutAnalyticsInput, PropertyUncheckedUpdateWithoutAnalyticsInput>
    create: XOR<PropertyCreateWithoutAnalyticsInput, PropertyUncheckedCreateWithoutAnalyticsInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutAnalyticsInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutAnalyticsInput, PropertyUncheckedUpdateWithoutAnalyticsInput>
  }

  export type PropertyUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutAnalyticsInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyCreateWithoutNotesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutNotesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutNotesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutNotesInput, PropertyUncheckedCreateWithoutNotesInput>
  }

  export type PropertyUpsertWithoutNotesInput = {
    update: XOR<PropertyUpdateWithoutNotesInput, PropertyUncheckedUpdateWithoutNotesInput>
    create: XOR<PropertyCreateWithoutNotesInput, PropertyUncheckedCreateWithoutNotesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutNotesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutNotesInput, PropertyUncheckedUpdateWithoutNotesInput>
  }

  export type PropertyUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutNotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryCreateNestedManyWithoutAssigneeInput
  }

  export type UserUncheckedCreateWithoutAuditLogsInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
    inquiries?: InquiryUncheckedCreateNestedManyWithoutAssigneeInput
  }

  export type UserCreateOrConnectWithoutAuditLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
  }

  export type UserUpsertWithoutAuditLogsInput = {
    update: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
    create: XOR<UserCreateWithoutAuditLogsInput, UserUncheckedCreateWithoutAuditLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogsInput, UserUncheckedUpdateWithoutAuditLogsInput>
  }

  export type UserUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUpdateManyWithoutAssigneeNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutAssigneeNestedInput
  }

  export type ContentMediaCreateWithoutContentInput = {
    id?: string
    order?: number
    media: MediaCreateNestedOneWithoutContentInput
  }

  export type ContentMediaUncheckedCreateWithoutContentInput = {
    id?: string
    mediaId: string
    order?: number
  }

  export type ContentMediaCreateOrConnectWithoutContentInput = {
    where: ContentMediaWhereUniqueInput
    create: XOR<ContentMediaCreateWithoutContentInput, ContentMediaUncheckedCreateWithoutContentInput>
  }

  export type ContentMediaCreateManyContentInputEnvelope = {
    data: ContentMediaCreateManyContentInput | ContentMediaCreateManyContentInput[]
  }

  export type ContentMediaUpsertWithWhereUniqueWithoutContentInput = {
    where: ContentMediaWhereUniqueInput
    update: XOR<ContentMediaUpdateWithoutContentInput, ContentMediaUncheckedUpdateWithoutContentInput>
    create: XOR<ContentMediaCreateWithoutContentInput, ContentMediaUncheckedCreateWithoutContentInput>
  }

  export type ContentMediaUpdateWithWhereUniqueWithoutContentInput = {
    where: ContentMediaWhereUniqueInput
    data: XOR<ContentMediaUpdateWithoutContentInput, ContentMediaUncheckedUpdateWithoutContentInput>
  }

  export type ContentMediaUpdateManyWithWhereWithoutContentInput = {
    where: ContentMediaScalarWhereInput
    data: XOR<ContentMediaUpdateManyMutationInput, ContentMediaUncheckedUpdateManyWithoutContentInput>
  }

  export type ContentMediaScalarWhereInput = {
    AND?: ContentMediaScalarWhereInput | ContentMediaScalarWhereInput[]
    OR?: ContentMediaScalarWhereInput[]
    NOT?: ContentMediaScalarWhereInput | ContentMediaScalarWhereInput[]
    id?: StringFilter<"ContentMedia"> | string
    contentId?: StringFilter<"ContentMedia"> | string
    mediaId?: StringFilter<"ContentMedia"> | string
    order?: IntFilter<"ContentMedia"> | number
  }

  export type ContentCreateWithoutMediaInput = {
    id?: string
    page: string
    section: string
    key: string
    contentGr?: string | null
    contentEn?: string | null
    type?: $Enums.ContentType
    order?: number
    active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentUncheckedCreateWithoutMediaInput = {
    id?: string
    page: string
    section: string
    key: string
    contentGr?: string | null
    contentEn?: string | null
    type?: $Enums.ContentType
    order?: number
    active?: boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: string | null
    metaTitleEn?: string | null
    metaDescriptionGr?: string | null
    metaDescriptionEn?: string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContentCreateOrConnectWithoutMediaInput = {
    where: ContentWhereUniqueInput
    create: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
  }

  export type MediaCreateWithoutContentInput = {
    id?: string
    filename: string
    originalName: string
    url: string
    thumbnailUrl?: string | null
    category?: $Enums.MediaCategory
    altTextGr?: string | null
    altTextEn?: string | null
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaUncheckedCreateWithoutContentInput = {
    id?: string
    filename: string
    originalName: string
    url: string
    thumbnailUrl?: string | null
    category?: $Enums.MediaCategory
    altTextGr?: string | null
    altTextEn?: string | null
    mimeType: string
    size: number
    width?: number | null
    height?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MediaCreateOrConnectWithoutContentInput = {
    where: MediaWhereUniqueInput
    create: XOR<MediaCreateWithoutContentInput, MediaUncheckedCreateWithoutContentInput>
  }

  export type ContentUpsertWithoutMediaInput = {
    update: XOR<ContentUpdateWithoutMediaInput, ContentUncheckedUpdateWithoutMediaInput>
    create: XOR<ContentCreateWithoutMediaInput, ContentUncheckedCreateWithoutMediaInput>
    where?: ContentWhereInput
  }

  export type ContentUpdateToOneWithWhereWithoutMediaInput = {
    where?: ContentWhereInput
    data: XOR<ContentUpdateWithoutMediaInput, ContentUncheckedUpdateWithoutMediaInput>
  }

  export type ContentUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    page?: StringFieldUpdateOperationsInput | string
    section?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    contentGr?: NullableStringFieldUpdateOperationsInput | string | null
    contentEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    metadata?: NullableJsonNullValueInput | InputJsonValue
    metaTitleGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaTitleEn?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    keywords?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUpsertWithoutContentInput = {
    update: XOR<MediaUpdateWithoutContentInput, MediaUncheckedUpdateWithoutContentInput>
    create: XOR<MediaCreateWithoutContentInput, MediaUncheckedCreateWithoutContentInput>
    where?: MediaWhereInput
  }

  export type MediaUpdateToOneWithWhereWithoutContentInput = {
    where?: MediaWhereInput
    data: XOR<MediaUpdateWithoutContentInput, MediaUncheckedUpdateWithoutContentInput>
  }

  export type MediaUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMediaCategoryFieldUpdateOperationsInput | $Enums.MediaCategory
    altTextGr?: NullableStringFieldUpdateOperationsInput | string | null
    altTextEn?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    thumbnailUrl?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumMediaCategoryFieldUpdateOperationsInput | $Enums.MediaCategory
    altTextGr?: NullableStringFieldUpdateOperationsInput | string | null
    altTextEn?: NullableStringFieldUpdateOperationsInput | string | null
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    width?: NullableIntFieldUpdateOperationsInput | number | null
    height?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentMediaCreateWithoutMediaInput = {
    id?: string
    order?: number
    content: ContentCreateNestedOneWithoutMediaInput
  }

  export type ContentMediaUncheckedCreateWithoutMediaInput = {
    id?: string
    contentId: string
    order?: number
  }

  export type ContentMediaCreateOrConnectWithoutMediaInput = {
    where: ContentMediaWhereUniqueInput
    create: XOR<ContentMediaCreateWithoutMediaInput, ContentMediaUncheckedCreateWithoutMediaInput>
  }

  export type ContentMediaCreateManyMediaInputEnvelope = {
    data: ContentMediaCreateManyMediaInput | ContentMediaCreateManyMediaInput[]
  }

  export type ContentMediaUpsertWithWhereUniqueWithoutMediaInput = {
    where: ContentMediaWhereUniqueInput
    update: XOR<ContentMediaUpdateWithoutMediaInput, ContentMediaUncheckedUpdateWithoutMediaInput>
    create: XOR<ContentMediaCreateWithoutMediaInput, ContentMediaUncheckedCreateWithoutMediaInput>
  }

  export type ContentMediaUpdateWithWhereUniqueWithoutMediaInput = {
    where: ContentMediaWhereUniqueInput
    data: XOR<ContentMediaUpdateWithoutMediaInput, ContentMediaUncheckedUpdateWithoutMediaInput>
  }

  export type ContentMediaUpdateManyWithWhereWithoutMediaInput = {
    where: ContentMediaScalarWhereInput
    data: XOR<ContentMediaUpdateManyMutationInput, ContentMediaUncheckedUpdateManyWithoutMediaInput>
  }

  export type RoomCreateWithoutRoomContentInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRoomsInput
    owner: UserCreateNestedOneWithoutRoomsInput
    availabilityRules?: RoomAvailabilityRuleCreateNestedManyWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutRoomContentInput = {
    id?: string
    propertyId: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    availabilityRules?: RoomAvailabilityRuleUncheckedCreateNestedManyWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutRoomContentInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutRoomContentInput, RoomUncheckedCreateWithoutRoomContentInput>
  }

  export type RoomUpsertWithoutRoomContentInput = {
    update: XOR<RoomUpdateWithoutRoomContentInput, RoomUncheckedUpdateWithoutRoomContentInput>
    create: XOR<RoomCreateWithoutRoomContentInput, RoomUncheckedCreateWithoutRoomContentInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutRoomContentInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutRoomContentInput, RoomUncheckedUpdateWithoutRoomContentInput>
  }

  export type RoomUpdateWithoutRoomContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRoomsNestedInput
    owner?: UserUpdateOneRequiredWithoutRoomsNestedInput
    availabilityRules?: RoomAvailabilityRuleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutRoomContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    availabilityRules?: RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomCreateWithoutAvailabilityRulesInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    property: PropertyCreateNestedOneWithoutRoomsInput
    owner: UserCreateNestedOneWithoutRoomsInput
    roomContent?: RoomContentCreateNestedOneWithoutRoomInput
  }

  export type RoomUncheckedCreateWithoutAvailabilityRulesInput = {
    id?: string
    propertyId: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    roomContent?: RoomContentUncheckedCreateNestedOneWithoutRoomInput
  }

  export type RoomCreateOrConnectWithoutAvailabilityRulesInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutAvailabilityRulesInput, RoomUncheckedCreateWithoutAvailabilityRulesInput>
  }

  export type RoomUpsertWithoutAvailabilityRulesInput = {
    update: XOR<RoomUpdateWithoutAvailabilityRulesInput, RoomUncheckedUpdateWithoutAvailabilityRulesInput>
    create: XOR<RoomCreateWithoutAvailabilityRulesInput, RoomUncheckedCreateWithoutAvailabilityRulesInput>
    where?: RoomWhereInput
  }

  export type RoomUpdateToOneWithWhereWithoutAvailabilityRulesInput = {
    where?: RoomWhereInput
    data: XOR<RoomUpdateWithoutAvailabilityRulesInput, RoomUncheckedUpdateWithoutAvailabilityRulesInput>
  }

  export type RoomUpdateWithoutAvailabilityRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRoomsNestedInput
    owner?: UserUpdateOneRequiredWithoutRoomsNestedInput
    roomContent?: RoomContentUpdateOneWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutAvailabilityRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomContent?: RoomContentUncheckedUpdateOneWithoutRoomNestedInput
  }

  export type PropertyCreateWithoutInquiriesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutPropertiesInput
    bookings?: BookingCreateNestedManyWithoutPropertyInput
    reviews?: ReviewCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestCreateNestedManyWithoutPropertyInput
    rooms?: RoomCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutPropertyInput
    propertyGroup?: PropertyGroupCreateNestedOneWithoutPropertiesInput
    payments?: PaymentCreateNestedManyWithoutPropertyInput
  }

  export type PropertyUncheckedCreateWithoutInquiriesInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutPropertyInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutPropertyInput
    amenities?: PropertyAmenityUncheckedCreateNestedManyWithoutPropertyInput
    availability?: PropertyAvailabilityUncheckedCreateNestedManyWithoutPropertyInput
    maintenance?: MaintenanceRequestUncheckedCreateNestedManyWithoutPropertyInput
    rooms?: RoomUncheckedCreateNestedManyWithoutPropertyInput
    notes?: PropertyNoteUncheckedCreateNestedManyWithoutPropertyInput
    analytics?: PropertyAnalyticsUncheckedCreateNestedManyWithoutPropertyInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutPropertyInput
    payments?: PaymentUncheckedCreateNestedManyWithoutPropertyInput
  }

  export type PropertyCreateOrConnectWithoutInquiriesInput = {
    where: PropertyWhereUniqueInput
    create: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
  }

  export type UserCreateWithoutInquiriesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyCreateNestedManyWithoutOwnerInput
    bookings?: BookingCreateNestedManyWithoutGuestInput
    reviews?: ReviewCreateNestedManyWithoutGuestInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    messages?: MessageCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupCreateNestedManyWithoutOwnerInput
    rooms?: RoomCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutInquiriesInput = {
    id?: string
    email: string
    name?: string | null
    phone?: string | null
    password?: string | null
    role?: $Enums.UserRole
    avatar?: string | null
    isActive?: boolean
    mfaEnabled?: boolean
    mfaSecret?: string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: boolean
    phoneVerified?: boolean
    stripeAccountId?: string | null
    stripeAccountStatus?: string | null
    preferredCurrency?: string | null
    preferredLanguage?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    properties?: PropertyUncheckedCreateNestedManyWithoutOwnerInput
    bookings?: BookingUncheckedCreateNestedManyWithoutGuestInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutGuestInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    messages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    auditLogs?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    propertyGroups?: PropertyGroupUncheckedCreateNestedManyWithoutOwnerInput
    rooms?: RoomUncheckedCreateNestedManyWithoutOwnerInput
    cleaningSchedules?: CleaningScheduleUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutInquiriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
  }

  export type PropertyUpsertWithoutInquiriesInput = {
    update: XOR<PropertyUpdateWithoutInquiriesInput, PropertyUncheckedUpdateWithoutInquiriesInput>
    create: XOR<PropertyCreateWithoutInquiriesInput, PropertyUncheckedCreateWithoutInquiriesInput>
    where?: PropertyWhereInput
  }

  export type PropertyUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: PropertyWhereInput
    data: XOR<PropertyUpdateWithoutInquiriesInput, PropertyUncheckedUpdateWithoutInquiriesInput>
  }

  export type PropertyUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type UserUpsertWithoutInquiriesInput = {
    update: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
    create: XOR<UserCreateWithoutInquiriesInput, UserUncheckedCreateWithoutInquiriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInquiriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInquiriesInput, UserUncheckedUpdateWithoutInquiriesInput>
  }

  export type UserUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    messages?: MessageUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutInquiriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    mfaEnabled?: BoolFieldUpdateOperationsInput | boolean
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaBackupCodes?: NullableJsonNullValueInput | InputJsonValue
    emailVerified?: BoolFieldUpdateOperationsInput | boolean
    phoneVerified?: BoolFieldUpdateOperationsInput | boolean
    stripeAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeAccountStatus?: NullableStringFieldUpdateOperationsInput | string | null
    preferredCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    preferredLanguage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutOwnerNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutGuestNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutGuestNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    messages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    auditLogs?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    propertyGroups?: PropertyGroupUncheckedUpdateManyWithoutOwnerNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutOwnerNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type PropertyCreateManyOwnerInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    propertyGroupId?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyGuestInput = {
    id?: string
    propertyId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyGuestInput = {
    id?: string
    propertyId: string
    bookingId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    message: string
    isRead?: boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    bookingId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type PropertyGroupCreateManyOwnerInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    description?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateManyOwnerInput = {
    id?: string
    propertyId: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningScheduleCreateManyOwnerInput = {
    id?: string
    propertyId: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateManyAssigneeInput = {
    id?: string
    propertyId: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    propertyGroup?: PropertyGroupUpdateOneWithoutPropertiesNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    propertyGroupId?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReviewsNestedInput
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutGuestInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    changes?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyGroupUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUpdateManyWithoutPropertyGroupNestedInput
  }

  export type PropertyGroupUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    properties?: PropertyUncheckedUpdateManyWithoutPropertyGroupNestedInput
  }

  export type PropertyGroupUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutRoomsNestedInput
    roomContent?: RoomContentUpdateOneWithoutRoomNestedInput
    availabilityRules?: RoomAvailabilityRuleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomContent?: RoomContentUncheckedUpdateOneWithoutRoomNestedInput
    availabilityRules?: RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutCleaningSchedulesNestedInput
  }

  export type CleaningScheduleUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyWithoutAssigneeInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyPropertyInput = {
    id?: string
    guestId: string
    status?: $Enums.BookingStatus
    paymentStatus?: $Enums.PaymentStatus
    checkIn: Date | string
    checkOut: Date | string
    guests: number
    totalPrice: number
    basePrice: number
    cleaningFee?: number | null
    serviceFee?: number | null
    taxes?: number | null
    currency?: string
    ownerRevenue?: number | null
    platformFee?: number | null
    source?: $Enums.BookingSource
    externalId?: string | null
    externalPlatform?: string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: number | null
    commissionAmount?: number | null
    netRevenue?: number | null
    externalGuestId?: string | null
    iCalUid?: string | null
    lastSyncedAt?: Date | string | null
    roomId?: string | null
    roomName?: string | null
    guestName: string
    guestEmail: string
    guestPhone?: string | null
    specialRequests?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyPropertyInput = {
    id?: string
    bookingId: string
    guestId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAmenityCreateManyPropertyInput = {
    id?: string
    amenityId: string
  }

  export type PropertyAvailabilityCreateManyPropertyInput = {
    id?: string
    date: Date | string
    available?: boolean
    price?: number | null
    minStay?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MaintenanceRequestCreateManyPropertyInput = {
    id?: string
    bookingId?: string | null
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomCreateManyPropertyInput = {
    id?: string
    name: string
    nameGr?: string | null
    nameEn?: string | null
    type: $Enums.RoomType
    capacity: number
    maxAdults?: number | null
    maxChildren?: number | null
    maxInfants?: number | null
    basePrice: number
    isBookable?: boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: string | null
    descriptionEn?: string | null
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyNoteCreateManyPropertyInput = {
    id?: string
    type: $Enums.NoteType
    title: string
    content: string
    isPrivate?: boolean
    createdBy: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyAnalyticsCreateManyPropertyInput = {
    id?: string
    period: $Enums.AnalyticsPeriod
    periodStart: Date | string
    periodEnd: Date | string
    totalRevenue: number
    totalCosts: number
    cleaningCosts: number
    maintenanceCosts: number
    platformFees: number
    netProfit: number
    profitMargin: number
    totalBookings: number
    cancelledBookings: number
    occupancyRate: number
    averageDailyRate: number
    revenuePerAvailableRoom?: number | null
    averageRating?: number | null
    averageCleanlinessRating?: number | null
    totalReviews: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CleaningScheduleCreateManyPropertyInput = {
    id?: string
    frequency: $Enums.CleaningFrequency
    lastCleaned?: Date | string | null
    nextCleaning?: Date | string | null
    assignedCleaner?: string | null
    ownerId: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyPropertyInput = {
    id?: string
    bookingId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InquiryCreateManyPropertyInput = {
    id?: string
    name: string
    email: string
    phone?: string | null
    message: string
    status?: $Enums.InquiryStatus
    priority?: $Enums.InquiryPriority
    respondedAt?: Date | string | null
    respondedBy?: string | null
    response?: string | null
    adminNotes?: string | null
    assignedTo?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    guest?: UserUpdateOneRequiredWithoutBookingsNestedInput
    payments?: PaymentUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUpdateManyWithoutBookingNestedInput
    messages?: MessageUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutBookingNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutBookingNestedInput
    messages?: MessageUncheckedUpdateManyWithoutBookingNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    checkIn?: DateTimeFieldUpdateOperationsInput | Date | string
    checkOut?: DateTimeFieldUpdateOperationsInput | Date | string
    guests?: IntFieldUpdateOperationsInput | number
    totalPrice?: FloatFieldUpdateOperationsInput | number
    basePrice?: FloatFieldUpdateOperationsInput | number
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFee?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    currency?: StringFieldUpdateOperationsInput | string
    ownerRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    platformFee?: NullableFloatFieldUpdateOperationsInput | number | null
    source?: EnumBookingSourceFieldUpdateOperationsInput | $Enums.BookingSource
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    externalPlatform?: NullableStringFieldUpdateOperationsInput | string | null
    externalData?: NullableJsonNullValueInput | InputJsonValue
    commissionRate?: NullableFloatFieldUpdateOperationsInput | number | null
    commissionAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    netRevenue?: NullableFloatFieldUpdateOperationsInput | number | null
    externalGuestId?: NullableStringFieldUpdateOperationsInput | string | null
    iCalUid?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    roomName?: NullableStringFieldUpdateOperationsInput | string | null
    guestName?: StringFieldUpdateOperationsInput | string
    guestEmail?: StringFieldUpdateOperationsInput | string
    guestPhone?: NullableStringFieldUpdateOperationsInput | string | null
    specialRequests?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutReviewsNestedInput
    guest?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAmenityUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenity?: AmenityUpdateOneRequiredWithoutPropertiesNestedInput
  }

  export type PropertyAmenityUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenityId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyAmenityUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amenityId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyAvailabilityUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAvailabilityUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAvailabilityUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    available?: BoolFieldUpdateOperationsInput | boolean
    price?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneWithoutMaintenanceNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutRoomsNestedInput
    roomContent?: RoomContentUpdateOneWithoutRoomNestedInput
    availabilityRules?: RoomAvailabilityRuleUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    roomContent?: RoomContentUncheckedUpdateOneWithoutRoomNestedInput
    availabilityRules?: RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomNestedInput
  }

  export type RoomUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameGr?: NullableStringFieldUpdateOperationsInput | string | null
    nameEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    capacity?: IntFieldUpdateOperationsInput | number
    maxAdults?: NullableIntFieldUpdateOperationsInput | number | null
    maxChildren?: NullableIntFieldUpdateOperationsInput | number | null
    maxInfants?: NullableIntFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    isBookable?: BoolFieldUpdateOperationsInput | boolean
    amenities?: NullableJsonNullValueInput | InputJsonValue
    images?: NullableJsonNullValueInput | InputJsonValue
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyNoteUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyNoteUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyNoteUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNoteTypeFieldUpdateOperationsInput | $Enums.NoteType
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isPrivate?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAnalyticsUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAnalyticsUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAnalyticsUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    period?: EnumAnalyticsPeriodFieldUpdateOperationsInput | $Enums.AnalyticsPeriod
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    totalRevenue?: FloatFieldUpdateOperationsInput | number
    totalCosts?: FloatFieldUpdateOperationsInput | number
    cleaningCosts?: FloatFieldUpdateOperationsInput | number
    maintenanceCosts?: FloatFieldUpdateOperationsInput | number
    platformFees?: FloatFieldUpdateOperationsInput | number
    netProfit?: FloatFieldUpdateOperationsInput | number
    profitMargin?: FloatFieldUpdateOperationsInput | number
    totalBookings?: IntFieldUpdateOperationsInput | number
    cancelledBookings?: IntFieldUpdateOperationsInput | number
    occupancyRate?: FloatFieldUpdateOperationsInput | number
    averageDailyRate?: FloatFieldUpdateOperationsInput | number
    revenuePerAvailableRoom?: NullableFloatFieldUpdateOperationsInput | number | null
    averageRating?: NullableFloatFieldUpdateOperationsInput | number | null
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    totalReviews?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutCleaningSchedulesNestedInput
  }

  export type CleaningScheduleUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CleaningScheduleUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    frequency?: EnumCleaningFrequencyFieldUpdateOperationsInput | $Enums.CleaningFrequency
    lastCleaned?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nextCleaning?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    assignedCleaner?: NullableStringFieldUpdateOperationsInput | string | null
    ownerId?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assignee?: UserUpdateOneWithoutInquiriesNestedInput
  }

  export type InquiryUncheckedUpdateWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InquiryUncheckedUpdateManyWithoutPropertyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    message?: StringFieldUpdateOperationsInput | string
    status?: EnumInquiryStatusFieldUpdateOperationsInput | $Enums.InquiryStatus
    priority?: EnumInquiryPriorityFieldUpdateOperationsInput | $Enums.InquiryPriority
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    respondedBy?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    adminNotes?: NullableStringFieldUpdateOperationsInput | string | null
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyAmenityCreateManyAmenityInput = {
    id?: string
    propertyId: string
  }

  export type PropertyAmenityUpdateWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    property?: PropertyUpdateOneRequiredWithoutAmenitiesNestedInput
  }

  export type PropertyAmenityUncheckedUpdateWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type PropertyAmenityUncheckedUpdateManyWithoutAmenityInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentCreateManyBookingInput = {
    id?: string
    propertyId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    method: $Enums.PaymentMethod
    transactionId?: string | null
    stripePaymentIntentId?: string | null
    stripeChargeId?: string | null
    refundAmount?: number | null
    refundReason?: string | null
    refundedAt?: Date | string | null
    payoutId?: string | null
    payoutStatus?: string | null
    payoutScheduledFor?: Date | string | null
    processedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyBookingInput = {
    id?: string
    propertyId: string
    guestId: string
    rating: number
    cleanlinessRating?: number | null
    accuracyRating?: number | null
    communicationRating?: number | null
    locationRating?: number | null
    valueRating?: number | null
    title?: string | null
    comment?: string | null
    response?: string | null
    isPublic?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateManyBookingInput = {
    id?: string
    senderId: string
    content: string
    type?: $Enums.MessageType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MaintenanceRequestCreateManyBookingInput = {
    id?: string
    propertyId: string
    title: string
    description: string
    priority?: $Enums.MaintenancePriority
    status?: $Enums.MaintenanceStatus
    assignedTo?: string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    method?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    stripePaymentIntentId?: NullableStringFieldUpdateOperationsInput | string | null
    stripeChargeId?: NullableStringFieldUpdateOperationsInput | string | null
    refundAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    refundReason?: NullableStringFieldUpdateOperationsInput | string | null
    refundedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payoutId?: NullableStringFieldUpdateOperationsInput | string | null
    payoutStatus?: NullableStringFieldUpdateOperationsInput | string | null
    payoutScheduledFor?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    processedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutReviewsNestedInput
    guest?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    guestId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    cleanlinessRating?: NullableIntFieldUpdateOperationsInput | number | null
    accuracyRating?: NullableIntFieldUpdateOperationsInput | number | null
    communicationRating?: NullableIntFieldUpdateOperationsInput | number | null
    locationRating?: NullableIntFieldUpdateOperationsInput | number | null
    valueRating?: NullableIntFieldUpdateOperationsInput | number | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    response?: NullableStringFieldUpdateOperationsInput | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    type?: EnumMessageTypeFieldUpdateOperationsInput | $Enums.MessageType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    property?: PropertyUpdateOneRequiredWithoutMaintenanceNestedInput
  }

  export type MaintenanceRequestUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaintenanceRequestUncheckedUpdateManyWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    propertyId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    priority?: EnumMaintenancePriorityFieldUpdateOperationsInput | $Enums.MaintenancePriority
    status?: EnumMaintenanceStatusFieldUpdateOperationsInput | $Enums.MaintenanceStatus
    assignedTo?: NullableStringFieldUpdateOperationsInput | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleCreateManyRoomInput = {
    id?: string
    startDate: Date | string
    endDate: Date | string
    isAvailable?: boolean
    reason?: string | null
    priceOverride?: number | null
    minStayOverride?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoomAvailabilityRuleUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleUncheckedUpdateWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomAvailabilityRuleUncheckedUpdateManyWithoutRoomInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAvailable?: BoolFieldUpdateOperationsInput | boolean
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    priceOverride?: NullableFloatFieldUpdateOperationsInput | number | null
    minStayOverride?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PropertyCreateManyPropertyGroupInput = {
    id?: string
    titleGr: string
    titleEn: string
    descriptionGr?: string | null
    descriptionEn?: string | null
    type: $Enums.PropertyType
    status?: $Enums.PropertyStatus
    address: string
    city?: string
    country?: string
    latitude?: number | null
    longitude?: number | null
    postalCode?: string | null
    maxGuests: number
    bedrooms: number
    bathrooms: number
    area?: number | null
    basePrice: number
    currency?: string
    cleaningFee?: number | null
    serviceFeePercentage?: number | null
    taxes?: number | null
    taxRate?: number | null
    minStay?: number
    maxStay?: number | null
    advanceBooking?: number
    checkInTime?: string | null
    checkOutTime?: string | null
    cancellationPolicy?: $Enums.CancellationPolicy
    houseRules?: string | null
    petFriendly?: boolean
    smokingAllowed?: boolean
    partyAllowed?: boolean
    hasDynamicRooms?: boolean
    averageCleanlinessRating?: number | null
    lastCleaningDate?: Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PropertyUpdateWithoutPropertyGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutPropertiesNestedInput
    bookings?: BookingUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateWithoutPropertyGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutPropertyNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutPropertyNestedInput
    amenities?: PropertyAmenityUncheckedUpdateManyWithoutPropertyNestedInput
    availability?: PropertyAvailabilityUncheckedUpdateManyWithoutPropertyNestedInput
    maintenance?: MaintenanceRequestUncheckedUpdateManyWithoutPropertyNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutPropertyNestedInput
    notes?: PropertyNoteUncheckedUpdateManyWithoutPropertyNestedInput
    analytics?: PropertyAnalyticsUncheckedUpdateManyWithoutPropertyNestedInput
    cleaningSchedules?: CleaningScheduleUncheckedUpdateManyWithoutPropertyNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutPropertyNestedInput
    inquiries?: InquiryUncheckedUpdateManyWithoutPropertyNestedInput
  }

  export type PropertyUncheckedUpdateManyWithoutPropertyGroupInput = {
    id?: StringFieldUpdateOperationsInput | string
    titleGr?: StringFieldUpdateOperationsInput | string
    titleEn?: StringFieldUpdateOperationsInput | string
    descriptionGr?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionEn?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumPropertyTypeFieldUpdateOperationsInput | $Enums.PropertyType
    status?: EnumPropertyStatusFieldUpdateOperationsInput | $Enums.PropertyStatus
    address?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    country?: StringFieldUpdateOperationsInput | string
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    maxGuests?: IntFieldUpdateOperationsInput | number
    bedrooms?: IntFieldUpdateOperationsInput | number
    bathrooms?: IntFieldUpdateOperationsInput | number
    area?: NullableFloatFieldUpdateOperationsInput | number | null
    basePrice?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    cleaningFee?: NullableFloatFieldUpdateOperationsInput | number | null
    serviceFeePercentage?: NullableFloatFieldUpdateOperationsInput | number | null
    taxes?: NullableFloatFieldUpdateOperationsInput | number | null
    taxRate?: NullableFloatFieldUpdateOperationsInput | number | null
    minStay?: IntFieldUpdateOperationsInput | number
    maxStay?: NullableIntFieldUpdateOperationsInput | number | null
    advanceBooking?: IntFieldUpdateOperationsInput | number
    checkInTime?: NullableStringFieldUpdateOperationsInput | string | null
    checkOutTime?: NullableStringFieldUpdateOperationsInput | string | null
    cancellationPolicy?: EnumCancellationPolicyFieldUpdateOperationsInput | $Enums.CancellationPolicy
    houseRules?: NullableStringFieldUpdateOperationsInput | string | null
    petFriendly?: BoolFieldUpdateOperationsInput | boolean
    smokingAllowed?: BoolFieldUpdateOperationsInput | boolean
    partyAllowed?: BoolFieldUpdateOperationsInput | boolean
    hasDynamicRooms?: BoolFieldUpdateOperationsInput | boolean
    averageCleanlinessRating?: NullableFloatFieldUpdateOperationsInput | number | null
    lastCleaningDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    videos?: NullableJsonNullValueInput | InputJsonValue
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContentMediaCreateManyContentInput = {
    id?: string
    mediaId: string
    order?: number
  }

  export type ContentMediaUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    media?: MediaUpdateOneRequiredWithoutContentNestedInput
  }

  export type ContentMediaUncheckedUpdateWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ContentMediaUncheckedUpdateManyWithoutContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    mediaId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ContentMediaCreateManyMediaInput = {
    id?: string
    contentId: string
    order?: number
  }

  export type ContentMediaUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    content?: ContentUpdateOneRequiredWithoutMediaNestedInput
  }

  export type ContentMediaUncheckedUpdateWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type ContentMediaUncheckedUpdateManyWithoutMediaInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}